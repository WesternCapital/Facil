// Edit or remove this or the below line to regenerate on next build
// Hash: 99da4a77869e89186d6189f3aae650cbde7c314cd1116a7054e50e3ecc16170e

//////////////////////////////////////////
//
// THIS FILE IS AUTOMATICALLY GENERATED
//
// Facil 2.9.1+b7e2fe97203d01d8cb702cb9aca5b809530ee469
//
//////////////////////////////////////////

module DbGen

#nowarn "49"

open System
open System.ComponentModel
open System.Data
open System.Threading
open Microsoft.Data.SqlClient
open Microsoft.Data.SqlClient.Server
open Facil.Runtime.CSharp
open Facil.Runtime.GeneratedCodeUtils


module MyPreludeModule =
  let x = 2



[<EditorBrowsable(EditorBrowsableState.Never)>]
type InternalUseOnly = private | InternalUseOnly
[<EditorBrowsable(EditorBrowsableState.Never)>]
let internalUseOnlyValue = InternalUseOnly


module TableDtos =


  module ``dbo`` =


    type ``AllTypesNonNull`` =
      {
        ``Key``: int
        ``Bigint``: int64
        ``Binary``: byte []
        ``Bit``: bool
        ``Char``: string
        ``Date``: DateTime
        ``Datetime``: DateTime
        ``Datetime2``: DateTime
        ``Datetimeoffset``: DateTimeOffset
        ``Decimal``: decimal
        ``Float``: float
        ``Image``: byte []
        ``Int``: int
        ``Money``: decimal
        ``Nchar``: string
        ``Ntext``: string
        ``Numeric``: decimal
        ``Nvarchar``: string
        ``Real``: float32
        ``Smalldatetime``: DateTime
        ``Smallint``: int16
        ``Smallmoney``: decimal
        ``Text``: string
        ``Time``: TimeSpan
        ``Tinyint``: byte
        ``Uniqueidentifier``: Guid
        ``Varbinary``: byte []
        ``Varchar``: string
        ``Xml``: string
      }

      static member getPrimaryKey (dto: ``AllTypesNonNull``) =
        dto.``Key``

      static member inline create dto : ``AllTypesNonNull`` =
        {
          ``Key`` = (^a: (member ``Key``: _) dto)
          ``Bigint`` = (^a: (member ``Bigint``: _) dto)
          ``Binary`` = (^a: (member ``Binary``: _) dto)
          ``Bit`` = (^a: (member ``Bit``: _) dto)
          ``Char`` = (^a: (member ``Char``: _) dto)
          ``Date`` = (^a: (member ``Date``: _) dto)
          ``Datetime`` = (^a: (member ``Datetime``: _) dto)
          ``Datetime2`` = (^a: (member ``Datetime2``: _) dto)
          ``Datetimeoffset`` = (^a: (member ``Datetimeoffset``: _) dto)
          ``Decimal`` = (^a: (member ``Decimal``: _) dto)
          ``Float`` = (^a: (member ``Float``: _) dto)
          ``Image`` = (^a: (member ``Image``: _) dto)
          ``Int`` = (^a: (member ``Int``: _) dto)
          ``Money`` = (^a: (member ``Money``: _) dto)
          ``Nchar`` = (^a: (member ``Nchar``: _) dto)
          ``Ntext`` = (^a: (member ``Ntext``: _) dto)
          ``Numeric`` = (^a: (member ``Numeric``: _) dto)
          ``Nvarchar`` = (^a: (member ``Nvarchar``: _) dto)
          ``Real`` = (^a: (member ``Real``: _) dto)
          ``Smalldatetime`` = (^a: (member ``Smalldatetime``: _) dto)
          ``Smallint`` = (^a: (member ``Smallint``: _) dto)
          ``Smallmoney`` = (^a: (member ``Smallmoney``: _) dto)
          ``Text`` = (^a: (member ``Text``: _) dto)
          ``Time`` = (^a: (member ``Time``: _) dto)
          ``Tinyint`` = (^a: (member ``Tinyint``: _) dto)
          ``Uniqueidentifier`` = (^a: (member ``Uniqueidentifier``: _) dto)
          ``Varbinary`` = (^a: (member ``Varbinary``: _) dto)
          ``Varchar`` = (^a: (member ``Varchar``: _) dto)
          ``Xml`` = (^a: (member ``Xml``: _) dto)
        }


    type ``AllTypesNull`` =
      {
        ``Key1``: int
        ``Key2``: int
        ``Bigint``: int64 option
        ``Binary``: byte [] option
        ``Bit``: bool option
        ``Char``: string option
        ``Date``: DateTime option
        ``Datetime``: DateTime option
        ``Datetime2``: DateTime option
        ``Datetimeoffset``: DateTimeOffset option
        ``Decimal``: decimal option
        ``Float``: float option
        ``Image``: byte [] option
        ``Int``: int option
        ``Money``: decimal option
        ``Nchar``: string option
        ``Ntext``: string option
        ``Numeric``: decimal option
        ``Nvarchar``: string option
        ``Real``: float32 option
        ``Smalldatetime``: DateTime option
        ``Smallint``: int16 option
        ``Smallmoney``: decimal option
        ``Text``: string option
        ``Time``: TimeSpan option
        ``Tinyint``: byte option
        ``Uniqueidentifier``: Guid option
        ``Varbinary``: byte [] option
        ``Varchar``: string option
        ``Xml``: string option
      }

      static member getPrimaryKey (dto: ``AllTypesNull``) =
        {|
          ``Key1`` = dto.``Key1``
          ``Key2`` = dto.``Key2``
        |}

      static member inline create dto : ``AllTypesNull`` =
        {
          ``Key1`` = (^a: (member ``Key1``: _) dto)
          ``Key2`` = (^a: (member ``Key2``: _) dto)
          ``Bigint`` = (^a: (member ``Bigint``: _) dto)
          ``Binary`` = (^a: (member ``Binary``: _) dto)
          ``Bit`` = (^a: (member ``Bit``: _) dto)
          ``Char`` = (^a: (member ``Char``: _) dto)
          ``Date`` = (^a: (member ``Date``: _) dto)
          ``Datetime`` = (^a: (member ``Datetime``: _) dto)
          ``Datetime2`` = (^a: (member ``Datetime2``: _) dto)
          ``Datetimeoffset`` = (^a: (member ``Datetimeoffset``: _) dto)
          ``Decimal`` = (^a: (member ``Decimal``: _) dto)
          ``Float`` = (^a: (member ``Float``: _) dto)
          ``Image`` = (^a: (member ``Image``: _) dto)
          ``Int`` = (^a: (member ``Int``: _) dto)
          ``Money`` = (^a: (member ``Money``: _) dto)
          ``Nchar`` = (^a: (member ``Nchar``: _) dto)
          ``Ntext`` = (^a: (member ``Ntext``: _) dto)
          ``Numeric`` = (^a: (member ``Numeric``: _) dto)
          ``Nvarchar`` = (^a: (member ``Nvarchar``: _) dto)
          ``Real`` = (^a: (member ``Real``: _) dto)
          ``Smalldatetime`` = (^a: (member ``Smalldatetime``: _) dto)
          ``Smallint`` = (^a: (member ``Smallint``: _) dto)
          ``Smallmoney`` = (^a: (member ``Smallmoney``: _) dto)
          ``Text`` = (^a: (member ``Text``: _) dto)
          ``Time`` = (^a: (member ``Time``: _) dto)
          ``Tinyint`` = (^a: (member ``Tinyint``: _) dto)
          ``Uniqueidentifier`` = (^a: (member ``Uniqueidentifier``: _) dto)
          ``Varbinary`` = (^a: (member ``Varbinary``: _) dto)
          ``Varchar`` = (^a: (member ``Varchar``: _) dto)
          ``Xml`` = (^a: (member ``Xml``: _) dto)
        }


    type ``CamelCaseColNames`` =
      {
        ``Col1``: string option
        ``OtherCol``: int option
      }


    type ``DesignTimeExecuteTest`` =
      {
        ``Col``: Guid
      }


    type ``LengthTypes`` =
      {
        ``Key``: int
        ``Binary``: byte []
        ``Char``: string
        ``Nchar``: string
        ``Nvarchar``: string
        ``Varbinary``: byte []
        ``Varchar``: string
      }

      static member getPrimaryKey (dto: ``LengthTypes``) =
        dto.``Key``


    type ``MaxLengthTypes`` =
      {
        ``Key``: int
        ``Nvarchar``: string
        ``Varbinary``: byte []
        ``Varchar``: string
      }

      static member getPrimaryKey (dto: ``MaxLengthTypes``) =
        dto.``Key``


    type ``OptionTableWithDto`` =
      {
        ``Col1``: string option
        ``Col2``: int option
      }


    type ``Table1`` =
      {
        ``TableCol1``: string
        ``TableCol2``: int option
      }


    type ``TableDtoColumnInheritance`` =
      {
        ``Col1``: int
        ``Col2``: int
      }


    type ``TableWithComputedCol`` =
      {
        ``Id``: int
        ``Bar``: int
      }

      static member getPrimaryKey (dto: ``TableWithComputedCol``) =
        dto.``Id``


    type ``TableWithFullTextCatalog`` =
      {
        ``Col1``: string
      }

      static member getPrimaryKey (dto: ``TableWithFullTextCatalog``) =
        dto.``Col1``


    type ``TableWithIdentityCol`` =
      {
        ``Id``: int
        ``Foo``: int64
        ``BAR``: DateTimeOffset option
      }

      static member getPrimaryKey (dto: ``TableWithIdentityCol``) =
        dto.``Id``


    type ``TableWithSkippedPkColumn`` =
      {
        ``Key2``: int
      }


    type ``TableWithSkippedUnsupportedColumn`` =
      {
        ``SupportedCol1``: string
        ``SupportedCol2``: int
      }


    type ``Temporal`` =
      {
        ``Id``: int
        ``Data``: string option
        ``ValidFrom``: DateTime
        ``ValidTo``: DateTime
      }

      static member getPrimaryKey (dto: ``Temporal``) =
        dto.``Id``


    type ``Temporal_History`` =
      {
        ``Id``: int
        ``Data``: string option
        ``ValidFrom``: DateTime
        ``ValidTo``: DateTime
      }


    type ``View1`` =
      {
        ``TableCol1``: string
        ``TableCol2``: int option
        ``Foo``: int
      }


    type ``VoptionTableWithDto`` =
      {
        ``Col1``: string voption
        ``Col2``: int voption
      }


module TableTypes =


  module ``dbo`` =


    let private ``AllTypesNonNull_meta`` =
      [|
        SqlMetaData("bigint", SqlDbType.BigInt)
        SqlMetaData("binary", SqlDbType.Binary, 42L)
        SqlMetaData("bit", SqlDbType.Bit)
        SqlMetaData("char", SqlDbType.Char, 42L)
        SqlMetaData("date", SqlDbType.Date)
        SqlMetaData("datetime", SqlDbType.DateTime)
        SqlMetaData("datetime2", SqlDbType.DateTime2, 0uy, 3uy)
        SqlMetaData("datetimeoffset", SqlDbType.DateTimeOffset, 0uy, 1uy)
        SqlMetaData("decimal", SqlDbType.Decimal, 10uy, 5uy)
        SqlMetaData("float", SqlDbType.Float)
        SqlMetaData("image", SqlDbType.Image)
        SqlMetaData("int", SqlDbType.Int)
        SqlMetaData("money", SqlDbType.Money)
        SqlMetaData("nchar", SqlDbType.NChar, 42L)
        SqlMetaData("ntext", SqlDbType.NText)
        SqlMetaData("numeric", SqlDbType.Decimal, 8uy, 3uy)
        SqlMetaData("nvarchar", SqlDbType.NVarChar, 42L)
        SqlMetaData("real", SqlDbType.Real)
        SqlMetaData("smalldatetime", SqlDbType.SmallDateTime)
        SqlMetaData("smallint", SqlDbType.SmallInt)
        SqlMetaData("smallmoney", SqlDbType.SmallMoney)
        SqlMetaData("text", SqlDbType.Text)
        SqlMetaData("time", SqlDbType.Time, 0uy, 1uy)
        SqlMetaData("tinyint", SqlDbType.TinyInt)
        SqlMetaData("uniqueidentifier", SqlDbType.UniqueIdentifier)
        SqlMetaData("varbinary", SqlDbType.VarBinary, 42L)
        SqlMetaData("varchar", SqlDbType.VarChar, 42L)
        SqlMetaData("xml", SqlDbType.Xml)
      |]


    type ``AllTypesNonNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``AllTypesNonNull_meta``)

      static member create
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let x = ``AllTypesNonNull``(internalUseOnlyValue)
        x.SetValues(
          ``bigint``,
          ``binary``,
          ``bit``,
          ``char``,
          ``date``,
          ``datetime``,
          ``datetime2``,
          ``datetimeoffset``,
          ``decimal``,
          ``float``,
          ``image``,
          ``int``,
          ``money``,
          ``nchar``,
          ``ntext``,
          ``numeric``,
          ``nvarchar``,
          ``real``,
          ``smalldatetime``,
          ``smallint``,
          ``smallmoney``,
          ``text``,
          ``time``,
          ``tinyint``,
          ``uniqueidentifier``,
          ``varbinary``,
          ``varchar``,
          ``xml``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``AllTypesNonNull``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``bigint``: int64) dto),
          (^a: (member ``binary``: byte []) dto),
          (^a: (member ``bit``: bool) dto),
          (^a: (member ``char``: string) dto),
          (^a: (member ``date``: DateTime) dto),
          (^a: (member ``datetime``: DateTime) dto),
          (^a: (member ``datetime2``: DateTime) dto),
          (^a: (member ``datetimeoffset``: DateTimeOffset) dto),
          (^a: (member ``decimal``: decimal) dto),
          (^a: (member ``float``: float) dto),
          (^a: (member ``image``: byte []) dto),
          (^a: (member ``int``: int) dto),
          (^a: (member ``money``: decimal) dto),
          (^a: (member ``nchar``: string) dto),
          (^a: (member ``ntext``: string) dto),
          (^a: (member ``numeric``: decimal) dto),
          (^a: (member ``nvarchar``: string) dto),
          (^a: (member ``real``: float32) dto),
          (^a: (member ``smalldatetime``: DateTime) dto),
          (^a: (member ``smallint``: int16) dto),
          (^a: (member ``smallmoney``: decimal) dto),
          (^a: (member ``text``: string) dto),
          (^a: (member ``time``: TimeSpan) dto),
          (^a: (member ``tinyint``: byte) dto),
          (^a: (member ``uniqueidentifier``: Guid) dto),
          (^a: (member ``varbinary``: byte []) dto),
          (^a: (member ``varchar``: string) dto),
          (^a: (member ``xml``: string) dto)
        )
        |> ignore
        x


    let private ``AllTypesNull_meta`` =
      [|
        SqlMetaData("bigint", SqlDbType.BigInt)
        SqlMetaData("binary", SqlDbType.Binary, 42L)
        SqlMetaData("bit", SqlDbType.Bit)
        SqlMetaData("char", SqlDbType.Char, 42L)
        SqlMetaData("date", SqlDbType.Date)
        SqlMetaData("datetime", SqlDbType.DateTime)
        SqlMetaData("datetime2", SqlDbType.DateTime2, 0uy, 3uy)
        SqlMetaData("datetimeoffset", SqlDbType.DateTimeOffset, 0uy, 1uy)
        SqlMetaData("decimal", SqlDbType.Decimal, 10uy, 5uy)
        SqlMetaData("float", SqlDbType.Float)
        SqlMetaData("image", SqlDbType.Image)
        SqlMetaData("int", SqlDbType.Int)
        SqlMetaData("money", SqlDbType.Money)
        SqlMetaData("nchar", SqlDbType.NChar, 42L)
        SqlMetaData("ntext", SqlDbType.NText)
        SqlMetaData("numeric", SqlDbType.Decimal, 8uy, 3uy)
        SqlMetaData("nvarchar", SqlDbType.NVarChar, 42L)
        SqlMetaData("real", SqlDbType.Real)
        SqlMetaData("smalldatetime", SqlDbType.SmallDateTime)
        SqlMetaData("smallint", SqlDbType.SmallInt)
        SqlMetaData("smallmoney", SqlDbType.SmallMoney)
        SqlMetaData("text", SqlDbType.Text)
        SqlMetaData("time", SqlDbType.Time, 0uy, 1uy)
        SqlMetaData("tinyint", SqlDbType.TinyInt)
        SqlMetaData("uniqueidentifier", SqlDbType.UniqueIdentifier)
        SqlMetaData("varbinary", SqlDbType.VarBinary, 42L)
        SqlMetaData("varchar", SqlDbType.VarChar, 42L)
        SqlMetaData("xml", SqlDbType.Xml)
      |]


    type ``AllTypesNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``AllTypesNull_meta``)

      static member create
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let x = ``AllTypesNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull ``bigint``,
          Option.toDbNull ``binary``,
          Option.toDbNull ``bit``,
          Option.toDbNull ``char``,
          Option.toDbNull ``date``,
          Option.toDbNull ``datetime``,
          Option.toDbNull ``datetime2``,
          Option.toDbNull ``datetimeoffset``,
          Option.toDbNull ``decimal``,
          Option.toDbNull ``float``,
          Option.toDbNull ``image``,
          Option.toDbNull ``int``,
          Option.toDbNull ``money``,
          Option.toDbNull ``nchar``,
          Option.toDbNull ``ntext``,
          Option.toDbNull ``numeric``,
          Option.toDbNull ``nvarchar``,
          Option.toDbNull ``real``,
          Option.toDbNull ``smalldatetime``,
          Option.toDbNull ``smallint``,
          Option.toDbNull ``smallmoney``,
          Option.toDbNull ``text``,
          Option.toDbNull ``time``,
          Option.toDbNull ``tinyint``,
          Option.toDbNull ``uniqueidentifier``,
          Option.toDbNull ``varbinary``,
          Option.toDbNull ``varchar``,
          Option.toDbNull ``xml``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``AllTypesNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull (^a: (member ``bigint``: int64 option) dto),
          Option.toDbNull (^a: (member ``binary``: byte [] option) dto),
          Option.toDbNull (^a: (member ``bit``: bool option) dto),
          Option.toDbNull (^a: (member ``char``: string option) dto),
          Option.toDbNull (^a: (member ``date``: DateTime option) dto),
          Option.toDbNull (^a: (member ``datetime``: DateTime option) dto),
          Option.toDbNull (^a: (member ``datetime2``: DateTime option) dto),
          Option.toDbNull (^a: (member ``datetimeoffset``: DateTimeOffset option) dto),
          Option.toDbNull (^a: (member ``decimal``: decimal option) dto),
          Option.toDbNull (^a: (member ``float``: float option) dto),
          Option.toDbNull (^a: (member ``image``: byte [] option) dto),
          Option.toDbNull (^a: (member ``int``: int option) dto),
          Option.toDbNull (^a: (member ``money``: decimal option) dto),
          Option.toDbNull (^a: (member ``nchar``: string option) dto),
          Option.toDbNull (^a: (member ``ntext``: string option) dto),
          Option.toDbNull (^a: (member ``numeric``: decimal option) dto),
          Option.toDbNull (^a: (member ``nvarchar``: string option) dto),
          Option.toDbNull (^a: (member ``real``: float32 option) dto),
          Option.toDbNull (^a: (member ``smalldatetime``: DateTime option) dto),
          Option.toDbNull (^a: (member ``smallint``: int16 option) dto),
          Option.toDbNull (^a: (member ``smallmoney``: decimal option) dto),
          Option.toDbNull (^a: (member ``text``: string option) dto),
          Option.toDbNull (^a: (member ``time``: TimeSpan option) dto),
          Option.toDbNull (^a: (member ``tinyint``: byte option) dto),
          Option.toDbNull (^a: (member ``uniqueidentifier``: Guid option) dto),
          Option.toDbNull (^a: (member ``varbinary``: byte [] option) dto),
          Option.toDbNull (^a: (member ``varchar``: string option) dto),
          Option.toDbNull (^a: (member ``xml``: string option) dto)
        )
        |> ignore
        x


    let private ``FilterForTableWithIdentityCol_meta`` =
      [|
        SqlMetaData("Id", SqlDbType.Int)
        SqlMetaData("Foo", SqlDbType.BigInt)
      |]


    type ``FilterForTableWithIdentityCol`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``FilterForTableWithIdentityCol_meta``)

      static member create
        (
          ``Id``: int,
          ``Foo``: int64
        ) =
        let x = ``FilterForTableWithIdentityCol``(internalUseOnlyValue)
        x.SetValues(
          ``Id``,
          ``Foo``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``FilterForTableWithIdentityCol``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``Id``: int) dto),
          (^a: (member ``Foo``: int64) dto)
        )
        |> ignore
        x


    let private ``LengthTypes_meta`` =
      [|
        SqlMetaData("binary", SqlDbType.Binary, 3L)
        SqlMetaData("char", SqlDbType.Char, 3L)
        SqlMetaData("nchar", SqlDbType.NChar, 3L)
        SqlMetaData("nvarchar", SqlDbType.NVarChar, 3L)
        SqlMetaData("varbinary", SqlDbType.VarBinary, 3L)
        SqlMetaData("varchar", SqlDbType.VarChar, 3L)
      |]


    type ``LengthTypes`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``LengthTypes_meta``)

      static member create
        (
          ``binary``: byte [],
          ``char``: string,
          ``nchar``: string,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) =
        let x = ``LengthTypes``(internalUseOnlyValue)
        x.SetValues(
          ``binary``,
          ``char``,
          ``nchar``,
          ``nvarchar``,
          ``varbinary``,
          ``varchar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``LengthTypes``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``binary``: byte []) dto),
          (^a: (member ``char``: string) dto),
          (^a: (member ``nchar``: string) dto),
          (^a: (member ``nvarchar``: string) dto),
          (^a: (member ``varbinary``: byte []) dto),
          (^a: (member ``varchar``: string) dto)
        )
        |> ignore
        x


    let private ``MaxLengthTypes_meta`` =
      [|
        SqlMetaData("nvarchar", SqlDbType.NVarChar, -1L)
        SqlMetaData("varbinary", SqlDbType.VarBinary, -1L)
        SqlMetaData("varchar", SqlDbType.VarChar, -1L)
      |]


    type ``MaxLengthTypes`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``MaxLengthTypes_meta``)

      static member create
        (
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) =
        let x = ``MaxLengthTypes``(internalUseOnlyValue)
        x.SetValues(
          ``nvarchar``,
          ``varbinary``,
          ``varchar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MaxLengthTypes``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``nvarchar``: string) dto),
          (^a: (member ``varbinary``: byte []) dto),
          (^a: (member ``varchar``: string) dto)
        )
        |> ignore
        x


    let private ``MultiColNonNull_meta`` =
      [|
        SqlMetaData("Foo", SqlDbType.Int)
        SqlMetaData("Bar", SqlDbType.NVarChar, 50L)
      |]


    type ``MultiColNonNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``MultiColNonNull_meta``)

      static member create
        (
          ``Foo``: int,
          ``Bar``: string
        ) =
        let x = ``MultiColNonNull``(internalUseOnlyValue)
        x.SetValues(
          ``Foo``,
          ``Bar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MultiColNonNull``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``Foo``: int) dto),
          (^a: (member ``Bar``: string) dto)
        )
        |> ignore
        x


    let private ``MultiColNull_meta`` =
      [|
        SqlMetaData("Foo", SqlDbType.Int)
        SqlMetaData("Bar", SqlDbType.NVarChar, 50L)
      |]


    type ``MultiColNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``MultiColNull_meta``)

      static member create
        (
          ``Foo``: int option,
          ``Bar``: string option
        ) =
        let x = ``MultiColNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull ``Foo``,
          Option.toDbNull ``Bar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MultiColNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull (^a: (member ``Foo``: int option) dto),
          Option.toDbNull (^a: (member ``Bar``: string option) dto)
        )
        |> ignore
        x


    let private ``MultiColNullVoption_meta`` =
      [|
        SqlMetaData("Foo", SqlDbType.Int)
        SqlMetaData("Bar", SqlDbType.NVarChar, 50L)
      |]


    type ``MultiColNullVoption`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``MultiColNullVoption_meta``)

      static member create
        (
          ``Foo``: int voption,
          ``Bar``: string voption
        ) =
        let x = ``MultiColNullVoption``(internalUseOnlyValue)
        x.SetValues(
          ValueOption.toDbNull ``Foo``,
          ValueOption.toDbNull ``Bar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MultiColNullVoption``(internalUseOnlyValue)
        x.SetValues(
          ValueOption.toDbNull (^a: (member ``Foo``: int voption) dto),
          ValueOption.toDbNull (^a: (member ``Bar``: string voption) dto)
        )
        |> ignore
        x


    let private ``SingleColNonNull_meta`` =
      [|
        SqlMetaData("Foo", SqlDbType.Int)
      |]


    type ``SingleColNonNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``SingleColNonNull_meta``)

      static member create
        (
          ``Foo``: int
        ) =
        let x = ``SingleColNonNull``(internalUseOnlyValue)
        x.SetValues(
          ``Foo``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``SingleColNonNull``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``Foo``: int) dto)
        )
        |> ignore
        x


    let private ``SingleColNull_meta`` =
      [|
        SqlMetaData("Foo", SqlDbType.Int)
      |]


    type ``SingleColNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``SingleColNull_meta``)

      static member create
        (
          ``Foo``: int option
        ) =
        let x = ``SingleColNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull ``Foo``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``SingleColNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull (^a: (member ``Foo``: int option) dto)
        )
        |> ignore
        x


module Procedures =


  module ``dbo`` =


    type ``ProcColumnInheritance`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcColumnInheritance"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``TableDtoColumnInheritance`` =
        let ``Col1`` = reader.GetInt32 ``ordinal_Col1``
        let ``Col2`` = reader.GetInt32 ``ordinal_Col2``
        {
          ``Col1`` = ``Col1``
          ``Col2`` = ``Col2``
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcColumnInheritance``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcColumnInheritance``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcColumnInheritance``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcInsert`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcInsert"
        userConfigureCmd cmd

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcInsert``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcInsert``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcInsert``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeNonQuery connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcNominalResult_Result`` =
      {
        ``TableCol1``: string
        ``TableCol2``: int option
      }


    type ``ProcNominalResult`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcNominalResult"
        userConfigureCmd cmd

      let mutable ``ordinal_TableCol1`` = 0
      let mutable ``ordinal_TableCol2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
        ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

      let getItem (reader: SqlDataReader) =
        let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
        let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
        {
          ``TableCol1`` = ``TableCol1``
          ``TableCol2`` = ``TableCol2``
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcNominalResult``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcNominalResult``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcNominalResult``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcOptionIn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionIn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcOptionIn`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcOptionIn``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionIn``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcOptionIn``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
          |]
        ``ProcOptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
          |]
        ``ProcOptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcOptionOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcOptionOut`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcOptionOut``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionOut``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcOptionOut``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
          |]
        ``ProcOptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
          |]
        ``ProcOptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcOptionTableOutWithDto`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionTableOutWithDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``OptionTableWithDto`` =
        let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
        let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
        {
          ``Col1`` = ``Col1``
          ``Col2`` = ``Col2``
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcOptionTableOutWithDto``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionTableOutWithDto``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcOptionTableOutWithDto``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcOptionTableOutWithoutDto`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionTableOutWithoutDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) =
        let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
        let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
        {|
          ``Col1`` = ``Col1``
          ``Col2`` = ``Col2``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcOptionTableOutWithoutDto``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionTableOutWithoutDto``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcOptionTableOutWithoutDto``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcOptionTvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionTvpInOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcOptionTvpInOut`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcOptionTvpInOut``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionTvpInOut``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcOptionTvpInOut``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``tvp``: seq<TableTypes.``dbo``.``MultiColNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty ``tvp``)
          |]
        ``ProcOptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
          |]
        ``ProcOptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcSelectFromTable`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcSelectFromTable"
        userConfigureCmd cmd

      let mutable ``ordinal_TableCol1`` = 0
      let mutable ``ordinal_TableCol2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
        ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

      let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
        let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
        let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
        {
          ``TableCol1`` = ``TableCol1``
          ``TableCol2`` = ``TableCol2``
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcSelectFromTable``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcSelectFromTable``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcSelectFromTable``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcSelectFromTableExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcSelectFromTableExtended"
        userConfigureCmd cmd

      let mutable ``ordinal_TableCol1`` = 0
      let mutable ``ordinal_TableCol2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
        ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

      let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
        let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
        let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
        {
          ``TableCol1`` = ``TableCol1``
          ``TableCol2`` = ``TableCol2``
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcSelectFromTableExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcSelectFromTableExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcSelectFromTableExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcToBeModified`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcToBeModified"
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetString ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcToBeModified``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcToBeModified``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcToBeModified``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcVoptionIn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionIn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcVoptionIn`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcVoptionIn``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionIn``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcVoptionIn``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string voption
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull ``param1``)
          |]
        ``ProcVoptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull (^a: (member ``Param1``: string voption) dto))
          |]
        ``ProcVoptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcVoptionOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then ValueNone else reader.GetString 0 |> ValueSome

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsyncVoption connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingleVoption connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcVoptionOut`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcVoptionOut``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionOut``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcVoptionOut``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
          |]
        ``ProcVoptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
          |]
        ``ProcVoptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcVoptionTableOutWithDto`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionTableOutWithDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``VoptionTableWithDto`` =
        let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
        let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
        {
          ``Col1`` = ``Col1``
          ``Col2`` = ``Col2``
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcVoptionTableOutWithDto``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionTableOutWithDto``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcVoptionTableOutWithDto``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingleVoption connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcVoptionTableOutWithoutDto`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionTableOutWithoutDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) =
        let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
        let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
        {|
          ``Col1`` = ``Col1``
          ``Col2`` = ``Col2``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcVoptionTableOutWithoutDto``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionTableOutWithoutDto``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcVoptionTableOutWithoutDto``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingleVoption connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcVoptionTvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionTvpInOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then ValueNone else reader.GetInt32 ``ordinal_Foo`` |> ValueSome
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then ValueNone else reader.GetString ``ordinal_Bar`` |> ValueSome
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsyncVoption connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingleVoption connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcVoptionTvpInOut`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcVoptionTvpInOut``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionTvpInOut``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcVoptionTvpInOut``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``tvp``: seq<TableTypes.``dbo``.``MultiColNullVoption``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = boxNullIfEmpty ``tvp``)
          |]
        ``ProcVoptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = boxNullIfEmpty (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNullVoption``>) dto))
          |]
        ``ProcVoptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypes_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypes"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
        let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
        let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
        let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
        let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
        let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
        let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
        let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
        let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
        let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
        let ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
        let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
        let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
        let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
        let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
        let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
        let ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
        let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
        let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``rowversion`` = ``rowversion``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``timestamp`` = ``timestamp``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypes`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypes``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypes``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypes``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``rowversion``: byte [],
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``timestamp``: byte [],
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = ``xml``)
          |]
        ``ProcWithAllTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = (^a: (member ``Bigint``: int64) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = (^a: (member ``Binary``: byte []) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = (^a: (member ``Bit``: bool) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = (^a: (member ``Char``: string) dto))
            SqlParameter("@date", SqlDbType.Date, Value = (^a: (member ``Date``: DateTime) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = (^a: (member ``Datetime``: DateTime) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = (^a: (member ``Datetime2``: DateTime) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = (^a: (member ``Datetimeoffset``: DateTimeOffset) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = (^a: (member ``Decimal``: decimal) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = (^a: (member ``Float``: float) dto))
            SqlParameter("@image", SqlDbType.Image, Value = (^a: (member ``Image``: byte []) dto))
            SqlParameter("@int", SqlDbType.Int, Value = (^a: (member ``Int``: int) dto))
            SqlParameter("@money", SqlDbType.Money, Value = (^a: (member ``Money``: decimal) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = (^a: (member ``Nchar``: string) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = (^a: (member ``Ntext``: string) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = (^a: (member ``Numeric``: decimal) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Nvarchar``: string) dto))
            SqlParameter("@real", SqlDbType.Real, Value = (^a: (member ``Real``: float32) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = (^a: (member ``Rowversion``: byte []) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = (^a: (member ``Smalldatetime``: DateTime) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = (^a: (member ``Smallint``: int16) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = (^a: (member ``Smallmoney``: decimal) dto))
            SqlParameter("@text", SqlDbType.Text, Value = (^a: (member ``Text``: string) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = (^a: (member ``Time``: TimeSpan) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = (^a: (member ``Timestamp``: byte []) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = (^a: (member ``Tinyint``: byte) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Uniqueidentifier``: Guid) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = (^a: (member ``Varbinary``: byte []) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = (^a: (member ``Varchar``: string) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = (^a: (member ``Xml``: string) dto))
          |]
        ``ProcWithAllTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
        let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
        let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
        let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
        let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
        let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
        let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
        let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
        let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
        let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
        let ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
        let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
        let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
        let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
        let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
        let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
        let ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
        let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
        let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``rowversion`` = ``rowversion``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``timestamp`` = ``timestamp``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``rowversion``: byte [],
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``timestamp``: byte [],
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = ``xml``)
          |]
        ``ProcWithAllTypesExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = (^a: (member ``Bigint``: int64) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = (^a: (member ``Binary``: byte []) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = (^a: (member ``Bit``: bool) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = (^a: (member ``Char``: string) dto))
            SqlParameter("@date", SqlDbType.Date, Value = (^a: (member ``Date``: DateTime) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = (^a: (member ``Datetime``: DateTime) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = (^a: (member ``Datetime2``: DateTime) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = (^a: (member ``Datetimeoffset``: DateTimeOffset) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = (^a: (member ``Decimal``: decimal) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = (^a: (member ``Float``: float) dto))
            SqlParameter("@image", SqlDbType.Image, Value = (^a: (member ``Image``: byte []) dto))
            SqlParameter("@int", SqlDbType.Int, Value = (^a: (member ``Int``: int) dto))
            SqlParameter("@money", SqlDbType.Money, Value = (^a: (member ``Money``: decimal) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = (^a: (member ``Nchar``: string) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = (^a: (member ``Ntext``: string) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = (^a: (member ``Numeric``: decimal) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Nvarchar``: string) dto))
            SqlParameter("@real", SqlDbType.Real, Value = (^a: (member ``Real``: float32) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = (^a: (member ``Rowversion``: byte []) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = (^a: (member ``Smalldatetime``: DateTime) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = (^a: (member ``Smallint``: int16) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = (^a: (member ``Smallmoney``: decimal) dto))
            SqlParameter("@text", SqlDbType.Text, Value = (^a: (member ``Text``: string) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = (^a: (member ``Time``: TimeSpan) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = (^a: (member ``Timestamp``: byte []) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = (^a: (member ``Tinyint``: byte) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Uniqueidentifier``: Guid) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = (^a: (member ``Varbinary``: byte []) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = (^a: (member ``Varchar``: string) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = (^a: (member ``Xml``: string) dto))
          |]
        ``ProcWithAllTypesExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNonNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNonNull"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = reader.GetInt64 ``ordinal_bigint``
        let ``binary`` = reader.GetBytes ``ordinal_binary``
        let ``bit`` = reader.GetBoolean ``ordinal_bit``
        let ``char`` = reader.GetString ``ordinal_char``
        let ``date`` = reader.GetDateTime ``ordinal_date``
        let ``datetime`` = reader.GetDateTime ``ordinal_datetime``
        let ``datetime2`` = reader.GetDateTime ``ordinal_datetime2``
        let ``datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_datetimeoffset``
        let ``decimal`` = reader.GetDecimal ``ordinal_decimal``
        let ``float`` = reader.GetDouble ``ordinal_float``
        let ``image`` = reader.GetBytes ``ordinal_image``
        let ``int`` = reader.GetInt32 ``ordinal_int``
        let ``money`` = reader.GetDecimal ``ordinal_money``
        let ``nchar`` = reader.GetString ``ordinal_nchar``
        let ``ntext`` = reader.GetString ``ordinal_ntext``
        let ``numeric`` = reader.GetDecimal ``ordinal_numeric``
        let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
        let ``real`` = reader.GetFloat ``ordinal_real``
        let ``smalldatetime`` = reader.GetDateTime ``ordinal_smalldatetime``
        let ``smallint`` = reader.GetInt16 ``ordinal_smallint``
        let ``smallmoney`` = reader.GetDecimal ``ordinal_smallmoney``
        let ``text`` = reader.GetString ``ordinal_text``
        let ``time`` = reader.GetTimeSpan ``ordinal_time``
        let ``tinyint`` = reader.GetByte ``ordinal_tinyint``
        let ``uniqueidentifier`` = reader.GetGuid ``ordinal_uniqueidentifier``
        let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
        let ``varchar`` = reader.GetString ``ordinal_varchar``
        let ``xml`` = reader.GetString ``ordinal_xml``
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesFromTvpNonNull`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesFromTvpNonNull``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNonNull``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesFromTvpNonNull``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNonNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = boxNullIfEmpty ``params``)
          |]
        ``ProcWithAllTypesFromTvpNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = boxNullIfEmpty (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNonNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNonNullExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNonNullExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = reader.GetInt64 ``ordinal_bigint``
        let ``binary`` = reader.GetBytes ``ordinal_binary``
        let ``bit`` = reader.GetBoolean ``ordinal_bit``
        let ``char`` = reader.GetString ``ordinal_char``
        let ``date`` = reader.GetDateTime ``ordinal_date``
        let ``datetime`` = reader.GetDateTime ``ordinal_datetime``
        let ``datetime2`` = reader.GetDateTime ``ordinal_datetime2``
        let ``datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_datetimeoffset``
        let ``decimal`` = reader.GetDecimal ``ordinal_decimal``
        let ``float`` = reader.GetDouble ``ordinal_float``
        let ``image`` = reader.GetBytes ``ordinal_image``
        let ``int`` = reader.GetInt32 ``ordinal_int``
        let ``money`` = reader.GetDecimal ``ordinal_money``
        let ``nchar`` = reader.GetString ``ordinal_nchar``
        let ``ntext`` = reader.GetString ``ordinal_ntext``
        let ``numeric`` = reader.GetDecimal ``ordinal_numeric``
        let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
        let ``real`` = reader.GetFloat ``ordinal_real``
        let ``smalldatetime`` = reader.GetDateTime ``ordinal_smalldatetime``
        let ``smallint`` = reader.GetInt16 ``ordinal_smallint``
        let ``smallmoney`` = reader.GetDecimal ``ordinal_smallmoney``
        let ``text`` = reader.GetString ``ordinal_text``
        let ``time`` = reader.GetTimeSpan ``ordinal_time``
        let ``tinyint`` = reader.GetByte ``ordinal_tinyint``
        let ``uniqueidentifier`` = reader.GetGuid ``ordinal_uniqueidentifier``
        let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
        let ``varchar`` = reader.GetString ``ordinal_varchar``
        let ``xml`` = reader.GetString ``ordinal_xml``
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesFromTvpNonNullExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesFromTvpNonNullExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNonNullExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesFromTvpNonNullExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNonNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = boxNullIfEmpty ``params``)
          |]
        ``ProcWithAllTypesFromTvpNonNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = boxNullIfEmpty (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNonNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNonNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcWithAllTypesFromTvpNonNullNominalParams_Params`` =
      {
        ``Params``: seq<TableTypes.``dbo``.``AllTypesNonNull``>
      }


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNonNullNominalParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNonNullNominalParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = reader.GetInt64 ``ordinal_bigint``
        let ``binary`` = reader.GetBytes ``ordinal_binary``
        let ``bit`` = reader.GetBoolean ``ordinal_bit``
        let ``char`` = reader.GetString ``ordinal_char``
        let ``date`` = reader.GetDateTime ``ordinal_date``
        let ``datetime`` = reader.GetDateTime ``ordinal_datetime``
        let ``datetime2`` = reader.GetDateTime ``ordinal_datetime2``
        let ``datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_datetimeoffset``
        let ``decimal`` = reader.GetDecimal ``ordinal_decimal``
        let ``float`` = reader.GetDouble ``ordinal_float``
        let ``image`` = reader.GetBytes ``ordinal_image``
        let ``int`` = reader.GetInt32 ``ordinal_int``
        let ``money`` = reader.GetDecimal ``ordinal_money``
        let ``nchar`` = reader.GetString ``ordinal_nchar``
        let ``ntext`` = reader.GetString ``ordinal_ntext``
        let ``numeric`` = reader.GetDecimal ``ordinal_numeric``
        let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
        let ``real`` = reader.GetFloat ``ordinal_real``
        let ``smalldatetime`` = reader.GetDateTime ``ordinal_smalldatetime``
        let ``smallint`` = reader.GetInt16 ``ordinal_smallint``
        let ``smallmoney`` = reader.GetDecimal ``ordinal_smallmoney``
        let ``text`` = reader.GetString ``ordinal_text``
        let ``time`` = reader.GetTimeSpan ``ordinal_time``
        let ``tinyint`` = reader.GetByte ``ordinal_tinyint``
        let ``uniqueidentifier`` = reader.GetGuid ``ordinal_uniqueidentifier``
        let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
        let ``varchar`` = reader.GetString ``ordinal_varchar``
        let ``xml`` = reader.GetString ``ordinal_xml``
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesFromTvpNonNullNominalParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesFromTvpNonNullNominalParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNonNullNominalParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesFromTvpNonNullNominalParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNonNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = boxNullIfEmpty ``params``)
          |]
        ``ProcWithAllTypesFromTvpNonNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ProcWithAllTypesFromTvpNonNullNominalParams_Params) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = boxNullIfEmpty dto.``Params``)
          |]
        ``ProcWithAllTypesFromTvpNonNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNull"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
        let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
        let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
        let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
        let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
        let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
        let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
        let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
        let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
        let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
        let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
        let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
        let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
        let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
        let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
        let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
        let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesFromTvpNull`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesFromTvpNull``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNull``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesFromTvpNull``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = boxNullIfEmpty ``params``)
          |]
        ``ProcWithAllTypesFromTvpNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = boxNullIfEmpty (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNullExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNullExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
        let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
        let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
        let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
        let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
        let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
        let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
        let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
        let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
        let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
        let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
        let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
        let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
        let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
        let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
        let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
        let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesFromTvpNullExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesFromTvpNullExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNullExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesFromTvpNullExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = boxNullIfEmpty ``params``)
          |]
        ``ProcWithAllTypesFromTvpNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = boxNullIfEmpty (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcWithAllTypesFromTvpNullNominalParams_Params`` =
      {
        ``Params``: seq<TableTypes.``dbo``.``AllTypesNull``>
      }


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNullNominalParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNullNominalParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
        let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
        let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
        let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
        let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
        let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
        let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
        let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
        let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
        let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
        let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
        let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
        let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
        let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
        let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
        let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
        let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesFromTvpNullNominalParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesFromTvpNullNominalParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNullNominalParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesFromTvpNullNominalParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = boxNullIfEmpty ``params``)
          |]
        ``ProcWithAllTypesFromTvpNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ProcWithAllTypesFromTvpNullNominalParams_Params) =
        let getSqlParams () =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = boxNullIfEmpty dto.``Params``)
          |]
        ``ProcWithAllTypesFromTvpNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcWithAllTypesNominalParams_Params`` =
      {
        ``Bigint``: int64
        ``Binary``: byte []
        ``Bit``: bool
        ``Char``: string
        ``Date``: DateTime
        ``Datetime``: DateTime
        ``Datetime2``: DateTime
        ``Datetimeoffset``: DateTimeOffset
        ``Decimal``: decimal
        ``Float``: float
        ``Image``: byte []
        ``Int``: int
        ``Money``: decimal
        ``Nchar``: string
        ``Ntext``: string
        ``Numeric``: decimal
        ``Nvarchar``: string
        ``Real``: float32
        ``Rowversion``: byte []
        ``Smalldatetime``: DateTime
        ``Smallint``: int16
        ``Smallmoney``: decimal
        ``Text``: string
        ``Time``: TimeSpan
        ``Timestamp``: byte []
        ``Tinyint``: byte
        ``Uniqueidentifier``: Guid
        ``Varbinary``: byte []
        ``Varchar``: string
        ``Xml``: string
      }


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesNominalParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesNominalParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
        let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
        let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
        let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
        let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
        let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
        let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
        let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
        let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
        let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
        let ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
        let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
        let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
        let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
        let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
        let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
        let ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
        let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
        let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``rowversion`` = ``rowversion``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``timestamp`` = ``timestamp``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesNominalParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesNominalParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesNominalParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesNominalParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``rowversion``: byte [],
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``timestamp``: byte [],
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = ``xml``)
          |]
        ``ProcWithAllTypesNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ProcWithAllTypesNominalParams_Params) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = dto.``Bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = dto.``Binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = dto.``Bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = dto.``Char``)
            SqlParameter("@date", SqlDbType.Date, Value = dto.``Date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = dto.``Datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = dto.``Datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = dto.``Datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = dto.``Decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = dto.``Float``)
            SqlParameter("@image", SqlDbType.Image, Value = dto.``Image``)
            SqlParameter("@int", SqlDbType.Int, Value = dto.``Int``)
            SqlParameter("@money", SqlDbType.Money, Value = dto.``Money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = dto.``Nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = dto.``Ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = dto.``Numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = dto.``Nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = dto.``Real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = dto.``Rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = dto.``Smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = dto.``Smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = dto.``Smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = dto.``Text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = dto.``Time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = dto.``Timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = dto.``Tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = dto.``Uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = dto.``Varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = dto.``Varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = dto.``Xml``)
          |]
        ``ProcWithAllTypesNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesNull"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
        let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
        let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
        let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
        let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
        let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
        let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
        let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
        let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
        let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
        let ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
        let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
        let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
        let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
        let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
        let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
        let ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
        let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
        let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``rowversion`` = ``rowversion``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``timestamp`` = ``timestamp``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesNull`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesNull``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesNull``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesNull``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``rowversion``: byte [] option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``timestamp``: byte [] option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
          |]
        ``ProcWithAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull (^a: (member ``Bigint``: int64 option) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull (^a: (member ``Binary``: byte [] option) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Bit``: bool option) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull (^a: (member ``Char``: string option) dto))
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull (^a: (member ``Date``: DateTime option) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull (^a: (member ``Decimal``: decimal option) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull (^a: (member ``Float``: float option) dto))
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull (^a: (member ``Image``: byte [] option) dto))
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Int``: int option) dto))
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull (^a: (member ``Money``: decimal option) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nchar``: string option) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull (^a: (member ``Ntext``: string option) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull (^a: (member ``Numeric``: decimal option) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nvarchar``: string option) dto))
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull (^a: (member ``Real``: float32 option) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Rowversion``: byte [] option) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull (^a: (member ``Smallint``: int16 option) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto))
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull (^a: (member ``Text``: string option) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Timestamp``: byte [] option) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull (^a: (member ``Tinyint``: byte option) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Varchar``: string option) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull (^a: (member ``Xml``: string option) dto))
          |]
        ``ProcWithAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesNullExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesNullExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
        let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
        let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
        let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
        let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
        let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
        let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
        let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
        let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
        let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
        let ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
        let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
        let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
        let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
        let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
        let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
        let ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
        let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
        let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``rowversion`` = ``rowversion``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``timestamp`` = ``timestamp``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesNullExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesNullExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesNullExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesNullExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``rowversion``: byte [] option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``timestamp``: byte [] option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
          |]
        ``ProcWithAllTypesNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull (^a: (member ``Bigint``: int64 option) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull (^a: (member ``Binary``: byte [] option) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Bit``: bool option) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull (^a: (member ``Char``: string option) dto))
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull (^a: (member ``Date``: DateTime option) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull (^a: (member ``Decimal``: decimal option) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull (^a: (member ``Float``: float option) dto))
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull (^a: (member ``Image``: byte [] option) dto))
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Int``: int option) dto))
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull (^a: (member ``Money``: decimal option) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nchar``: string option) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull (^a: (member ``Ntext``: string option) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull (^a: (member ``Numeric``: decimal option) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nvarchar``: string option) dto))
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull (^a: (member ``Real``: float32 option) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Rowversion``: byte [] option) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull (^a: (member ``Smallint``: int16 option) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto))
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull (^a: (member ``Text``: string option) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Timestamp``: byte [] option) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull (^a: (member ``Tinyint``: byte option) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Varchar``: string option) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull (^a: (member ``Xml``: string option) dto))
          |]
        ``ProcWithAllTypesNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcWithAllTypesNullNominalParams_Params`` =
      {
        ``Bigint``: int64 option
        ``Binary``: byte [] option
        ``Bit``: bool option
        ``Char``: string option
        ``Date``: DateTime option
        ``Datetime``: DateTime option
        ``Datetime2``: DateTime option
        ``Datetimeoffset``: DateTimeOffset option
        ``Decimal``: decimal option
        ``Float``: float option
        ``Image``: byte [] option
        ``Int``: int option
        ``Money``: decimal option
        ``Nchar``: string option
        ``Ntext``: string option
        ``Numeric``: decimal option
        ``Nvarchar``: string option
        ``Real``: float32 option
        ``Rowversion``: byte [] option
        ``Smalldatetime``: DateTime option
        ``Smallint``: int16 option
        ``Smallmoney``: decimal option
        ``Text``: string option
        ``Time``: TimeSpan option
        ``Timestamp``: byte [] option
        ``Tinyint``: byte option
        ``Uniqueidentifier``: Guid option
        ``Varbinary``: byte [] option
        ``Varchar``: string option
        ``Xml``: string option
      }


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesNullNominalParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesNullNominalParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
        let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
        let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
        let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
        let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
        let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
        let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
        let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
        let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
        let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
        let ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
        let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
        let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
        let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
        let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
        let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
        let ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
        let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
        let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        {|
          ``bigint`` = ``bigint``
          ``binary`` = ``binary``
          ``bit`` = ``bit``
          ``char`` = ``char``
          ``date`` = ``date``
          ``datetime`` = ``datetime``
          ``datetime2`` = ``datetime2``
          ``datetimeoffset`` = ``datetimeoffset``
          ``decimal`` = ``decimal``
          ``float`` = ``float``
          ``image`` = ``image``
          ``int`` = ``int``
          ``money`` = ``money``
          ``nchar`` = ``nchar``
          ``ntext`` = ``ntext``
          ``numeric`` = ``numeric``
          ``nvarchar`` = ``nvarchar``
          ``real`` = ``real``
          ``rowversion`` = ``rowversion``
          ``smalldatetime`` = ``smalldatetime``
          ``smallint`` = ``smallint``
          ``smallmoney`` = ``smallmoney``
          ``text`` = ``text``
          ``time`` = ``time``
          ``timestamp`` = ``timestamp``
          ``tinyint`` = ``tinyint``
          ``uniqueidentifier`` = ``uniqueidentifier``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
          ``xml`` = ``xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithAllTypesNullNominalParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithAllTypesNullNominalParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesNullNominalParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithAllTypesNullNominalParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``rowversion``: byte [] option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``timestamp``: byte [] option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
          |]
        ``ProcWithAllTypesNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ProcWithAllTypesNullNominalParams_Params) =
        let getSqlParams () =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull dto.``Bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull dto.``Binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull dto.``Bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull dto.``Char``)
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull dto.``Date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull dto.``Datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull dto.``Datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull dto.``Datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull dto.``Decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull dto.``Float``)
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull dto.``Image``)
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull dto.``Int``)
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull dto.``Money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull dto.``Nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull dto.``Ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull dto.``Numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull dto.``Nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull dto.``Real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull dto.``Rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull dto.``Smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull dto.``Smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull dto.``Smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull dto.``Text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull dto.``Time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull dto.``Timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull dto.``Tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull dto.``Uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull dto.``Varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull dto.``Varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull dto.``Xml``)
          |]
        ``ProcWithAllTypesNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcWithCamelCaseColNames`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithCamelCaseColNames"
        userConfigureCmd cmd

      let mutable ``ordinal_col1`` = 0
      let mutable ``ordinal_otherCol`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_col1`` <- reader.GetOrdinal "col1"
        ``ordinal_otherCol`` <- reader.GetOrdinal "otherCol"

      let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``CamelCaseColNames`` =
        let ``col1`` = if reader.IsDBNull ``ordinal_col1`` then None else reader.GetString ``ordinal_col1`` |> Some
        let ``otherCol`` = if reader.IsDBNull ``ordinal_otherCol`` then None else reader.GetInt32 ``ordinal_otherCol`` |> Some
        {
          ``Col1`` = ``col1``
          ``OtherCol`` = ``otherCol``
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithCamelCaseColNames``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithCamelCaseColNames``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithCamelCaseColNames``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithDynamicSqlWithFullTextSearch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithDynamicSqlWithFullTextSearch"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetString 0

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithDynamicSqlWithFullTextSearch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithDynamicSqlWithFullTextSearch``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithDynamicSqlWithFullTextSearch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithDynamicSqlWithFullTextSearch``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``fullTextPredicate``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@fullTextPredicate", SqlDbType.NVarChar, Size = 1000, Value = ``fullTextPredicate``)
          |]
        ``ProcWithDynamicSqlWithFullTextSearch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@fullTextPredicate", SqlDbType.NVarChar, Size = 1000, Value = (^a: (member ``FullTextPredicate``: string) dto))
          |]
        ``ProcWithDynamicSqlWithFullTextSearch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithLengthTypes_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithLengthTypes"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

      let getItem (reader: SqlDataReader) =
        let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
        let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
        let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        {|
          ``binary`` = ``binary``
          ``char`` = ``char``
          ``nchar`` = ``nchar``
          ``nvarchar`` = ``nvarchar``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithLengthTypes`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithLengthTypes``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithLengthTypes``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithLengthTypes``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``binary``: byte [],
          ``char``: string,
          ``nchar``: string,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@binary", SqlDbType.Binary, Size = 3, Value = ``binary``)
            SqlParameter("@char", SqlDbType.Char, Size = 3, Value = ``char``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 3, Value = ``nchar``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 3, Value = ``nvarchar``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 3, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 3, Value = ``varchar``)
          |]
        ``ProcWithLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@binary", SqlDbType.Binary, Size = 3, Value = (^a: (member ``Binary``: byte []) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 3, Value = (^a: (member ``Char``: string) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 3, Value = (^a: (member ``Nchar``: string) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 3, Value = (^a: (member ``Nvarchar``: string) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 3, Value = (^a: (member ``Varbinary``: byte []) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 3, Value = (^a: (member ``Varchar``: string) dto))
          |]
        ``ProcWithLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithLengthTypesFromTvp_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithLengthTypesFromTvp"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

      let getItem (reader: SqlDataReader) =
        let ``binary`` = reader.GetBytes ``ordinal_binary``
        let ``char`` = reader.GetString ``ordinal_char``
        let ``nchar`` = reader.GetString ``ordinal_nchar``
        let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
        let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
        let ``varchar`` = reader.GetString ``ordinal_varchar``
        {|
          ``binary`` = ``binary``
          ``char`` = ``char``
          ``nchar`` = ``nchar``
          ``nvarchar`` = ``nvarchar``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithLengthTypesFromTvp`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithLengthTypesFromTvp``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithLengthTypesFromTvp``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithLengthTypesFromTvp``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``tvp``: seq<TableTypes.``dbo``.``LengthTypes``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.LengthTypes", Value = boxNullIfEmpty ``tvp``)
          |]
        ``ProcWithLengthTypesFromTvp_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.LengthTypes", Value = boxNullIfEmpty (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``LengthTypes``>) dto))
          |]
        ``ProcWithLengthTypesFromTvp_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMaxLengthTypes_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMaxLengthTypes"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

      let getItem (reader: SqlDataReader) =
        let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
        let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
        let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        {|
          ``nvarchar`` = ``nvarchar``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMaxLengthTypes`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMaxLengthTypes``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMaxLengthTypes``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMaxLengthTypes``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 0, Value = ``nvarchar``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = -1, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = -1, Value = ``varchar``)
          |]
        ``ProcWithMaxLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 0, Value = (^a: (member ``Nvarchar``: string) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = -1, Value = (^a: (member ``Varbinary``: byte []) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = -1, Value = (^a: (member ``Varchar``: string) dto))
          |]
        ``ProcWithMaxLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMaxLengthTypesFromTvp_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMaxLengthTypesFromTvp"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

      let getItem (reader: SqlDataReader) =
        let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
        let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
        let ``varchar`` = reader.GetString ``ordinal_varchar``
        {|
          ``nvarchar`` = ``nvarchar``
          ``varbinary`` = ``varbinary``
          ``varchar`` = ``varchar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMaxLengthTypesFromTvp`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMaxLengthTypesFromTvp``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMaxLengthTypesFromTvp``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMaxLengthTypesFromTvp``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``tvp``: seq<TableTypes.``dbo``.``MaxLengthTypes``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MaxLengthTypes", Value = boxNullIfEmpty ``tvp``)
          |]
        ``ProcWithMaxLengthTypesFromTvp_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MaxLengthTypes", Value = boxNullIfEmpty (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MaxLengthTypes``>) dto))
          |]
        ``ProcWithMaxLengthTypesFromTvp_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcWithMultipleColumnsAndNoParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndNoParams"
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetString ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndNoParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndNoParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndNoParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcWithMultipleColumnsAndNoParamsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndNoParamsExtended"
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetString ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndNoParamsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndNoParamsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndNoParamsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleDefaultParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleDefaultParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleColumnsAndSimpleDefaultParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndSimpleDefaultParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleDefaultParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndSimpleDefaultParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleDefaultParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNonDefaultParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndSimpleNonDefaultParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNullParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNullParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleColumnsAndSimpleNullParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndSimpleNullParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNullParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndSimpleNullParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option,
          ``bar``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Bar``: string option) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNullParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNullParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleColumnsAndSimpleNullParamsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndSimpleNullParamsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option,
          ``bar``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Bar``: string option) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndTvpParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndTvpParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetString ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleColumnsAndTvpParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndTvpParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndTvpParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndTvpParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNonNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNonNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = boxNullIfEmpty ``multi``)
          |]
        ``ProcWithMultipleColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNonNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = boxNullIfEmpty (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNonNull``>) dto))
          |]
        ``ProcWithMultipleColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndTvpParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndTvpParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetString ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleColumnsAndTvpParamsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleColumnsAndTvpParamsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndTvpParamsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleColumnsAndTvpParamsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNonNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNonNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = boxNullIfEmpty ``multi``)
          |]
        ``ProcWithMultipleColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNonNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = boxNullIfEmpty (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNonNull``>) dto))
          |]
        ``ProcWithMultipleColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleNullableColumnsAndTvpParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleNullableColumnsAndTvpParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleNullableColumnsAndTvpParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleNullableColumnsAndTvpParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleNullableColumnsAndTvpParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleNullableColumnsAndTvpParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = boxNullIfEmpty ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty ``multi``)
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = boxNullIfEmpty (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleNullableColumnsAndTvpParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleNullableColumnsAndTvpParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithMultipleNullableColumnsAndTvpParamsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithMultipleNullableColumnsAndTvpParamsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNull``>
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = boxNullIfEmpty ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty ``multi``)
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = boxNullIfEmpty (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithNoResults_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNoResults"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


    type ``ProcWithNoResults`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithNoResults``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNoResults``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithNoResults``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithNoResults_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithNoResults_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithNoResultsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNoResultsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


    type ``ProcWithNoResultsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithNoResultsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNoResultsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithNoResultsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithNoResultsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithNoResultsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcWithNonFSharpFriendlyNames`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNonFSharpFriendlyNames"
        userConfigureCmd cmd

      let mutable ``ordinal_This is the first column`` = 0
      let mutable ``ordinal_!"#%&/()=?`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_This is the first column`` <- reader.GetOrdinal "This is the first column"
        ``ordinal_!"#%&/()=?`` <- reader.GetOrdinal "!\"#%&/()=?"

      let getItem (reader: SqlDataReader) =
        let ``This is the first column`` = reader.GetString ``ordinal_This is the first column``
        let ``!"#%&/()=?`` = reader.GetInt32 ``ordinal_!"#%&/()=?``
        {|
          ``This is the first column`` = ``This is the first column``
          ``!"#%&/()=?`` = ``!"#%&/()=?``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithNonFSharpFriendlyNames``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNonFSharpFriendlyNames``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithNonFSharpFriendlyNames``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcWithNonFSharpFriendlyNamesExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNonFSharpFriendlyNamesExtended"
        userConfigureCmd cmd

      let mutable ``ordinal_This is the first column`` = 0
      let mutable ``ordinal_!"#%&/()=?`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_This is the first column`` <- reader.GetOrdinal "This is the first column"
        ``ordinal_!"#%&/()=?`` <- reader.GetOrdinal "!\"#%&/()=?"

      let getItem (reader: SqlDataReader) =
        let ``This is the first column`` = reader.GetString ``ordinal_This is the first column``
        let ``!"#%&/()=?`` = reader.GetInt32 ``ordinal_!"#%&/()=?``
        {|
          ``This is the first column`` = ``This is the first column``
          ``!"#%&/()=?`` = ``!"#%&/()=?``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithNonFSharpFriendlyNamesExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNonFSharpFriendlyNamesExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithNonFSharpFriendlyNamesExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithNullParamOverrides_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNullParamOverrides"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithNullParamOverrides`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithNullParamOverrides``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNullParamOverrides``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithNullParamOverrides``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: int option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.Int, Value = Option.toDbNull ``bar``)
          |]
        ``ProcWithNullParamOverrides_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Bar``: int option) dto))
          |]
        ``ProcWithNullParamOverrides_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams[1].Value = box DBNull.Value then None else sqlParams[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams[3].Value = box DBNull.Value then None else sqlParams[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData
        |> wrapResultWithOutParams sqlParams


    type ``ProcWithOutParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithOutParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithOutParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsAndRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsAndRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams[1].Value = box DBNull.Value then None else sqlParams[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams[3].Value = box DBNull.Value then None else sqlParams[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData
        |> wrapResultWithOutParams sqlParams


    type ``ProcWithOutParamsAndRetVal`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithOutParamsAndRetVal``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsAndRetVal``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithOutParamsAndRetVal``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsAndRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsAndRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams[1].Value = box DBNull.Value then None else sqlParams[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams[3].Value = box DBNull.Value then None else sqlParams[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData
        |> wrapResultWithOutParams sqlParams


    type ``ProcWithOutParamsAndRetValExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithOutParamsAndRetValExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsAndRetValExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithOutParamsAndRetValExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsAndRetValVoption_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsAndRetValVoption"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams[1].Value = box DBNull.Value then ValueNone else sqlParams[1].Value |> unbox<int> |> ValueSome
              ``out2`` = if sqlParams[3].Value = box DBNull.Value then ValueNone else sqlParams[3].Value |> unbox<string> |> ValueSome
            |}
          ReturnValue = sqlParams[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData
        |> wrapResultWithOutParams sqlParams


    type ``ProcWithOutParamsAndRetValVoption`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithOutParamsAndRetValVoption``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsAndRetValVoption``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithOutParamsAndRetValVoption``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string voption
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map ValueOption.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = ValueOption.toDbNull (^a: (member ``Out1``: int voption) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = ValueOption.toDbNull (^a: (member ``Out2``: string voption) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams[1].Value = box DBNull.Value then None else sqlParams[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams[3].Value = box DBNull.Value then None else sqlParams[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData
        |> wrapResultWithOutParams sqlParams


    type ``ProcWithOutParamsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithOutParamsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithOutParamsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOverriddenDtoParamName_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOverriddenDtoParamName"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithOverriddenDtoParamName`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithOverriddenDtoParamName``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOverriddenDtoParamName``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithOverriddenDtoParamName``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``nameToBeOverridden``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = ``nameToBeOverridden``)
          |]
        ``ProcWithOverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = (^a: (member ``newDtoParamName``: int) dto))
          |]
        ``ProcWithOverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams[1].Value = box DBNull.Value then None else sqlParams[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams[3].Value = box DBNull.Value then None else sqlParams[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithResultsAndOutParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithResultsAndOutParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithResultsAndOutParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithResultsAndOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithResultsAndOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParamsAndRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParamsAndRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams[1].Value = box DBNull.Value then None else sqlParams[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams[3].Value = box DBNull.Value then None else sqlParams[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithResultsAndOutParamsAndRetVal`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithResultsAndOutParamsAndRetVal``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParamsAndRetVal``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithResultsAndOutParamsAndRetVal``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParamsAndRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParamsAndRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams[1].Value = box DBNull.Value then None else sqlParams[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams[3].Value = box DBNull.Value then None else sqlParams[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithResultsAndOutParamsAndRetValExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithResultsAndOutParamsAndRetValExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParamsAndRetValExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithResultsAndOutParamsAndRetValExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams[1].Value = box DBNull.Value then None else sqlParams[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams[3].Value = box DBNull.Value then None else sqlParams[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithResultsAndOutParamsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithResultsAndOutParamsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParamsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithResultsAndOutParamsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithResultsAndOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithResultsAndOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          ReturnValue = sqlParams[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithResultsAndRetVal`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithResultsAndRetVal``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndRetVal``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithResultsAndRetVal``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        let ``Foo`` = reader.GetInt32 ``ordinal_Foo``
        let ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        {|
          ``Foo`` = ``Foo``
          ``Bar`` = ``Bar``
        |}

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          ReturnValue = sqlParams[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData
        |> wrapResultWithOutParams sqlParams

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithResultsAndRetValExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithResultsAndRetValExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndRetValExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithResultsAndRetValExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          ReturnValue = sqlParams[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData
        |> wrapResultWithOutParams sqlParams


    type ``ProcWithRetVal`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithRetVal``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithRetVal``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithRetVal``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams (sqlParams: SqlParameter []) result =
        {|
          Result = result
          ReturnValue = sqlParams[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map (wrapResultWithOutParams sqlParams)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData
        |> wrapResultWithOutParams sqlParams


    type ``ProcWithRetValExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithRetValExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithRetValExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithRetValExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcWithSingleColumnAndNoParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleColumnAndNoParams"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSingleColumnAndNoParams``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleColumnAndNoParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSingleColumnAndNoParams``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcWithSingleColumnAndNoParamsExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleColumnAndNoParamsExtended"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSingleColumnAndNoParamsExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleColumnAndNoParamsExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSingleColumnAndNoParamsExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcWithSingleNamelessColumn`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNamelessColumn"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSingleNamelessColumn``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNamelessColumn``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSingleNamelessColumn``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcWithSingleNamelessColumnExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNamelessColumnExtended"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSingleNamelessColumnExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNamelessColumnExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSingleNamelessColumnExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNonNullColumn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNonNullColumn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithSingleNonNullColumn`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSingleNonNullColumn``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNonNullColumn``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSingleNonNullColumn``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithSingleNonNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithSingleNonNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNonNullColumnExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNonNullColumnExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithSingleNonNullColumnExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSingleNonNullColumnExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNonNullColumnExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSingleNonNullColumnExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithSingleNonNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithSingleNonNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNullColumn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNullColumn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithSingleNullColumn`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSingleNullColumn``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNullColumn``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSingleNullColumn``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
          |]
        ``ProcWithSingleNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
          |]
        ``ProcWithSingleNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNullColumnExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNullColumnExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithSingleNullColumnExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSingleNullColumnExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNullColumnExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSingleNullColumnExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
          |]
        ``ProcWithSingleNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
          |]
        ``ProcWithSingleNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    type ``ProcWithSingleRecordCol`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleRecordCol"
        userConfigureCmd cmd

      let mutable ``ordinal_Test`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Test`` <- reader.GetOrdinal "Test"

      let getItem (reader: SqlDataReader) =
        let ``Test`` = reader.GetInt32 ``ordinal_Test``
        {|
          ``Test`` = ``Test``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSingleRecordCol``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleRecordCol``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSingleRecordCol``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    type ``ProcWithSkippedUnsupportedColumn`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSkippedUnsupportedColumn"
        userConfigureCmd cmd

      let mutable ``ordinal_SupportedCol1`` = 0
      let mutable ``ordinal_SupportedCol2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_SupportedCol1`` <- reader.GetOrdinal "SupportedCol1"
        ``ordinal_SupportedCol2`` <- reader.GetOrdinal "SupportedCol2"

      let getItem (reader: SqlDataReader) =
        let ``SupportedCol1`` = reader.GetInt32 ``ordinal_SupportedCol1``
        let ``SupportedCol2`` = reader.GetString ``ordinal_SupportedCol2``
        {|
          ``SupportedCol1`` = ``SupportedCol1``
          ``SupportedCol2`` = ``SupportedCol2``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSkippedUnsupportedColumn``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSkippedUnsupportedColumn``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSkippedUnsupportedColumn``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecute() =
        executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSpecialCasing_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSpecialCasing"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_COL1`` = 0
      let mutable ``ordinal_Col2`` = 0
      let mutable ``ordinal_col3`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_COL1`` <- reader.GetOrdinal "COL1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"
        ``ordinal_col3`` <- reader.GetOrdinal "col3"

      let getItem (reader: SqlDataReader) =
        let ``COL1`` = if reader.IsDBNull ``ordinal_COL1`` then None else reader.GetInt32 ``ordinal_COL1`` |> Some
        let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
        let ``col3`` = if reader.IsDBNull ``ordinal_col3`` then None else reader.GetInt32 ``ordinal_col3`` |> Some
        {|
          ``COL1`` = ``COL1``
          ``Col2`` = ``Col2``
          ``col3`` = ``col3``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithSpecialCasing`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSpecialCasing``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSpecialCasing``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSpecialCasing``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``PARAM1``: int,
          ``Param2``: int,
          ``param3``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = ``PARAM1``)
            SqlParameter("@Param2", SqlDbType.Int, Value = ``Param2``)
            SqlParameter("@param3", SqlDbType.Int, Value = ``param3``)
          |]
        ``ProcWithSpecialCasing_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = (^a: (member ``PARAM1``: int) dto))
            SqlParameter("@Param2", SqlDbType.Int, Value = (^a: (member ``Param2``: int) dto))
            SqlParameter("@param3", SqlDbType.Int, Value = (^a: (member ``Param3``: int) dto))
          |]
        ``ProcWithSpecialCasing_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSpecialCasingExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSpecialCasingExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_COL1`` = 0
      let mutable ``ordinal_Col2`` = 0
      let mutable ``ordinal_col3`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_COL1`` <- reader.GetOrdinal "COL1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"
        ``ordinal_col3`` <- reader.GetOrdinal "col3"

      let getItem (reader: SqlDataReader) =
        let ``COL1`` = if reader.IsDBNull ``ordinal_COL1`` then None else reader.GetInt32 ``ordinal_COL1`` |> Some
        let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
        let ``col3`` = if reader.IsDBNull ``ordinal_col3`` then None else reader.GetInt32 ``ordinal_col3`` |> Some
        {|
          ``COL1`` = ``COL1``
          ``Col2`` = ``Col2``
          ``col3`` = ``col3``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithSpecialCasingExtended`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithSpecialCasingExtended``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSpecialCasingExtended``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithSpecialCasingExtended``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``PARAM1``: int,
          ``Param2``: int,
          ``param3``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = ``PARAM1``)
            SqlParameter("@Param2", SqlDbType.Int, Value = ``Param2``)
            SqlParameter("@param3", SqlDbType.Int, Value = ``param3``)
          |]
        ``ProcWithSpecialCasingExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = (^a: (member ``PARAM1``: int) dto))
            SqlParameter("@Param2", SqlDbType.Int, Value = (^a: (member ``Param2``: int) dto))
            SqlParameter("@param3", SqlDbType.Int, Value = (^a: (member ``Param3``: int) dto))
          |]
        ``ProcWithSpecialCasingExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


    module ``ProcWithTempTable`` =


      type ``tempTable`` (__: InternalUseOnly, fields: obj []) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member _.Fields = fields

        static member create
          (
            ``Col1``: int,
            ``Col2``: string option
          ) : ``tempTable`` =
          [|
            ``Col1`` |> box
            Option.toDbNull ``Col2`` |> box
          |]
          |> fun fields -> ``tempTable``(internalUseOnlyValue, fields)

        static member inline create (dto: ^a) : ``tempTable`` =
          [|
            (^a: (member ``Col1``: int) dto) |> box
            Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
          |]
          |> fun fields -> ``tempTable``(internalUseOnlyValue, fields)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithTempTable_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithTempTable"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) =
        let ``Col1`` = reader.GetInt32 ``ordinal_Col1``
        let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetString ``ordinal_Col2`` |> Some
        {|
          ``Col1`` = ``Col1``
          ``Col2`` = ``Col2``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.LazyExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecute() =
        let sqlParams = getSqlParams ()
        executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        let sqlParams = getSqlParams ()
        executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReader() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
        }

      /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReader() =
        let sqlParams = getSqlParams ()
        executeReader connStr conn tran configureConn (configureCmd sqlParams) []

      /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingleAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

      /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
      member this.AsyncExecuteReaderSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
        }

      /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
      member this.ExecuteReaderSingle() =
        let sqlParams = getSqlParams ()
        executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


    type ``ProcWithTempTable`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithTempTable``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
        this.userConfigureBulkCopy <- configureBulkCopy
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithTempTable``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithTempTable``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member this.CreateTempTableData
        (
          ``tempTable``: seq<``ProcWithTempTable``.``tempTable``>
        ) =
        [
          TempTableData
            (
              "#tempTable",
              """
              DROP TABLE IF EXISTS #tempTable
              CREATE TABLE #tempTable (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
              """,
              (``tempTable`` |> Seq.map (fun x -> x.Fields)),
              2,
              Action<_> this.userConfigureBulkCopy
            )
        ]
      member this.WithParameters
        (
          ``tempTable``: seq<``ProcWithTempTable``.``tempTable``>,
          ``param``: int
        ) =
        let getSqlParams () =
          [|
            SqlParameter("@param", SqlDbType.Int, Value = ``param``)
          |]
        let tempTableData =
          this.CreateTempTableData(
            ``tempTable``
          )
        ``ProcWithTempTable_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
            SqlParameter("@param", SqlDbType.Int, Value = (^a: (member ``Param``: int) dto))
          |]
        let tempTableData =
          this.CreateTempTableData(
            (^a: (member ``TempTable``: #seq<``ProcWithTempTable``.``tempTable``>) dto)
          )
        ``ProcWithTempTable_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


    module ``ProcWithTempTableNonIntrospectable`` =


      type ``tempTable`` (__: InternalUseOnly, fields: obj []) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member _.Fields = fields

        static member create
          (
            ``Col1``: int,
            ``Col2``: string option
          ) : ``tempTable`` =
          [|
            ``Col1`` |> box
            Option.toDbNull ``Col2`` |> box
          |]
          |> fun fields -> ``tempTable``(internalUseOnlyValue, fields)

        static member inline create (dto: ^a) : ``tempTable`` =
          [|
            (^a: (member ``Col1``: int) dto) |> box
            Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
          |]
          |> fun fields -> ``tempTable``(internalUseOnlyValue, fields)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithTempTableNonIntrospectable_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

      let configureCmd sqlParams (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithTempTableNonIntrospectable"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      member _.ExecuteAsync(?cancellationToken) =
        let sqlParams = getSqlParams ()
        executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        let sqlParams = getSqlParams ()
        executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


    type ``ProcWithTempTableNonIntrospectable`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      new() =
        failwith "This constructor is for aiding reflection and type constraints only"
        ``ProcWithTempTableNonIntrospectable``(null, null, null)

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val tran = tran

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
        this.userConfigureBulkCopy <- configureBulkCopy
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithTempTableNonIntrospectable``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection, ?transaction) = ``ProcWithTempTableNonIntrospectable``(null, connection, defaultArg transaction null)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member this.CreateTempTableData
        (
          ``tempTable``: seq<``ProcWithTempTableNonIntrospectable``.``tempTable``>
        ) =
        [
          TempTableData
            (
              "#tempTable",
              """
              CREATE TABLE #tempTable (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
              """,
              (``tempTable`` |> Seq.map (fun x -> x.Fields)),
              2,
              Action<_> this.userConfigureBulkCopy
            )
        ]
      member this.WithParameters
        (
          ``tempTable``: seq<``ProcWithTempTableNonIntrospectable``.``tempTable``>
        ) =
        let getSqlParams () =
          [|
          |]
        let tempTableData =
          this.CreateTempTableData(
            ``tempTable``
          )
        ``ProcWithTempTableNonIntrospectable_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

      member inline this.WithParameters(dto: ^a) =
        let getSqlParams () =
          [|
          |]
        let tempTableData =
          this.CreateTempTableData(
            (^a: (member ``TempTable``: #seq<``ProcWithTempTableNonIntrospectable``.``tempTable``>) dto)
          )
        ``ProcWithTempTableNonIntrospectable_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


module Scripts =


  type ``AllTypesNonNull_All`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNonNull_All
SELECT
  [key],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
FROM
  [dbo].[AllTypesNonNull]"""
      userConfigureCmd cmd

    let mutable ``ordinal_key`` = 0
    let mutable ``ordinal_bigint`` = 0
    let mutable ``ordinal_binary`` = 0
    let mutable ``ordinal_bit`` = 0
    let mutable ``ordinal_char`` = 0
    let mutable ``ordinal_date`` = 0
    let mutable ``ordinal_datetime`` = 0
    let mutable ``ordinal_datetime2`` = 0
    let mutable ``ordinal_datetimeoffset`` = 0
    let mutable ``ordinal_decimal`` = 0
    let mutable ``ordinal_float`` = 0
    let mutable ``ordinal_image`` = 0
    let mutable ``ordinal_int`` = 0
    let mutable ``ordinal_money`` = 0
    let mutable ``ordinal_nchar`` = 0
    let mutable ``ordinal_ntext`` = 0
    let mutable ``ordinal_numeric`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_real`` = 0
    let mutable ``ordinal_smalldatetime`` = 0
    let mutable ``ordinal_smallint`` = 0
    let mutable ``ordinal_smallmoney`` = 0
    let mutable ``ordinal_text`` = 0
    let mutable ``ordinal_time`` = 0
    let mutable ``ordinal_tinyint`` = 0
    let mutable ``ordinal_uniqueidentifier`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0
    let mutable ``ordinal_xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_key`` <- reader.GetOrdinal "key"
      ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
      ``ordinal_binary`` <- reader.GetOrdinal "binary"
      ``ordinal_bit`` <- reader.GetOrdinal "bit"
      ``ordinal_char`` <- reader.GetOrdinal "char"
      ``ordinal_date`` <- reader.GetOrdinal "date"
      ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
      ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
      ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
      ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
      ``ordinal_float`` <- reader.GetOrdinal "float"
      ``ordinal_image`` <- reader.GetOrdinal "image"
      ``ordinal_int`` <- reader.GetOrdinal "int"
      ``ordinal_money`` <- reader.GetOrdinal "money"
      ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
      ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
      ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_real`` <- reader.GetOrdinal "real"
      ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
      ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
      ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
      ``ordinal_text`` <- reader.GetOrdinal "text"
      ``ordinal_time`` <- reader.GetOrdinal "time"
      ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
      ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
      ``ordinal_xml`` <- reader.GetOrdinal "xml"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``AllTypesNonNull`` =
      let ``key`` = reader.GetInt32 ``ordinal_key``
      let ``bigint`` = reader.GetInt64 ``ordinal_bigint``
      let ``binary`` = reader.GetBytes ``ordinal_binary``
      let ``bit`` = reader.GetBoolean ``ordinal_bit``
      let ``char`` = reader.GetString ``ordinal_char``
      let ``date`` = reader.GetDateTime ``ordinal_date``
      let ``datetime`` = reader.GetDateTime ``ordinal_datetime``
      let ``datetime2`` = reader.GetDateTime ``ordinal_datetime2``
      let ``datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_datetimeoffset``
      let ``decimal`` = reader.GetDecimal ``ordinal_decimal``
      let ``float`` = reader.GetDouble ``ordinal_float``
      let ``image`` = reader.GetBytes ``ordinal_image``
      let ``int`` = reader.GetInt32 ``ordinal_int``
      let ``money`` = reader.GetDecimal ``ordinal_money``
      let ``nchar`` = reader.GetString ``ordinal_nchar``
      let ``ntext`` = reader.GetString ``ordinal_ntext``
      let ``numeric`` = reader.GetDecimal ``ordinal_numeric``
      let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
      let ``real`` = reader.GetFloat ``ordinal_real``
      let ``smalldatetime`` = reader.GetDateTime ``ordinal_smalldatetime``
      let ``smallint`` = reader.GetInt16 ``ordinal_smallint``
      let ``smallmoney`` = reader.GetDecimal ``ordinal_smallmoney``
      let ``text`` = reader.GetString ``ordinal_text``
      let ``time`` = reader.GetTimeSpan ``ordinal_time``
      let ``tinyint`` = reader.GetByte ``ordinal_tinyint``
      let ``uniqueidentifier`` = reader.GetGuid ``ordinal_uniqueidentifier``
      let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
      let ``varchar`` = reader.GetString ``ordinal_varchar``
      let ``xml`` = reader.GetString ``ordinal_xml``
      {
        ``Key`` = ``key``
        ``Bigint`` = ``bigint``
        ``Binary`` = ``binary``
        ``Bit`` = ``bit``
        ``Char`` = ``char``
        ``Date`` = ``date``
        ``Datetime`` = ``datetime``
        ``Datetime2`` = ``datetime2``
        ``Datetimeoffset`` = ``datetimeoffset``
        ``Decimal`` = ``decimal``
        ``Float`` = ``float``
        ``Image`` = ``image``
        ``Int`` = ``int``
        ``Money`` = ``money``
        ``Nchar`` = ``nchar``
        ``Ntext`` = ``ntext``
        ``Numeric`` = ``numeric``
        ``Nvarchar`` = ``nvarchar``
        ``Real`` = ``real``
        ``Smalldatetime`` = ``smalldatetime``
        ``Smallint`` = ``smallint``
        ``Smallmoney`` = ``smallmoney``
        ``Text`` = ``text``
        ``Time`` = ``time``
        ``Tinyint`` = ``tinyint``
        ``Uniqueidentifier`` = ``uniqueidentifier``
        ``Varbinary`` = ``varbinary``
        ``Varchar`` = ``varchar``
        ``Xml`` = ``xml``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNonNull_All``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNonNull_All``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNonNull_All``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNonNull_ById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNonNull_ById
SELECT
  [key],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
FROM
  [dbo].[AllTypesNonNull]
WHERE
  [key] = @key"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_key`` = 0
    let mutable ``ordinal_bigint`` = 0
    let mutable ``ordinal_binary`` = 0
    let mutable ``ordinal_bit`` = 0
    let mutable ``ordinal_char`` = 0
    let mutable ``ordinal_date`` = 0
    let mutable ``ordinal_datetime`` = 0
    let mutable ``ordinal_datetime2`` = 0
    let mutable ``ordinal_datetimeoffset`` = 0
    let mutable ``ordinal_decimal`` = 0
    let mutable ``ordinal_float`` = 0
    let mutable ``ordinal_image`` = 0
    let mutable ``ordinal_int`` = 0
    let mutable ``ordinal_money`` = 0
    let mutable ``ordinal_nchar`` = 0
    let mutable ``ordinal_ntext`` = 0
    let mutable ``ordinal_numeric`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_real`` = 0
    let mutable ``ordinal_smalldatetime`` = 0
    let mutable ``ordinal_smallint`` = 0
    let mutable ``ordinal_smallmoney`` = 0
    let mutable ``ordinal_text`` = 0
    let mutable ``ordinal_time`` = 0
    let mutable ``ordinal_tinyint`` = 0
    let mutable ``ordinal_uniqueidentifier`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0
    let mutable ``ordinal_xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_key`` <- reader.GetOrdinal "key"
      ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
      ``ordinal_binary`` <- reader.GetOrdinal "binary"
      ``ordinal_bit`` <- reader.GetOrdinal "bit"
      ``ordinal_char`` <- reader.GetOrdinal "char"
      ``ordinal_date`` <- reader.GetOrdinal "date"
      ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
      ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
      ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
      ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
      ``ordinal_float`` <- reader.GetOrdinal "float"
      ``ordinal_image`` <- reader.GetOrdinal "image"
      ``ordinal_int`` <- reader.GetOrdinal "int"
      ``ordinal_money`` <- reader.GetOrdinal "money"
      ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
      ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
      ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_real`` <- reader.GetOrdinal "real"
      ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
      ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
      ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
      ``ordinal_text`` <- reader.GetOrdinal "text"
      ``ordinal_time`` <- reader.GetOrdinal "time"
      ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
      ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
      ``ordinal_xml`` <- reader.GetOrdinal "xml"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``AllTypesNonNull`` =
      let ``key`` = reader.GetInt32 ``ordinal_key``
      let ``bigint`` = reader.GetInt64 ``ordinal_bigint``
      let ``binary`` = reader.GetBytes ``ordinal_binary``
      let ``bit`` = reader.GetBoolean ``ordinal_bit``
      let ``char`` = reader.GetString ``ordinal_char``
      let ``date`` = reader.GetDateTime ``ordinal_date``
      let ``datetime`` = reader.GetDateTime ``ordinal_datetime``
      let ``datetime2`` = reader.GetDateTime ``ordinal_datetime2``
      let ``datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_datetimeoffset``
      let ``decimal`` = reader.GetDecimal ``ordinal_decimal``
      let ``float`` = reader.GetDouble ``ordinal_float``
      let ``image`` = reader.GetBytes ``ordinal_image``
      let ``int`` = reader.GetInt32 ``ordinal_int``
      let ``money`` = reader.GetDecimal ``ordinal_money``
      let ``nchar`` = reader.GetString ``ordinal_nchar``
      let ``ntext`` = reader.GetString ``ordinal_ntext``
      let ``numeric`` = reader.GetDecimal ``ordinal_numeric``
      let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
      let ``real`` = reader.GetFloat ``ordinal_real``
      let ``smalldatetime`` = reader.GetDateTime ``ordinal_smalldatetime``
      let ``smallint`` = reader.GetInt16 ``ordinal_smallint``
      let ``smallmoney`` = reader.GetDecimal ``ordinal_smallmoney``
      let ``text`` = reader.GetString ``ordinal_text``
      let ``time`` = reader.GetTimeSpan ``ordinal_time``
      let ``tinyint`` = reader.GetByte ``ordinal_tinyint``
      let ``uniqueidentifier`` = reader.GetGuid ``ordinal_uniqueidentifier``
      let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
      let ``varchar`` = reader.GetString ``ordinal_varchar``
      let ``xml`` = reader.GetString ``ordinal_xml``
      {
        ``Key`` = ``key``
        ``Bigint`` = ``bigint``
        ``Binary`` = ``binary``
        ``Bit`` = ``bit``
        ``Char`` = ``char``
        ``Date`` = ``date``
        ``Datetime`` = ``datetime``
        ``Datetime2`` = ``datetime2``
        ``Datetimeoffset`` = ``datetimeoffset``
        ``Decimal`` = ``decimal``
        ``Float`` = ``float``
        ``Image`` = ``image``
        ``Int`` = ``int``
        ``Money`` = ``money``
        ``Nchar`` = ``nchar``
        ``Ntext`` = ``ntext``
        ``Numeric`` = ``numeric``
        ``Nvarchar`` = ``nvarchar``
        ``Real`` = ``real``
        ``Smalldatetime`` = ``smalldatetime``
        ``Smallint`` = ``smallint``
        ``Smallmoney`` = ``smallmoney``
        ``Text`` = ``text``
        ``Time`` = ``time``
        ``Tinyint`` = ``tinyint``
        ``Uniqueidentifier`` = ``uniqueidentifier``
        ``Varbinary`` = ``varbinary``
        ``Varchar`` = ``varchar``
        ``Xml`` = ``xml``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``AllTypesNonNull_ById`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNonNull_ById``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNonNull_ById``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNonNull_ById``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
        |]
      ``AllTypesNonNull_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
        |]
      ``AllTypesNonNull_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNonNull_Delete_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNonNull_Delete
DELETE FROM [dbo].[AllTypesNonNull]
WHERE
  [key] = @key"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNonNull_Delete`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNonNull_Delete``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNonNull_Delete``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNonNull_Delete``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
        |]
      ``AllTypesNonNull_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
        |]
      ``AllTypesNonNull_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNonNull_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNonNull_Insert
INSERT INTO [dbo].[AllTypesNonNull]
(
  [key],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
)
VALUES
(
  @key,
  @bigint,
  @binary,
  @bit,
  @char,
  @date,
  @datetime,
  @datetime2,
  @datetimeoffset,
  @decimal,
  @float,
  @image,
  @int,
  @money,
  @nchar,
  @ntext,
  @numeric,
  @nvarchar,
  @real,
  @smalldatetime,
  @smallint,
  @smallmoney,
  @text,
  @time,
  @tinyint,
  @uniqueidentifier,
  @varbinary,
  @varchar,
  @xml
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNonNull_Insert`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNonNull_Insert``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNonNull_Insert``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNonNull_Insert``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int,
        ``bigint``: int64,
        ``binary``: byte [],
        ``bit``: bool,
        ``char``: string,
        ``date``: DateTime,
        ``datetime``: DateTime,
        ``datetime2``: DateTime,
        ``datetimeoffset``: DateTimeOffset,
        ``decimal``: decimal,
        ``float``: float,
        ``image``: byte [],
        ``int``: int,
        ``money``: decimal,
        ``nchar``: string,
        ``ntext``: string,
        ``numeric``: decimal,
        ``nvarchar``: string,
        ``real``: float32,
        ``smalldatetime``: DateTime,
        ``smallint``: int16,
        ``smallmoney``: decimal,
        ``text``: string,
        ``time``: TimeSpan,
        ``tinyint``: byte,
        ``uniqueidentifier``: Guid,
        ``varbinary``: byte [],
        ``varchar``: string,
        ``xml``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
          SqlParameter("bigint", SqlDbType.BigInt, Value = ``bigint``)
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
          SqlParameter("bit", SqlDbType.Bit, Value = ``bit``)
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = ``char``)
          SqlParameter("date", SqlDbType.Date, Value = ``date``)
          SqlParameter("datetime", SqlDbType.DateTime, Value = ``datetime``)
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = ``float``)
          SqlParameter("image", SqlDbType.Image, Value = ``image``)
          SqlParameter("int", SqlDbType.Int, Value = ``int``)
          SqlParameter("money", SqlDbType.Money, Value = ``money``)
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
          SqlParameter("ntext", SqlDbType.NText, Value = ``ntext``)
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
          SqlParameter("real", SqlDbType.Real, Value = ``real``)
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
          SqlParameter("smallint", SqlDbType.SmallInt, Value = ``smallint``)
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
          SqlParameter("text", SqlDbType.Text, Value = ``text``)
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = ``time``)
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
          SqlParameter("xml", SqlDbType.Xml, Value = ``xml``)
        |]
      ``AllTypesNonNull_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
          SqlParameter("bigint", SqlDbType.BigInt, Value = (^a: (member ``Bigint``: int64) dto))
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = (^a: (member ``Binary``: byte []) dto))
          SqlParameter("bit", SqlDbType.Bit, Value = (^a: (member ``Bit``: bool) dto))
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = (^a: (member ``Char``: string) dto))
          SqlParameter("date", SqlDbType.Date, Value = (^a: (member ``Date``: DateTime) dto))
          SqlParameter("datetime", SqlDbType.DateTime, Value = (^a: (member ``Datetime``: DateTime) dto))
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = (^a: (member ``Datetime2``: DateTime) dto))
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = (^a: (member ``Datetimeoffset``: DateTimeOffset) dto))
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = (^a: (member ``Decimal``: decimal) dto))
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = (^a: (member ``Float``: float) dto))
          SqlParameter("image", SqlDbType.Image, Value = (^a: (member ``Image``: byte []) dto))
          SqlParameter("int", SqlDbType.Int, Value = (^a: (member ``Int``: int) dto))
          SqlParameter("money", SqlDbType.Money, Value = (^a: (member ``Money``: decimal) dto))
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = (^a: (member ``Nchar``: string) dto))
          SqlParameter("ntext", SqlDbType.NText, Value = (^a: (member ``Ntext``: string) dto))
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = (^a: (member ``Numeric``: decimal) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Nvarchar``: string) dto))
          SqlParameter("real", SqlDbType.Real, Value = (^a: (member ``Real``: float32) dto))
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = (^a: (member ``Smalldatetime``: DateTime) dto))
          SqlParameter("smallint", SqlDbType.SmallInt, Value = (^a: (member ``Smallint``: int16) dto))
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = (^a: (member ``Smallmoney``: decimal) dto))
          SqlParameter("text", SqlDbType.Text, Value = (^a: (member ``Text``: string) dto))
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = (^a: (member ``Time``: TimeSpan) dto))
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = (^a: (member ``Tinyint``: byte) dto))
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Uniqueidentifier``: Guid) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = (^a: (member ``Varbinary``: byte []) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = (^a: (member ``Varchar``: string) dto))
          SqlParameter("xml", SqlDbType.Xml, Value = (^a: (member ``Xml``: string) dto))
        |]
      ``AllTypesNonNull_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``AllTypesNonNull_InsertBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key``: int,
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) : ``args`` =
        [|
          ``key`` |> box
          ``bigint`` |> box
          ``binary`` |> box
          ``bit`` |> box
          ``char`` |> box
          ``date`` |> box
          ``datetime`` |> box
          ``datetime2`` |> box
          ``datetimeoffset`` |> box
          ``decimal`` |> box
          ``float`` |> box
          ``image`` |> box
          ``int`` |> box
          ``money`` |> box
          ``nchar`` |> box
          ``ntext`` |> box
          ``numeric`` |> box
          ``nvarchar`` |> box
          ``real`` |> box
          ``smalldatetime`` |> box
          ``smallint`` |> box
          ``smallmoney`` |> box
          ``text`` |> box
          ``time`` |> box
          ``tinyint`` |> box
          ``uniqueidentifier`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
          ``xml`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key``: int) dto) |> box
          (^a: (member ``bigint``: int64) dto) |> box
          (^a: (member ``binary``: byte []) dto) |> box
          (^a: (member ``bit``: bool) dto) |> box
          (^a: (member ``char``: string) dto) |> box
          (^a: (member ``date``: DateTime) dto) |> box
          (^a: (member ``datetime``: DateTime) dto) |> box
          (^a: (member ``datetime2``: DateTime) dto) |> box
          (^a: (member ``datetimeoffset``: DateTimeOffset) dto) |> box
          (^a: (member ``decimal``: decimal) dto) |> box
          (^a: (member ``float``: float) dto) |> box
          (^a: (member ``image``: byte []) dto) |> box
          (^a: (member ``int``: int) dto) |> box
          (^a: (member ``money``: decimal) dto) |> box
          (^a: (member ``nchar``: string) dto) |> box
          (^a: (member ``ntext``: string) dto) |> box
          (^a: (member ``numeric``: decimal) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``real``: float32) dto) |> box
          (^a: (member ``smalldatetime``: DateTime) dto) |> box
          (^a: (member ``smallint``: int16) dto) |> box
          (^a: (member ``smallmoney``: decimal) dto) |> box
          (^a: (member ``text``: string) dto) |> box
          (^a: (member ``time``: TimeSpan) dto) |> box
          (^a: (member ``tinyint``: byte) dto) |> box
          (^a: (member ``uniqueidentifier``: Guid) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
          (^a: (member ``xml``: string) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNonNull_InsertBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNonNull_InsertBatch
INSERT INTO [dbo].[AllTypesNonNull]
(
  [key],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
)
SELECT
  [key],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
FROM #args"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNonNull_InsertBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNonNull_InsertBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNonNull_InsertBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNonNull_InsertBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``AllTypesNonNull_InsertBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key] INT NOT NULL,
              [bigint] BIGINT NOT NULL,
              [binary] BINARY(42) NOT NULL,
              [bit] BIT NOT NULL,
              [char] CHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [date] DATE NOT NULL,
              [datetime] DATETIME NOT NULL,
              [datetime2] DATETIME2(3) NOT NULL,
              [datetimeoffset] DATETIMEOFFSET(1) NOT NULL,
              [decimal] DECIMAL(10, 5) NOT NULL,
              [float] FLOAT(53) NOT NULL,
              [image] IMAGE NOT NULL,
              [int] INT NOT NULL,
              [money] MONEY NOT NULL,
              [nchar] NCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [ntext] NTEXT COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [numeric] NUMERIC(8, 3) NOT NULL,
              [nvarchar] NVARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [real] REAL NOT NULL,
              [smalldatetime] SMALLDATETIME NOT NULL,
              [smallint] SMALLINT NOT NULL,
              [smallmoney] SMALLMONEY NOT NULL,
              [text] TEXT COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [time] TIME(1) NOT NULL,
              [tinyint] TINYINT NOT NULL,
              [uniqueidentifier] UNIQUEIDENTIFIER NOT NULL,
              [varbinary] VARBINARY(42) NOT NULL,
              [varchar] VARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [xml] XML NOT NULL
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            29,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``AllTypesNonNull_InsertBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``AllTypesNonNull_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``AllTypesNonNull_InsertBatch``.``args``>) dto)
        )
      ``AllTypesNonNull_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNonNull_Merge_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNonNull_Merge
MERGE [dbo].[AllTypesNonNull]
USING
(
  SELECT
    [key] = @key,
    [bigint] = @bigint,
    [binary] = @binary,
    [bit] = @bit,
    [char] = @char,
    [date] = @date,
    [datetime] = @datetime,
    [datetime2] = @datetime2,
    [datetimeoffset] = @datetimeoffset,
    [decimal] = @decimal,
    [float] = @float,
    [image] = @image,
    [int] = @int,
    [money] = @money,
    [nchar] = @nchar,
    [ntext] = @ntext,
    [numeric] = @numeric,
    [nvarchar] = @nvarchar,
    [real] = @real,
    [smalldatetime] = @smalldatetime,
    [smallint] = @smallint,
    [smallmoney] = @smallmoney,
    [text] = @text,
    [time] = @time,
    [tinyint] = @tinyint,
    [uniqueidentifier] = @uniqueidentifier,
    [varbinary] = @varbinary,
    [varchar] = @varchar,
    [xml] = @xml
)
AS x
ON
  [AllTypesNonNull].[key] = x.[key]

WHEN MATCHED THEN
  UPDATE
  SET
    [bigint] = x.[bigint],
    [binary] = x.[binary],
    [bit] = x.[bit],
    [char] = x.[char],
    [date] = x.[date],
    [datetime] = x.[datetime],
    [datetime2] = x.[datetime2],
    [datetimeoffset] = x.[datetimeoffset],
    [decimal] = x.[decimal],
    [float] = x.[float],
    [image] = x.[image],
    [int] = x.[int],
    [money] = x.[money],
    [nchar] = x.[nchar],
    [ntext] = x.[ntext],
    [numeric] = x.[numeric],
    [nvarchar] = x.[nvarchar],
    [real] = x.[real],
    [smalldatetime] = x.[smalldatetime],
    [smallint] = x.[smallint],
    [smallmoney] = x.[smallmoney],
    [text] = x.[text],
    [time] = x.[time],
    [tinyint] = x.[tinyint],
    [uniqueidentifier] = x.[uniqueidentifier],
    [varbinary] = x.[varbinary],
    [varchar] = x.[varchar],
    [xml] = x.[xml]

WHEN NOT MATCHED THEN
  INSERT
  (
    [key],
    [bigint],
    [binary],
    [bit],
    [char],
    [date],
    [datetime],
    [datetime2],
    [datetimeoffset],
    [decimal],
    [float],
    [image],
    [int],
    [money],
    [nchar],
    [ntext],
    [numeric],
    [nvarchar],
    [real],
    [smalldatetime],
    [smallint],
    [smallmoney],
    [text],
    [time],
    [tinyint],
    [uniqueidentifier],
    [varbinary],
    [varchar],
    [xml]
  )
  VALUES
  (
    x.[key],
    x.[bigint],
    x.[binary],
    x.[bit],
    x.[char],
    x.[date],
    x.[datetime],
    x.[datetime2],
    x.[datetimeoffset],
    x.[decimal],
    x.[float],
    x.[image],
    x.[int],
    x.[money],
    x.[nchar],
    x.[ntext],
    x.[numeric],
    x.[nvarchar],
    x.[real],
    x.[smalldatetime],
    x.[smallint],
    x.[smallmoney],
    x.[text],
    x.[time],
    x.[tinyint],
    x.[uniqueidentifier],
    x.[varbinary],
    x.[varchar],
    x.[xml]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNonNull_Merge`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNonNull_Merge``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNonNull_Merge``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNonNull_Merge``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int,
        ``bigint``: int64,
        ``binary``: byte [],
        ``bit``: bool,
        ``char``: string,
        ``date``: DateTime,
        ``datetime``: DateTime,
        ``datetime2``: DateTime,
        ``datetimeoffset``: DateTimeOffset,
        ``decimal``: decimal,
        ``float``: float,
        ``image``: byte [],
        ``int``: int,
        ``money``: decimal,
        ``nchar``: string,
        ``ntext``: string,
        ``numeric``: decimal,
        ``nvarchar``: string,
        ``real``: float32,
        ``smalldatetime``: DateTime,
        ``smallint``: int16,
        ``smallmoney``: decimal,
        ``text``: string,
        ``time``: TimeSpan,
        ``tinyint``: byte,
        ``uniqueidentifier``: Guid,
        ``varbinary``: byte [],
        ``varchar``: string,
        ``xml``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
          SqlParameter("bigint", SqlDbType.BigInt, Value = ``bigint``)
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
          SqlParameter("bit", SqlDbType.Bit, Value = ``bit``)
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = ``char``)
          SqlParameter("date", SqlDbType.Date, Value = ``date``)
          SqlParameter("datetime", SqlDbType.DateTime, Value = ``datetime``)
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = ``float``)
          SqlParameter("image", SqlDbType.Image, Value = ``image``)
          SqlParameter("int", SqlDbType.Int, Value = ``int``)
          SqlParameter("money", SqlDbType.Money, Value = ``money``)
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
          SqlParameter("ntext", SqlDbType.NText, Value = ``ntext``)
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
          SqlParameter("real", SqlDbType.Real, Value = ``real``)
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
          SqlParameter("smallint", SqlDbType.SmallInt, Value = ``smallint``)
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
          SqlParameter("text", SqlDbType.Text, Value = ``text``)
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = ``time``)
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
          SqlParameter("xml", SqlDbType.Xml, Value = ``xml``)
        |]
      ``AllTypesNonNull_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
          SqlParameter("bigint", SqlDbType.BigInt, Value = (^a: (member ``Bigint``: int64) dto))
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = (^a: (member ``Binary``: byte []) dto))
          SqlParameter("bit", SqlDbType.Bit, Value = (^a: (member ``Bit``: bool) dto))
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = (^a: (member ``Char``: string) dto))
          SqlParameter("date", SqlDbType.Date, Value = (^a: (member ``Date``: DateTime) dto))
          SqlParameter("datetime", SqlDbType.DateTime, Value = (^a: (member ``Datetime``: DateTime) dto))
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = (^a: (member ``Datetime2``: DateTime) dto))
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = (^a: (member ``Datetimeoffset``: DateTimeOffset) dto))
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = (^a: (member ``Decimal``: decimal) dto))
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = (^a: (member ``Float``: float) dto))
          SqlParameter("image", SqlDbType.Image, Value = (^a: (member ``Image``: byte []) dto))
          SqlParameter("int", SqlDbType.Int, Value = (^a: (member ``Int``: int) dto))
          SqlParameter("money", SqlDbType.Money, Value = (^a: (member ``Money``: decimal) dto))
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = (^a: (member ``Nchar``: string) dto))
          SqlParameter("ntext", SqlDbType.NText, Value = (^a: (member ``Ntext``: string) dto))
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = (^a: (member ``Numeric``: decimal) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Nvarchar``: string) dto))
          SqlParameter("real", SqlDbType.Real, Value = (^a: (member ``Real``: float32) dto))
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = (^a: (member ``Smalldatetime``: DateTime) dto))
          SqlParameter("smallint", SqlDbType.SmallInt, Value = (^a: (member ``Smallint``: int16) dto))
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = (^a: (member ``Smallmoney``: decimal) dto))
          SqlParameter("text", SqlDbType.Text, Value = (^a: (member ``Text``: string) dto))
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = (^a: (member ``Time``: TimeSpan) dto))
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = (^a: (member ``Tinyint``: byte) dto))
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Uniqueidentifier``: Guid) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = (^a: (member ``Varbinary``: byte []) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = (^a: (member ``Varchar``: string) dto))
          SqlParameter("xml", SqlDbType.Xml, Value = (^a: (member ``Xml``: string) dto))
        |]
      ``AllTypesNonNull_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``AllTypesNonNull_MergeBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key``: int,
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) : ``args`` =
        [|
          ``key`` |> box
          ``bigint`` |> box
          ``binary`` |> box
          ``bit`` |> box
          ``char`` |> box
          ``date`` |> box
          ``datetime`` |> box
          ``datetime2`` |> box
          ``datetimeoffset`` |> box
          ``decimal`` |> box
          ``float`` |> box
          ``image`` |> box
          ``int`` |> box
          ``money`` |> box
          ``nchar`` |> box
          ``ntext`` |> box
          ``numeric`` |> box
          ``nvarchar`` |> box
          ``real`` |> box
          ``smalldatetime`` |> box
          ``smallint`` |> box
          ``smallmoney`` |> box
          ``text`` |> box
          ``time`` |> box
          ``tinyint`` |> box
          ``uniqueidentifier`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
          ``xml`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key``: int) dto) |> box
          (^a: (member ``bigint``: int64) dto) |> box
          (^a: (member ``binary``: byte []) dto) |> box
          (^a: (member ``bit``: bool) dto) |> box
          (^a: (member ``char``: string) dto) |> box
          (^a: (member ``date``: DateTime) dto) |> box
          (^a: (member ``datetime``: DateTime) dto) |> box
          (^a: (member ``datetime2``: DateTime) dto) |> box
          (^a: (member ``datetimeoffset``: DateTimeOffset) dto) |> box
          (^a: (member ``decimal``: decimal) dto) |> box
          (^a: (member ``float``: float) dto) |> box
          (^a: (member ``image``: byte []) dto) |> box
          (^a: (member ``int``: int) dto) |> box
          (^a: (member ``money``: decimal) dto) |> box
          (^a: (member ``nchar``: string) dto) |> box
          (^a: (member ``ntext``: string) dto) |> box
          (^a: (member ``numeric``: decimal) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``real``: float32) dto) |> box
          (^a: (member ``smalldatetime``: DateTime) dto) |> box
          (^a: (member ``smallint``: int16) dto) |> box
          (^a: (member ``smallmoney``: decimal) dto) |> box
          (^a: (member ``text``: string) dto) |> box
          (^a: (member ``time``: TimeSpan) dto) |> box
          (^a: (member ``tinyint``: byte) dto) |> box
          (^a: (member ``uniqueidentifier``: Guid) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
          (^a: (member ``xml``: string) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNonNull_MergeBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNonNull_MergeBatch
MERGE [dbo].[AllTypesNonNull]
USING
  #args
AS x
ON
  [AllTypesNonNull].[key] = x.[key]

WHEN MATCHED THEN
  UPDATE
  SET
    [bigint] = x.[bigint],
    [binary] = x.[binary],
    [bit] = x.[bit],
    [char] = x.[char],
    [date] = x.[date],
    [datetime] = x.[datetime],
    [datetime2] = x.[datetime2],
    [datetimeoffset] = x.[datetimeoffset],
    [decimal] = x.[decimal],
    [float] = x.[float],
    [image] = x.[image],
    [int] = x.[int],
    [money] = x.[money],
    [nchar] = x.[nchar],
    [ntext] = x.[ntext],
    [numeric] = x.[numeric],
    [nvarchar] = x.[nvarchar],
    [real] = x.[real],
    [smalldatetime] = x.[smalldatetime],
    [smallint] = x.[smallint],
    [smallmoney] = x.[smallmoney],
    [text] = x.[text],
    [time] = x.[time],
    [tinyint] = x.[tinyint],
    [uniqueidentifier] = x.[uniqueidentifier],
    [varbinary] = x.[varbinary],
    [varchar] = x.[varchar],
    [xml] = x.[xml]

WHEN NOT MATCHED THEN
  INSERT
  (
    [key],
    [bigint],
    [binary],
    [bit],
    [char],
    [date],
    [datetime],
    [datetime2],
    [datetimeoffset],
    [decimal],
    [float],
    [image],
    [int],
    [money],
    [nchar],
    [ntext],
    [numeric],
    [nvarchar],
    [real],
    [smalldatetime],
    [smallint],
    [smallmoney],
    [text],
    [time],
    [tinyint],
    [uniqueidentifier],
    [varbinary],
    [varchar],
    [xml]
  )
  VALUES
  (
    x.[key],
    x.[bigint],
    x.[binary],
    x.[bit],
    x.[char],
    x.[date],
    x.[datetime],
    x.[datetime2],
    x.[datetimeoffset],
    x.[decimal],
    x.[float],
    x.[image],
    x.[int],
    x.[money],
    x.[nchar],
    x.[ntext],
    x.[numeric],
    x.[nvarchar],
    x.[real],
    x.[smalldatetime],
    x.[smallint],
    x.[smallmoney],
    x.[text],
    x.[time],
    x.[tinyint],
    x.[uniqueidentifier],
    x.[varbinary],
    x.[varchar],
    x.[xml]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNonNull_MergeBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNonNull_MergeBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNonNull_MergeBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNonNull_MergeBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``AllTypesNonNull_MergeBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key] INT NOT NULL,
              [bigint] BIGINT NOT NULL,
              [binary] BINARY(42) NOT NULL,
              [bit] BIT NOT NULL,
              [char] CHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [date] DATE NOT NULL,
              [datetime] DATETIME NOT NULL,
              [datetime2] DATETIME2(3) NOT NULL,
              [datetimeoffset] DATETIMEOFFSET(1) NOT NULL,
              [decimal] DECIMAL(10, 5) NOT NULL,
              [float] FLOAT(53) NOT NULL,
              [image] IMAGE NOT NULL,
              [int] INT NOT NULL,
              [money] MONEY NOT NULL,
              [nchar] NCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [ntext] NTEXT COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [numeric] NUMERIC(8, 3) NOT NULL,
              [nvarchar] NVARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [real] REAL NOT NULL,
              [smalldatetime] SMALLDATETIME NOT NULL,
              [smallint] SMALLINT NOT NULL,
              [smallmoney] SMALLMONEY NOT NULL,
              [text] TEXT COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [time] TIME(1) NOT NULL,
              [tinyint] TINYINT NOT NULL,
              [uniqueidentifier] UNIQUEIDENTIFIER NOT NULL,
              [varbinary] VARBINARY(42) NOT NULL,
              [varchar] VARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [xml] XML NOT NULL,
              PRIMARY KEY ([key])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            29,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``AllTypesNonNull_MergeBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``AllTypesNonNull_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``AllTypesNonNull_MergeBatch``.``args``>) dto)
        )
      ``AllTypesNonNull_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNonNull_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNonNull_Update
UPDATE
  [dbo].[AllTypesNonNull]
SET
  [bigint] = @bigint,
  [binary] = @binary,
  [bit] = @bit,
  [char] = @char,
  [date] = @date,
  [datetime] = @datetime,
  [datetime2] = @datetime2,
  [datetimeoffset] = @datetimeoffset,
  [decimal] = @decimal,
  [float] = @float,
  [image] = @image,
  [int] = @int,
  [money] = @money,
  [nchar] = @nchar,
  [ntext] = @ntext,
  [numeric] = @numeric,
  [nvarchar] = @nvarchar,
  [real] = @real,
  [smalldatetime] = @smalldatetime,
  [smallint] = @smallint,
  [smallmoney] = @smallmoney,
  [text] = @text,
  [time] = @time,
  [tinyint] = @tinyint,
  [uniqueidentifier] = @uniqueidentifier,
  [varbinary] = @varbinary,
  [varchar] = @varchar,
  [xml] = @xml
WHERE
  [key] = @key"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNonNull_Update`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNonNull_Update``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNonNull_Update``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNonNull_Update``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int,
        ``bigint``: int64,
        ``binary``: byte [],
        ``bit``: bool,
        ``char``: string,
        ``date``: DateTime,
        ``datetime``: DateTime,
        ``datetime2``: DateTime,
        ``datetimeoffset``: DateTimeOffset,
        ``decimal``: decimal,
        ``float``: float,
        ``image``: byte [],
        ``int``: int,
        ``money``: decimal,
        ``nchar``: string,
        ``ntext``: string,
        ``numeric``: decimal,
        ``nvarchar``: string,
        ``real``: float32,
        ``smalldatetime``: DateTime,
        ``smallint``: int16,
        ``smallmoney``: decimal,
        ``text``: string,
        ``time``: TimeSpan,
        ``tinyint``: byte,
        ``uniqueidentifier``: Guid,
        ``varbinary``: byte [],
        ``varchar``: string,
        ``xml``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
          SqlParameter("bigint", SqlDbType.BigInt, Value = ``bigint``)
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
          SqlParameter("bit", SqlDbType.Bit, Value = ``bit``)
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = ``char``)
          SqlParameter("date", SqlDbType.Date, Value = ``date``)
          SqlParameter("datetime", SqlDbType.DateTime, Value = ``datetime``)
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = ``float``)
          SqlParameter("image", SqlDbType.Image, Value = ``image``)
          SqlParameter("int", SqlDbType.Int, Value = ``int``)
          SqlParameter("money", SqlDbType.Money, Value = ``money``)
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
          SqlParameter("ntext", SqlDbType.NText, Value = ``ntext``)
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
          SqlParameter("real", SqlDbType.Real, Value = ``real``)
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
          SqlParameter("smallint", SqlDbType.SmallInt, Value = ``smallint``)
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
          SqlParameter("text", SqlDbType.Text, Value = ``text``)
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = ``time``)
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
          SqlParameter("xml", SqlDbType.Xml, Value = ``xml``)
        |]
      ``AllTypesNonNull_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
          SqlParameter("bigint", SqlDbType.BigInt, Value = (^a: (member ``Bigint``: int64) dto))
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = (^a: (member ``Binary``: byte []) dto))
          SqlParameter("bit", SqlDbType.Bit, Value = (^a: (member ``Bit``: bool) dto))
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = (^a: (member ``Char``: string) dto))
          SqlParameter("date", SqlDbType.Date, Value = (^a: (member ``Date``: DateTime) dto))
          SqlParameter("datetime", SqlDbType.DateTime, Value = (^a: (member ``Datetime``: DateTime) dto))
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = (^a: (member ``Datetime2``: DateTime) dto))
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = (^a: (member ``Datetimeoffset``: DateTimeOffset) dto))
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = (^a: (member ``Decimal``: decimal) dto))
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = (^a: (member ``Float``: float) dto))
          SqlParameter("image", SqlDbType.Image, Value = (^a: (member ``Image``: byte []) dto))
          SqlParameter("int", SqlDbType.Int, Value = (^a: (member ``Int``: int) dto))
          SqlParameter("money", SqlDbType.Money, Value = (^a: (member ``Money``: decimal) dto))
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = (^a: (member ``Nchar``: string) dto))
          SqlParameter("ntext", SqlDbType.NText, Value = (^a: (member ``Ntext``: string) dto))
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = (^a: (member ``Numeric``: decimal) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Nvarchar``: string) dto))
          SqlParameter("real", SqlDbType.Real, Value = (^a: (member ``Real``: float32) dto))
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = (^a: (member ``Smalldatetime``: DateTime) dto))
          SqlParameter("smallint", SqlDbType.SmallInt, Value = (^a: (member ``Smallint``: int16) dto))
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = (^a: (member ``Smallmoney``: decimal) dto))
          SqlParameter("text", SqlDbType.Text, Value = (^a: (member ``Text``: string) dto))
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = (^a: (member ``Time``: TimeSpan) dto))
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = (^a: (member ``Tinyint``: byte) dto))
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Uniqueidentifier``: Guid) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = (^a: (member ``Varbinary``: byte []) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = (^a: (member ``Varchar``: string) dto))
          SqlParameter("xml", SqlDbType.Xml, Value = (^a: (member ``Xml``: string) dto))
        |]
      ``AllTypesNonNull_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``AllTypesNonNull_UpdateBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key``: int,
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) : ``args`` =
        [|
          ``key`` |> box
          ``bigint`` |> box
          ``binary`` |> box
          ``bit`` |> box
          ``char`` |> box
          ``date`` |> box
          ``datetime`` |> box
          ``datetime2`` |> box
          ``datetimeoffset`` |> box
          ``decimal`` |> box
          ``float`` |> box
          ``image`` |> box
          ``int`` |> box
          ``money`` |> box
          ``nchar`` |> box
          ``ntext`` |> box
          ``numeric`` |> box
          ``nvarchar`` |> box
          ``real`` |> box
          ``smalldatetime`` |> box
          ``smallint`` |> box
          ``smallmoney`` |> box
          ``text`` |> box
          ``time`` |> box
          ``tinyint`` |> box
          ``uniqueidentifier`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
          ``xml`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key``: int) dto) |> box
          (^a: (member ``bigint``: int64) dto) |> box
          (^a: (member ``binary``: byte []) dto) |> box
          (^a: (member ``bit``: bool) dto) |> box
          (^a: (member ``char``: string) dto) |> box
          (^a: (member ``date``: DateTime) dto) |> box
          (^a: (member ``datetime``: DateTime) dto) |> box
          (^a: (member ``datetime2``: DateTime) dto) |> box
          (^a: (member ``datetimeoffset``: DateTimeOffset) dto) |> box
          (^a: (member ``decimal``: decimal) dto) |> box
          (^a: (member ``float``: float) dto) |> box
          (^a: (member ``image``: byte []) dto) |> box
          (^a: (member ``int``: int) dto) |> box
          (^a: (member ``money``: decimal) dto) |> box
          (^a: (member ``nchar``: string) dto) |> box
          (^a: (member ``ntext``: string) dto) |> box
          (^a: (member ``numeric``: decimal) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``real``: float32) dto) |> box
          (^a: (member ``smalldatetime``: DateTime) dto) |> box
          (^a: (member ``smallint``: int16) dto) |> box
          (^a: (member ``smallmoney``: decimal) dto) |> box
          (^a: (member ``text``: string) dto) |> box
          (^a: (member ``time``: TimeSpan) dto) |> box
          (^a: (member ``tinyint``: byte) dto) |> box
          (^a: (member ``uniqueidentifier``: Guid) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
          (^a: (member ``xml``: string) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNonNull_UpdateBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNonNull_UpdateBatch
UPDATE
  [dbo].[AllTypesNonNull]
SET
  [bigint] = x.[bigint],
  [binary] = x.[binary],
  [bit] = x.[bit],
  [char] = x.[char],
  [date] = x.[date],
  [datetime] = x.[datetime],
  [datetime2] = x.[datetime2],
  [datetimeoffset] = x.[datetimeoffset],
  [decimal] = x.[decimal],
  [float] = x.[float],
  [image] = x.[image],
  [int] = x.[int],
  [money] = x.[money],
  [nchar] = x.[nchar],
  [ntext] = x.[ntext],
  [numeric] = x.[numeric],
  [nvarchar] = x.[nvarchar],
  [real] = x.[real],
  [smalldatetime] = x.[smalldatetime],
  [smallint] = x.[smallint],
  [smallmoney] = x.[smallmoney],
  [text] = x.[text],
  [time] = x.[time],
  [tinyint] = x.[tinyint],
  [uniqueidentifier] = x.[uniqueidentifier],
  [varbinary] = x.[varbinary],
  [varchar] = x.[varchar],
  [xml] = x.[xml]
FROM
  [dbo].[AllTypesNonNull]
INNER JOIN
  #args AS x
    ON
      [AllTypesNonNull].[key] = x.[key]"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNonNull_UpdateBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNonNull_UpdateBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNonNull_UpdateBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNonNull_UpdateBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``AllTypesNonNull_UpdateBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key] INT NOT NULL,
              [bigint] BIGINT NOT NULL,
              [binary] BINARY(42) NOT NULL,
              [bit] BIT NOT NULL,
              [char] CHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [date] DATE NOT NULL,
              [datetime] DATETIME NOT NULL,
              [datetime2] DATETIME2(3) NOT NULL,
              [datetimeoffset] DATETIMEOFFSET(1) NOT NULL,
              [decimal] DECIMAL(10, 5) NOT NULL,
              [float] FLOAT(53) NOT NULL,
              [image] IMAGE NOT NULL,
              [int] INT NOT NULL,
              [money] MONEY NOT NULL,
              [nchar] NCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [ntext] NTEXT COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [numeric] NUMERIC(8, 3) NOT NULL,
              [nvarchar] NVARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [real] REAL NOT NULL,
              [smalldatetime] SMALLDATETIME NOT NULL,
              [smallint] SMALLINT NOT NULL,
              [smallmoney] SMALLMONEY NOT NULL,
              [text] TEXT COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [time] TIME(1) NOT NULL,
              [tinyint] TINYINT NOT NULL,
              [uniqueidentifier] UNIQUEIDENTIFIER NOT NULL,
              [varbinary] VARBINARY(42) NOT NULL,
              [varchar] VARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [xml] XML NOT NULL,
              PRIMARY KEY ([key])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            29,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``AllTypesNonNull_UpdateBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``AllTypesNonNull_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``AllTypesNonNull_UpdateBatch``.``args``>) dto)
        )
      ``AllTypesNonNull_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  type ``AllTypesNull_All`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNull_All
SELECT
  [key1],
  [key2],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
FROM
  [dbo].[AllTypesNull]"""
      userConfigureCmd cmd

    let mutable ``ordinal_key1`` = 0
    let mutable ``ordinal_key2`` = 0
    let mutable ``ordinal_bigint`` = 0
    let mutable ``ordinal_binary`` = 0
    let mutable ``ordinal_bit`` = 0
    let mutable ``ordinal_char`` = 0
    let mutable ``ordinal_date`` = 0
    let mutable ``ordinal_datetime`` = 0
    let mutable ``ordinal_datetime2`` = 0
    let mutable ``ordinal_datetimeoffset`` = 0
    let mutable ``ordinal_decimal`` = 0
    let mutable ``ordinal_float`` = 0
    let mutable ``ordinal_image`` = 0
    let mutable ``ordinal_int`` = 0
    let mutable ``ordinal_money`` = 0
    let mutable ``ordinal_nchar`` = 0
    let mutable ``ordinal_ntext`` = 0
    let mutable ``ordinal_numeric`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_real`` = 0
    let mutable ``ordinal_smalldatetime`` = 0
    let mutable ``ordinal_smallint`` = 0
    let mutable ``ordinal_smallmoney`` = 0
    let mutable ``ordinal_text`` = 0
    let mutable ``ordinal_time`` = 0
    let mutable ``ordinal_tinyint`` = 0
    let mutable ``ordinal_uniqueidentifier`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0
    let mutable ``ordinal_xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_key1`` <- reader.GetOrdinal "key1"
      ``ordinal_key2`` <- reader.GetOrdinal "key2"
      ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
      ``ordinal_binary`` <- reader.GetOrdinal "binary"
      ``ordinal_bit`` <- reader.GetOrdinal "bit"
      ``ordinal_char`` <- reader.GetOrdinal "char"
      ``ordinal_date`` <- reader.GetOrdinal "date"
      ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
      ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
      ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
      ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
      ``ordinal_float`` <- reader.GetOrdinal "float"
      ``ordinal_image`` <- reader.GetOrdinal "image"
      ``ordinal_int`` <- reader.GetOrdinal "int"
      ``ordinal_money`` <- reader.GetOrdinal "money"
      ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
      ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
      ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_real`` <- reader.GetOrdinal "real"
      ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
      ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
      ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
      ``ordinal_text`` <- reader.GetOrdinal "text"
      ``ordinal_time`` <- reader.GetOrdinal "time"
      ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
      ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
      ``ordinal_xml`` <- reader.GetOrdinal "xml"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``AllTypesNull`` =
      let ``key1`` = reader.GetInt32 ``ordinal_key1``
      let ``key2`` = reader.GetInt32 ``ordinal_key2``
      let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
      let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
      let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
      let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
      let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
      let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
      let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
      let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
      let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
      let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
      let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
      let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
      let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
      let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
      let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
      let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
      let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
      let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
      let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
      let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
      let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
      let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
      let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
      let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
      let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
      let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
      let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
      let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
      {
        ``Key1`` = ``key1``
        ``Key2`` = ``key2``
        ``Bigint`` = ``bigint``
        ``Binary`` = ``binary``
        ``Bit`` = ``bit``
        ``Char`` = ``char``
        ``Date`` = ``date``
        ``Datetime`` = ``datetime``
        ``Datetime2`` = ``datetime2``
        ``Datetimeoffset`` = ``datetimeoffset``
        ``Decimal`` = ``decimal``
        ``Float`` = ``float``
        ``Image`` = ``image``
        ``Int`` = ``int``
        ``Money`` = ``money``
        ``Nchar`` = ``nchar``
        ``Ntext`` = ``ntext``
        ``Numeric`` = ``numeric``
        ``Nvarchar`` = ``nvarchar``
        ``Real`` = ``real``
        ``Smalldatetime`` = ``smalldatetime``
        ``Smallint`` = ``smallint``
        ``Smallmoney`` = ``smallmoney``
        ``Text`` = ``text``
        ``Time`` = ``time``
        ``Tinyint`` = ``tinyint``
        ``Uniqueidentifier`` = ``uniqueidentifier``
        ``Varbinary`` = ``varbinary``
        ``Varchar`` = ``varchar``
        ``Xml`` = ``xml``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNull_All``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNull_All``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNull_All``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNull_ById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNull_ById
SELECT
  [key1],
  [key2],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
FROM
  [dbo].[AllTypesNull]
WHERE
  [key1] = @key1
  AND [key2] = @key2"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_key1`` = 0
    let mutable ``ordinal_key2`` = 0
    let mutable ``ordinal_bigint`` = 0
    let mutable ``ordinal_binary`` = 0
    let mutable ``ordinal_bit`` = 0
    let mutable ``ordinal_char`` = 0
    let mutable ``ordinal_date`` = 0
    let mutable ``ordinal_datetime`` = 0
    let mutable ``ordinal_datetime2`` = 0
    let mutable ``ordinal_datetimeoffset`` = 0
    let mutable ``ordinal_decimal`` = 0
    let mutable ``ordinal_float`` = 0
    let mutable ``ordinal_image`` = 0
    let mutable ``ordinal_int`` = 0
    let mutable ``ordinal_money`` = 0
    let mutable ``ordinal_nchar`` = 0
    let mutable ``ordinal_ntext`` = 0
    let mutable ``ordinal_numeric`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_real`` = 0
    let mutable ``ordinal_smalldatetime`` = 0
    let mutable ``ordinal_smallint`` = 0
    let mutable ``ordinal_smallmoney`` = 0
    let mutable ``ordinal_text`` = 0
    let mutable ``ordinal_time`` = 0
    let mutable ``ordinal_tinyint`` = 0
    let mutable ``ordinal_uniqueidentifier`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0
    let mutable ``ordinal_xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_key1`` <- reader.GetOrdinal "key1"
      ``ordinal_key2`` <- reader.GetOrdinal "key2"
      ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
      ``ordinal_binary`` <- reader.GetOrdinal "binary"
      ``ordinal_bit`` <- reader.GetOrdinal "bit"
      ``ordinal_char`` <- reader.GetOrdinal "char"
      ``ordinal_date`` <- reader.GetOrdinal "date"
      ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
      ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
      ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
      ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
      ``ordinal_float`` <- reader.GetOrdinal "float"
      ``ordinal_image`` <- reader.GetOrdinal "image"
      ``ordinal_int`` <- reader.GetOrdinal "int"
      ``ordinal_money`` <- reader.GetOrdinal "money"
      ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
      ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
      ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_real`` <- reader.GetOrdinal "real"
      ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
      ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
      ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
      ``ordinal_text`` <- reader.GetOrdinal "text"
      ``ordinal_time`` <- reader.GetOrdinal "time"
      ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
      ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
      ``ordinal_xml`` <- reader.GetOrdinal "xml"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``AllTypesNull`` =
      let ``key1`` = reader.GetInt32 ``ordinal_key1``
      let ``key2`` = reader.GetInt32 ``ordinal_key2``
      let ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
      let ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
      let ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
      let ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
      let ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
      let ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
      let ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
      let ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
      let ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
      let ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
      let ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
      let ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
      let ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
      let ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
      let ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
      let ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
      let ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
      let ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
      let ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
      let ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
      let ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
      let ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
      let ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
      let ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
      let ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
      let ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
      let ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
      let ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
      {
        ``Key1`` = ``key1``
        ``Key2`` = ``key2``
        ``Bigint`` = ``bigint``
        ``Binary`` = ``binary``
        ``Bit`` = ``bit``
        ``Char`` = ``char``
        ``Date`` = ``date``
        ``Datetime`` = ``datetime``
        ``Datetime2`` = ``datetime2``
        ``Datetimeoffset`` = ``datetimeoffset``
        ``Decimal`` = ``decimal``
        ``Float`` = ``float``
        ``Image`` = ``image``
        ``Int`` = ``int``
        ``Money`` = ``money``
        ``Nchar`` = ``nchar``
        ``Ntext`` = ``ntext``
        ``Numeric`` = ``numeric``
        ``Nvarchar`` = ``nvarchar``
        ``Real`` = ``real``
        ``Smalldatetime`` = ``smalldatetime``
        ``Smallint`` = ``smallint``
        ``Smallmoney`` = ``smallmoney``
        ``Text`` = ``text``
        ``Time`` = ``time``
        ``Tinyint`` = ``tinyint``
        ``Uniqueidentifier`` = ``uniqueidentifier``
        ``Varbinary`` = ``varbinary``
        ``Varchar`` = ``varchar``
        ``Xml`` = ``xml``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``AllTypesNull_ById`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNull_ById``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNull_ById``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNull_ById``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key1``: int,
        ``key2``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = ``key1``)
          SqlParameter("key2", SqlDbType.Int, Value = ``key2``)
        |]
      ``AllTypesNull_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = (^a: (member ``Key1``: int) dto))
          SqlParameter("key2", SqlDbType.Int, Value = (^a: (member ``Key2``: int) dto))
        |]
      ``AllTypesNull_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNull_Delete_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNull_Delete
DELETE FROM [dbo].[AllTypesNull]
WHERE
  [key1] = @key1
  AND [key2] = @key2"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNull_Delete`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNull_Delete``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNull_Delete``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNull_Delete``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key1``: int,
        ``key2``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = ``key1``)
          SqlParameter("key2", SqlDbType.Int, Value = ``key2``)
        |]
      ``AllTypesNull_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = (^a: (member ``Key1``: int) dto))
          SqlParameter("key2", SqlDbType.Int, Value = (^a: (member ``Key2``: int) dto))
        |]
      ``AllTypesNull_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNull_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNull_Insert
INSERT INTO [dbo].[AllTypesNull]
(
  [key1],
  [key2],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
)
VALUES
(
  @key1,
  @key2,
  @bigint,
  @binary,
  @bit,
  @char,
  @date,
  @datetime,
  @datetime2,
  @datetimeoffset,
  @decimal,
  @float,
  @image,
  @int,
  @money,
  @nchar,
  @ntext,
  @numeric,
  @nvarchar,
  @real,
  @smalldatetime,
  @smallint,
  @smallmoney,
  @text,
  @time,
  @tinyint,
  @uniqueidentifier,
  @varbinary,
  @varchar,
  @xml
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNull_Insert`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNull_Insert``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNull_Insert``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNull_Insert``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key1``: int,
        ``key2``: int,
        ``bigint``: int64 option,
        ``binary``: byte [] option,
        ``bit``: bool option,
        ``char``: string option,
        ``date``: DateTime option,
        ``datetime``: DateTime option,
        ``datetime2``: DateTime option,
        ``datetimeoffset``: DateTimeOffset option,
        ``decimal``: decimal option,
        ``float``: float option,
        ``image``: byte [] option,
        ``int``: int option,
        ``money``: decimal option,
        ``nchar``: string option,
        ``ntext``: string option,
        ``numeric``: decimal option,
        ``nvarchar``: string option,
        ``real``: float32 option,
        ``smalldatetime``: DateTime option,
        ``smallint``: int16 option,
        ``smallmoney``: decimal option,
        ``text``: string option,
        ``time``: TimeSpan option,
        ``tinyint``: byte option,
        ``uniqueidentifier``: Guid option,
        ``varbinary``: byte [] option,
        ``varchar``: string option,
        ``xml``: string option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = ``key1``)
          SqlParameter("key2", SqlDbType.Int, Value = ``key2``)
          SqlParameter("bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
          SqlParameter("bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
          SqlParameter("date", SqlDbType.Date, Value = Option.toDbNull ``date``)
          SqlParameter("datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
          SqlParameter("image", SqlDbType.Image, Value = Option.toDbNull ``image``)
          SqlParameter("int", SqlDbType.Int, Value = Option.toDbNull ``int``)
          SqlParameter("money", SqlDbType.Money, Value = Option.toDbNull ``money``)
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
          SqlParameter("ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
          SqlParameter("real", SqlDbType.Real, Value = Option.toDbNull ``real``)
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
          SqlParameter("smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
          SqlParameter("text", SqlDbType.Text, Value = Option.toDbNull ``text``)
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
          SqlParameter("xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
        |]
      ``AllTypesNull_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = (^a: (member ``Key1``: int) dto))
          SqlParameter("key2", SqlDbType.Int, Value = (^a: (member ``Key2``: int) dto))
          SqlParameter("bigint", SqlDbType.BigInt, Value = Option.toDbNull (^a: (member ``Bigint``: int64 option) dto))
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull (^a: (member ``Binary``: byte [] option) dto))
          SqlParameter("bit", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Bit``: bool option) dto))
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = Option.toDbNull (^a: (member ``Char``: string option) dto))
          SqlParameter("date", SqlDbType.Date, Value = Option.toDbNull (^a: (member ``Date``: DateTime option) dto))
          SqlParameter("datetime", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto))
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto))
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto))
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull (^a: (member ``Decimal``: decimal option) dto))
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = Option.toDbNull (^a: (member ``Float``: float option) dto))
          SqlParameter("image", SqlDbType.Image, Value = Option.toDbNull (^a: (member ``Image``: byte [] option) dto))
          SqlParameter("int", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Int``: int option) dto))
          SqlParameter("money", SqlDbType.Money, Value = Option.toDbNull (^a: (member ``Money``: decimal option) dto))
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nchar``: string option) dto))
          SqlParameter("ntext", SqlDbType.NText, Value = Option.toDbNull (^a: (member ``Ntext``: string option) dto))
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull (^a: (member ``Numeric``: decimal option) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nvarchar``: string option) dto))
          SqlParameter("real", SqlDbType.Real, Value = Option.toDbNull (^a: (member ``Real``: float32 option) dto))
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto))
          SqlParameter("smallint", SqlDbType.SmallInt, Value = Option.toDbNull (^a: (member ``Smallint``: int16 option) dto))
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto))
          SqlParameter("text", SqlDbType.Text, Value = Option.toDbNull (^a: (member ``Text``: string option) dto))
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto))
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = Option.toDbNull (^a: (member ``Tinyint``: byte option) dto))
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Varchar``: string option) dto))
          SqlParameter("xml", SqlDbType.Xml, Value = Option.toDbNull (^a: (member ``Xml``: string option) dto))
        |]
      ``AllTypesNull_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``AllTypesNull_InsertBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key1``: int,
          ``key2``: int,
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) : ``args`` =
        [|
          ``key1`` |> box
          ``key2`` |> box
          Option.toDbNull ``bigint`` |> box
          Option.toDbNull ``binary`` |> box
          Option.toDbNull ``bit`` |> box
          Option.toDbNull ``char`` |> box
          Option.toDbNull ``date`` |> box
          Option.toDbNull ``datetime`` |> box
          Option.toDbNull ``datetime2`` |> box
          Option.toDbNull ``datetimeoffset`` |> box
          Option.toDbNull ``decimal`` |> box
          Option.toDbNull ``float`` |> box
          Option.toDbNull ``image`` |> box
          Option.toDbNull ``int`` |> box
          Option.toDbNull ``money`` |> box
          Option.toDbNull ``nchar`` |> box
          Option.toDbNull ``ntext`` |> box
          Option.toDbNull ``numeric`` |> box
          Option.toDbNull ``nvarchar`` |> box
          Option.toDbNull ``real`` |> box
          Option.toDbNull ``smalldatetime`` |> box
          Option.toDbNull ``smallint`` |> box
          Option.toDbNull ``smallmoney`` |> box
          Option.toDbNull ``text`` |> box
          Option.toDbNull ``time`` |> box
          Option.toDbNull ``tinyint`` |> box
          Option.toDbNull ``uniqueidentifier`` |> box
          Option.toDbNull ``varbinary`` |> box
          Option.toDbNull ``varchar`` |> box
          Option.toDbNull ``xml`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key1``: int) dto) |> box
          (^a: (member ``key2``: int) dto) |> box
          Option.toDbNull (^a: (member ``bigint``: int64 option) dto) |> box
          Option.toDbNull (^a: (member ``binary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``bit``: bool option) dto) |> box
          Option.toDbNull (^a: (member ``char``: string option) dto) |> box
          Option.toDbNull (^a: (member ``date``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``datetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``datetime2``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``datetimeoffset``: DateTimeOffset option) dto) |> box
          Option.toDbNull (^a: (member ``decimal``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``float``: float option) dto) |> box
          Option.toDbNull (^a: (member ``image``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``int``: int option) dto) |> box
          Option.toDbNull (^a: (member ``money``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``nchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``ntext``: string option) dto) |> box
          Option.toDbNull (^a: (member ``numeric``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``nvarchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``real``: float32 option) dto) |> box
          Option.toDbNull (^a: (member ``smalldatetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``smallint``: int16 option) dto) |> box
          Option.toDbNull (^a: (member ``smallmoney``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``text``: string option) dto) |> box
          Option.toDbNull (^a: (member ``time``: TimeSpan option) dto) |> box
          Option.toDbNull (^a: (member ``tinyint``: byte option) dto) |> box
          Option.toDbNull (^a: (member ``uniqueidentifier``: Guid option) dto) |> box
          Option.toDbNull (^a: (member ``varbinary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``varchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``xml``: string option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNull_InsertBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNull_InsertBatch
INSERT INTO [dbo].[AllTypesNull]
(
  [key1],
  [key2],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
)
SELECT
  [key1],
  [key2],
  [bigint],
  [binary],
  [bit],
  [char],
  [date],
  [datetime],
  [datetime2],
  [datetimeoffset],
  [decimal],
  [float],
  [image],
  [int],
  [money],
  [nchar],
  [ntext],
  [numeric],
  [nvarchar],
  [real],
  [smalldatetime],
  [smallint],
  [smallmoney],
  [text],
  [time],
  [tinyint],
  [uniqueidentifier],
  [varbinary],
  [varchar],
  [xml]
FROM #args"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNull_InsertBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNull_InsertBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNull_InsertBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNull_InsertBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``AllTypesNull_InsertBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key1] INT NOT NULL,
              [key2] INT NOT NULL,
              [bigint] BIGINT NULL,
              [binary] BINARY(42) NULL,
              [bit] BIT NULL,
              [char] CHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [date] DATE NULL,
              [datetime] DATETIME NULL,
              [datetime2] DATETIME2(3) NULL,
              [datetimeoffset] DATETIMEOFFSET(1) NULL,
              [decimal] DECIMAL(10, 5) NULL,
              [float] FLOAT(53) NULL,
              [image] IMAGE NULL,
              [int] INT NULL,
              [money] MONEY NULL,
              [nchar] NCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [ntext] NTEXT COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [numeric] NUMERIC(8, 3) NULL,
              [nvarchar] NVARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [real] REAL NULL,
              [smalldatetime] SMALLDATETIME NULL,
              [smallint] SMALLINT NULL,
              [smallmoney] SMALLMONEY NULL,
              [text] TEXT COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [time] TIME(1) NULL,
              [tinyint] TINYINT NULL,
              [uniqueidentifier] UNIQUEIDENTIFIER NULL,
              [varbinary] VARBINARY(42) NULL,
              [varchar] VARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [xml] XML NULL
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            30,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``AllTypesNull_InsertBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``AllTypesNull_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``AllTypesNull_InsertBatch``.``args``>) dto)
        )
      ``AllTypesNull_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNull_Merge_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNull_Merge
MERGE [dbo].[AllTypesNull]
USING
(
  SELECT
    [key1] = @key1,
    [key2] = @key2,
    [bigint] = @bigint,
    [binary] = @binary,
    [bit] = @bit,
    [char] = @char,
    [date] = @date,
    [datetime] = @datetime,
    [datetime2] = @datetime2,
    [datetimeoffset] = @datetimeoffset,
    [decimal] = @decimal,
    [float] = @float,
    [image] = @image,
    [int] = @int,
    [money] = @money,
    [nchar] = @nchar,
    [ntext] = @ntext,
    [numeric] = @numeric,
    [nvarchar] = @nvarchar,
    [real] = @real,
    [smalldatetime] = @smalldatetime,
    [smallint] = @smallint,
    [smallmoney] = @smallmoney,
    [text] = @text,
    [time] = @time,
    [tinyint] = @tinyint,
    [uniqueidentifier] = @uniqueidentifier,
    [varbinary] = @varbinary,
    [varchar] = @varchar,
    [xml] = @xml
)
AS x
ON
  [AllTypesNull].[key1] = x.[key1]
  AND [AllTypesNull].[key2] = x.[key2]

WHEN MATCHED THEN
  UPDATE
  SET
    [bigint] = x.[bigint],
    [binary] = x.[binary],
    [bit] = x.[bit],
    [char] = x.[char],
    [date] = x.[date],
    [datetime] = x.[datetime],
    [datetime2] = x.[datetime2],
    [datetimeoffset] = x.[datetimeoffset],
    [decimal] = x.[decimal],
    [float] = x.[float],
    [image] = x.[image],
    [int] = x.[int],
    [money] = x.[money],
    [nchar] = x.[nchar],
    [ntext] = x.[ntext],
    [numeric] = x.[numeric],
    [nvarchar] = x.[nvarchar],
    [real] = x.[real],
    [smalldatetime] = x.[smalldatetime],
    [smallint] = x.[smallint],
    [smallmoney] = x.[smallmoney],
    [text] = x.[text],
    [time] = x.[time],
    [tinyint] = x.[tinyint],
    [uniqueidentifier] = x.[uniqueidentifier],
    [varbinary] = x.[varbinary],
    [varchar] = x.[varchar],
    [xml] = x.[xml]

WHEN NOT MATCHED THEN
  INSERT
  (
    [key1],
    [key2],
    [bigint],
    [binary],
    [bit],
    [char],
    [date],
    [datetime],
    [datetime2],
    [datetimeoffset],
    [decimal],
    [float],
    [image],
    [int],
    [money],
    [nchar],
    [ntext],
    [numeric],
    [nvarchar],
    [real],
    [smalldatetime],
    [smallint],
    [smallmoney],
    [text],
    [time],
    [tinyint],
    [uniqueidentifier],
    [varbinary],
    [varchar],
    [xml]
  )
  VALUES
  (
    x.[key1],
    x.[key2],
    x.[bigint],
    x.[binary],
    x.[bit],
    x.[char],
    x.[date],
    x.[datetime],
    x.[datetime2],
    x.[datetimeoffset],
    x.[decimal],
    x.[float],
    x.[image],
    x.[int],
    x.[money],
    x.[nchar],
    x.[ntext],
    x.[numeric],
    x.[nvarchar],
    x.[real],
    x.[smalldatetime],
    x.[smallint],
    x.[smallmoney],
    x.[text],
    x.[time],
    x.[tinyint],
    x.[uniqueidentifier],
    x.[varbinary],
    x.[varchar],
    x.[xml]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNull_Merge`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNull_Merge``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNull_Merge``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNull_Merge``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key1``: int,
        ``key2``: int,
        ``bigint``: int64 option,
        ``binary``: byte [] option,
        ``bit``: bool option,
        ``char``: string option,
        ``date``: DateTime option,
        ``datetime``: DateTime option,
        ``datetime2``: DateTime option,
        ``datetimeoffset``: DateTimeOffset option,
        ``decimal``: decimal option,
        ``float``: float option,
        ``image``: byte [] option,
        ``int``: int option,
        ``money``: decimal option,
        ``nchar``: string option,
        ``ntext``: string option,
        ``numeric``: decimal option,
        ``nvarchar``: string option,
        ``real``: float32 option,
        ``smalldatetime``: DateTime option,
        ``smallint``: int16 option,
        ``smallmoney``: decimal option,
        ``text``: string option,
        ``time``: TimeSpan option,
        ``tinyint``: byte option,
        ``uniqueidentifier``: Guid option,
        ``varbinary``: byte [] option,
        ``varchar``: string option,
        ``xml``: string option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = ``key1``)
          SqlParameter("key2", SqlDbType.Int, Value = ``key2``)
          SqlParameter("bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
          SqlParameter("bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
          SqlParameter("date", SqlDbType.Date, Value = Option.toDbNull ``date``)
          SqlParameter("datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
          SqlParameter("image", SqlDbType.Image, Value = Option.toDbNull ``image``)
          SqlParameter("int", SqlDbType.Int, Value = Option.toDbNull ``int``)
          SqlParameter("money", SqlDbType.Money, Value = Option.toDbNull ``money``)
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
          SqlParameter("ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
          SqlParameter("real", SqlDbType.Real, Value = Option.toDbNull ``real``)
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
          SqlParameter("smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
          SqlParameter("text", SqlDbType.Text, Value = Option.toDbNull ``text``)
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
          SqlParameter("xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
        |]
      ``AllTypesNull_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = (^a: (member ``Key1``: int) dto))
          SqlParameter("key2", SqlDbType.Int, Value = (^a: (member ``Key2``: int) dto))
          SqlParameter("bigint", SqlDbType.BigInt, Value = Option.toDbNull (^a: (member ``Bigint``: int64 option) dto))
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull (^a: (member ``Binary``: byte [] option) dto))
          SqlParameter("bit", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Bit``: bool option) dto))
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = Option.toDbNull (^a: (member ``Char``: string option) dto))
          SqlParameter("date", SqlDbType.Date, Value = Option.toDbNull (^a: (member ``Date``: DateTime option) dto))
          SqlParameter("datetime", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto))
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto))
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto))
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull (^a: (member ``Decimal``: decimal option) dto))
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = Option.toDbNull (^a: (member ``Float``: float option) dto))
          SqlParameter("image", SqlDbType.Image, Value = Option.toDbNull (^a: (member ``Image``: byte [] option) dto))
          SqlParameter("int", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Int``: int option) dto))
          SqlParameter("money", SqlDbType.Money, Value = Option.toDbNull (^a: (member ``Money``: decimal option) dto))
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nchar``: string option) dto))
          SqlParameter("ntext", SqlDbType.NText, Value = Option.toDbNull (^a: (member ``Ntext``: string option) dto))
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull (^a: (member ``Numeric``: decimal option) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nvarchar``: string option) dto))
          SqlParameter("real", SqlDbType.Real, Value = Option.toDbNull (^a: (member ``Real``: float32 option) dto))
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto))
          SqlParameter("smallint", SqlDbType.SmallInt, Value = Option.toDbNull (^a: (member ``Smallint``: int16 option) dto))
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto))
          SqlParameter("text", SqlDbType.Text, Value = Option.toDbNull (^a: (member ``Text``: string option) dto))
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto))
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = Option.toDbNull (^a: (member ``Tinyint``: byte option) dto))
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Varchar``: string option) dto))
          SqlParameter("xml", SqlDbType.Xml, Value = Option.toDbNull (^a: (member ``Xml``: string option) dto))
        |]
      ``AllTypesNull_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``AllTypesNull_MergeBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key1``: int,
          ``key2``: int,
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) : ``args`` =
        [|
          ``key1`` |> box
          ``key2`` |> box
          Option.toDbNull ``bigint`` |> box
          Option.toDbNull ``binary`` |> box
          Option.toDbNull ``bit`` |> box
          Option.toDbNull ``char`` |> box
          Option.toDbNull ``date`` |> box
          Option.toDbNull ``datetime`` |> box
          Option.toDbNull ``datetime2`` |> box
          Option.toDbNull ``datetimeoffset`` |> box
          Option.toDbNull ``decimal`` |> box
          Option.toDbNull ``float`` |> box
          Option.toDbNull ``image`` |> box
          Option.toDbNull ``int`` |> box
          Option.toDbNull ``money`` |> box
          Option.toDbNull ``nchar`` |> box
          Option.toDbNull ``ntext`` |> box
          Option.toDbNull ``numeric`` |> box
          Option.toDbNull ``nvarchar`` |> box
          Option.toDbNull ``real`` |> box
          Option.toDbNull ``smalldatetime`` |> box
          Option.toDbNull ``smallint`` |> box
          Option.toDbNull ``smallmoney`` |> box
          Option.toDbNull ``text`` |> box
          Option.toDbNull ``time`` |> box
          Option.toDbNull ``tinyint`` |> box
          Option.toDbNull ``uniqueidentifier`` |> box
          Option.toDbNull ``varbinary`` |> box
          Option.toDbNull ``varchar`` |> box
          Option.toDbNull ``xml`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key1``: int) dto) |> box
          (^a: (member ``key2``: int) dto) |> box
          Option.toDbNull (^a: (member ``bigint``: int64 option) dto) |> box
          Option.toDbNull (^a: (member ``binary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``bit``: bool option) dto) |> box
          Option.toDbNull (^a: (member ``char``: string option) dto) |> box
          Option.toDbNull (^a: (member ``date``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``datetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``datetime2``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``datetimeoffset``: DateTimeOffset option) dto) |> box
          Option.toDbNull (^a: (member ``decimal``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``float``: float option) dto) |> box
          Option.toDbNull (^a: (member ``image``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``int``: int option) dto) |> box
          Option.toDbNull (^a: (member ``money``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``nchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``ntext``: string option) dto) |> box
          Option.toDbNull (^a: (member ``numeric``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``nvarchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``real``: float32 option) dto) |> box
          Option.toDbNull (^a: (member ``smalldatetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``smallint``: int16 option) dto) |> box
          Option.toDbNull (^a: (member ``smallmoney``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``text``: string option) dto) |> box
          Option.toDbNull (^a: (member ``time``: TimeSpan option) dto) |> box
          Option.toDbNull (^a: (member ``tinyint``: byte option) dto) |> box
          Option.toDbNull (^a: (member ``uniqueidentifier``: Guid option) dto) |> box
          Option.toDbNull (^a: (member ``varbinary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``varchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``xml``: string option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNull_MergeBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNull_MergeBatch
MERGE [dbo].[AllTypesNull]
USING
  #args
AS x
ON
  [AllTypesNull].[key1] = x.[key1]
  AND [AllTypesNull].[key2] = x.[key2]

WHEN MATCHED THEN
  UPDATE
  SET
    [bigint] = x.[bigint],
    [binary] = x.[binary],
    [bit] = x.[bit],
    [char] = x.[char],
    [date] = x.[date],
    [datetime] = x.[datetime],
    [datetime2] = x.[datetime2],
    [datetimeoffset] = x.[datetimeoffset],
    [decimal] = x.[decimal],
    [float] = x.[float],
    [image] = x.[image],
    [int] = x.[int],
    [money] = x.[money],
    [nchar] = x.[nchar],
    [ntext] = x.[ntext],
    [numeric] = x.[numeric],
    [nvarchar] = x.[nvarchar],
    [real] = x.[real],
    [smalldatetime] = x.[smalldatetime],
    [smallint] = x.[smallint],
    [smallmoney] = x.[smallmoney],
    [text] = x.[text],
    [time] = x.[time],
    [tinyint] = x.[tinyint],
    [uniqueidentifier] = x.[uniqueidentifier],
    [varbinary] = x.[varbinary],
    [varchar] = x.[varchar],
    [xml] = x.[xml]

WHEN NOT MATCHED THEN
  INSERT
  (
    [key1],
    [key2],
    [bigint],
    [binary],
    [bit],
    [char],
    [date],
    [datetime],
    [datetime2],
    [datetimeoffset],
    [decimal],
    [float],
    [image],
    [int],
    [money],
    [nchar],
    [ntext],
    [numeric],
    [nvarchar],
    [real],
    [smalldatetime],
    [smallint],
    [smallmoney],
    [text],
    [time],
    [tinyint],
    [uniqueidentifier],
    [varbinary],
    [varchar],
    [xml]
  )
  VALUES
  (
    x.[key1],
    x.[key2],
    x.[bigint],
    x.[binary],
    x.[bit],
    x.[char],
    x.[date],
    x.[datetime],
    x.[datetime2],
    x.[datetimeoffset],
    x.[decimal],
    x.[float],
    x.[image],
    x.[int],
    x.[money],
    x.[nchar],
    x.[ntext],
    x.[numeric],
    x.[nvarchar],
    x.[real],
    x.[smalldatetime],
    x.[smallint],
    x.[smallmoney],
    x.[text],
    x.[time],
    x.[tinyint],
    x.[uniqueidentifier],
    x.[varbinary],
    x.[varchar],
    x.[xml]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNull_MergeBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNull_MergeBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNull_MergeBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNull_MergeBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``AllTypesNull_MergeBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key1] INT NOT NULL,
              [key2] INT NOT NULL,
              [bigint] BIGINT NULL,
              [binary] BINARY(42) NULL,
              [bit] BIT NULL,
              [char] CHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [date] DATE NULL,
              [datetime] DATETIME NULL,
              [datetime2] DATETIME2(3) NULL,
              [datetimeoffset] DATETIMEOFFSET(1) NULL,
              [decimal] DECIMAL(10, 5) NULL,
              [float] FLOAT(53) NULL,
              [image] IMAGE NULL,
              [int] INT NULL,
              [money] MONEY NULL,
              [nchar] NCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [ntext] NTEXT COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [numeric] NUMERIC(8, 3) NULL,
              [nvarchar] NVARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [real] REAL NULL,
              [smalldatetime] SMALLDATETIME NULL,
              [smallint] SMALLINT NULL,
              [smallmoney] SMALLMONEY NULL,
              [text] TEXT COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [time] TIME(1) NULL,
              [tinyint] TINYINT NULL,
              [uniqueidentifier] UNIQUEIDENTIFIER NULL,
              [varbinary] VARBINARY(42) NULL,
              [varchar] VARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [xml] XML NULL,
              PRIMARY KEY ([key1], [key2])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            30,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``AllTypesNull_MergeBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``AllTypesNull_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``AllTypesNull_MergeBatch``.``args``>) dto)
        )
      ``AllTypesNull_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNull_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNull_Update
UPDATE
  [dbo].[AllTypesNull]
SET
  [bigint] = @bigint,
  [binary] = @binary,
  [bit] = @bit,
  [char] = @char,
  [date] = @date,
  [datetime] = @datetime,
  [datetime2] = @datetime2,
  [datetimeoffset] = @datetimeoffset,
  [decimal] = @decimal,
  [float] = @float,
  [image] = @image,
  [int] = @int,
  [money] = @money,
  [nchar] = @nchar,
  [ntext] = @ntext,
  [numeric] = @numeric,
  [nvarchar] = @nvarchar,
  [real] = @real,
  [smalldatetime] = @smalldatetime,
  [smallint] = @smallint,
  [smallmoney] = @smallmoney,
  [text] = @text,
  [time] = @time,
  [tinyint] = @tinyint,
  [uniqueidentifier] = @uniqueidentifier,
  [varbinary] = @varbinary,
  [varchar] = @varchar,
  [xml] = @xml
WHERE
  [key1] = @key1
  AND [key2] = @key2"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNull_Update`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNull_Update``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNull_Update``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNull_Update``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key1``: int,
        ``key2``: int,
        ``bigint``: int64 option,
        ``binary``: byte [] option,
        ``bit``: bool option,
        ``char``: string option,
        ``date``: DateTime option,
        ``datetime``: DateTime option,
        ``datetime2``: DateTime option,
        ``datetimeoffset``: DateTimeOffset option,
        ``decimal``: decimal option,
        ``float``: float option,
        ``image``: byte [] option,
        ``int``: int option,
        ``money``: decimal option,
        ``nchar``: string option,
        ``ntext``: string option,
        ``numeric``: decimal option,
        ``nvarchar``: string option,
        ``real``: float32 option,
        ``smalldatetime``: DateTime option,
        ``smallint``: int16 option,
        ``smallmoney``: decimal option,
        ``text``: string option,
        ``time``: TimeSpan option,
        ``tinyint``: byte option,
        ``uniqueidentifier``: Guid option,
        ``varbinary``: byte [] option,
        ``varchar``: string option,
        ``xml``: string option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = ``key1``)
          SqlParameter("key2", SqlDbType.Int, Value = ``key2``)
          SqlParameter("bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
          SqlParameter("bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
          SqlParameter("date", SqlDbType.Date, Value = Option.toDbNull ``date``)
          SqlParameter("datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
          SqlParameter("image", SqlDbType.Image, Value = Option.toDbNull ``image``)
          SqlParameter("int", SqlDbType.Int, Value = Option.toDbNull ``int``)
          SqlParameter("money", SqlDbType.Money, Value = Option.toDbNull ``money``)
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
          SqlParameter("ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
          SqlParameter("real", SqlDbType.Real, Value = Option.toDbNull ``real``)
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
          SqlParameter("smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
          SqlParameter("text", SqlDbType.Text, Value = Option.toDbNull ``text``)
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
          SqlParameter("xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
        |]
      ``AllTypesNull_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = (^a: (member ``Key1``: int) dto))
          SqlParameter("key2", SqlDbType.Int, Value = (^a: (member ``Key2``: int) dto))
          SqlParameter("bigint", SqlDbType.BigInt, Value = Option.toDbNull (^a: (member ``Bigint``: int64 option) dto))
          SqlParameter("binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull (^a: (member ``Binary``: byte [] option) dto))
          SqlParameter("bit", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Bit``: bool option) dto))
          SqlParameter("char", SqlDbType.Char, Size = 42, Value = Option.toDbNull (^a: (member ``Char``: string option) dto))
          SqlParameter("date", SqlDbType.Date, Value = Option.toDbNull (^a: (member ``Date``: DateTime option) dto))
          SqlParameter("datetime", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto))
          SqlParameter("datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto))
          SqlParameter("datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto))
          SqlParameter("decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull (^a: (member ``Decimal``: decimal option) dto))
          SqlParameter("float", SqlDbType.Float, Size = 8, Value = Option.toDbNull (^a: (member ``Float``: float option) dto))
          SqlParameter("image", SqlDbType.Image, Value = Option.toDbNull (^a: (member ``Image``: byte [] option) dto))
          SqlParameter("int", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Int``: int option) dto))
          SqlParameter("money", SqlDbType.Money, Value = Option.toDbNull (^a: (member ``Money``: decimal option) dto))
          SqlParameter("nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nchar``: string option) dto))
          SqlParameter("ntext", SqlDbType.NText, Value = Option.toDbNull (^a: (member ``Ntext``: string option) dto))
          SqlParameter("numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull (^a: (member ``Numeric``: decimal option) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nvarchar``: string option) dto))
          SqlParameter("real", SqlDbType.Real, Value = Option.toDbNull (^a: (member ``Real``: float32 option) dto))
          SqlParameter("smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto))
          SqlParameter("smallint", SqlDbType.SmallInt, Value = Option.toDbNull (^a: (member ``Smallint``: int16 option) dto))
          SqlParameter("smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto))
          SqlParameter("text", SqlDbType.Text, Value = Option.toDbNull (^a: (member ``Text``: string option) dto))
          SqlParameter("time", SqlDbType.Time, Size = 3, Value = Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto))
          SqlParameter("tinyint", SqlDbType.TinyInt, Value = Option.toDbNull (^a: (member ``Tinyint``: byte option) dto))
          SqlParameter("uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Varchar``: string option) dto))
          SqlParameter("xml", SqlDbType.Xml, Value = Option.toDbNull (^a: (member ``Xml``: string option) dto))
        |]
      ``AllTypesNull_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``AllTypesNull_UpdateBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key1``: int,
          ``key2``: int,
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) : ``args`` =
        [|
          ``key1`` |> box
          ``key2`` |> box
          Option.toDbNull ``bigint`` |> box
          Option.toDbNull ``binary`` |> box
          Option.toDbNull ``bit`` |> box
          Option.toDbNull ``char`` |> box
          Option.toDbNull ``date`` |> box
          Option.toDbNull ``datetime`` |> box
          Option.toDbNull ``datetime2`` |> box
          Option.toDbNull ``datetimeoffset`` |> box
          Option.toDbNull ``decimal`` |> box
          Option.toDbNull ``float`` |> box
          Option.toDbNull ``image`` |> box
          Option.toDbNull ``int`` |> box
          Option.toDbNull ``money`` |> box
          Option.toDbNull ``nchar`` |> box
          Option.toDbNull ``ntext`` |> box
          Option.toDbNull ``numeric`` |> box
          Option.toDbNull ``nvarchar`` |> box
          Option.toDbNull ``real`` |> box
          Option.toDbNull ``smalldatetime`` |> box
          Option.toDbNull ``smallint`` |> box
          Option.toDbNull ``smallmoney`` |> box
          Option.toDbNull ``text`` |> box
          Option.toDbNull ``time`` |> box
          Option.toDbNull ``tinyint`` |> box
          Option.toDbNull ``uniqueidentifier`` |> box
          Option.toDbNull ``varbinary`` |> box
          Option.toDbNull ``varchar`` |> box
          Option.toDbNull ``xml`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key1``: int) dto) |> box
          (^a: (member ``key2``: int) dto) |> box
          Option.toDbNull (^a: (member ``bigint``: int64 option) dto) |> box
          Option.toDbNull (^a: (member ``binary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``bit``: bool option) dto) |> box
          Option.toDbNull (^a: (member ``char``: string option) dto) |> box
          Option.toDbNull (^a: (member ``date``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``datetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``datetime2``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``datetimeoffset``: DateTimeOffset option) dto) |> box
          Option.toDbNull (^a: (member ``decimal``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``float``: float option) dto) |> box
          Option.toDbNull (^a: (member ``image``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``int``: int option) dto) |> box
          Option.toDbNull (^a: (member ``money``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``nchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``ntext``: string option) dto) |> box
          Option.toDbNull (^a: (member ``numeric``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``nvarchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``real``: float32 option) dto) |> box
          Option.toDbNull (^a: (member ``smalldatetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``smallint``: int16 option) dto) |> box
          Option.toDbNull (^a: (member ``smallmoney``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``text``: string option) dto) |> box
          Option.toDbNull (^a: (member ``time``: TimeSpan option) dto) |> box
          Option.toDbNull (^a: (member ``tinyint``: byte option) dto) |> box
          Option.toDbNull (^a: (member ``uniqueidentifier``: Guid option) dto) |> box
          Option.toDbNull (^a: (member ``varbinary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``varchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``xml``: string option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``AllTypesNull_UpdateBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- AllTypesNull_UpdateBatch
UPDATE
  [dbo].[AllTypesNull]
SET
  [bigint] = x.[bigint],
  [binary] = x.[binary],
  [bit] = x.[bit],
  [char] = x.[char],
  [date] = x.[date],
  [datetime] = x.[datetime],
  [datetime2] = x.[datetime2],
  [datetimeoffset] = x.[datetimeoffset],
  [decimal] = x.[decimal],
  [float] = x.[float],
  [image] = x.[image],
  [int] = x.[int],
  [money] = x.[money],
  [nchar] = x.[nchar],
  [ntext] = x.[ntext],
  [numeric] = x.[numeric],
  [nvarchar] = x.[nvarchar],
  [real] = x.[real],
  [smalldatetime] = x.[smalldatetime],
  [smallint] = x.[smallint],
  [smallmoney] = x.[smallmoney],
  [text] = x.[text],
  [time] = x.[time],
  [tinyint] = x.[tinyint],
  [uniqueidentifier] = x.[uniqueidentifier],
  [varbinary] = x.[varbinary],
  [varchar] = x.[varchar],
  [xml] = x.[xml]
FROM
  [dbo].[AllTypesNull]
INNER JOIN
  #args AS x
    ON
      [AllTypesNull].[key1] = x.[key1]
      AND [AllTypesNull].[key2] = x.[key2]"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``AllTypesNull_UpdateBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``AllTypesNull_UpdateBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``AllTypesNull_UpdateBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``AllTypesNull_UpdateBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``AllTypesNull_UpdateBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key1] INT NOT NULL,
              [key2] INT NOT NULL,
              [bigint] BIGINT NULL,
              [binary] BINARY(42) NULL,
              [bit] BIT NULL,
              [char] CHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [date] DATE NULL,
              [datetime] DATETIME NULL,
              [datetime2] DATETIME2(3) NULL,
              [datetimeoffset] DATETIMEOFFSET(1) NULL,
              [decimal] DECIMAL(10, 5) NULL,
              [float] FLOAT(53) NULL,
              [image] IMAGE NULL,
              [int] INT NULL,
              [money] MONEY NULL,
              [nchar] NCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [ntext] NTEXT COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [numeric] NUMERIC(8, 3) NULL,
              [nvarchar] NVARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [real] REAL NULL,
              [smalldatetime] SMALLDATETIME NULL,
              [smallint] SMALLINT NULL,
              [smallmoney] SMALLMONEY NULL,
              [text] TEXT COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [time] TIME(1) NULL,
              [tinyint] TINYINT NULL,
              [uniqueidentifier] UNIQUEIDENTIFIER NULL,
              [varbinary] VARBINARY(42) NULL,
              [varchar] VARCHAR(42) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              [xml] XML NULL,
              PRIMARY KEY ([key1], [key2])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            30,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``AllTypesNull_UpdateBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``AllTypesNull_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``AllTypesNull_UpdateBatch``.``args``>) dto)
        )
      ``AllTypesNull_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  type ``ColumnInheritance`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- ColumnInheritance.sql
DECLARE @hid HIERARCHYID

SELECT
  Col1 = 1,
  Col2 = 2,
  Col3 = @hid,
  Col4 = @hid"""
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``TableDtoColumnInheritance`` =
      let ``Col1`` = reader.GetInt32 ``ordinal_Col1``
      let ``Col2`` = reader.GetInt32 ``ordinal_Col2``
      {
        ``Col1`` = ``Col1``
        ``Col2`` = ``Col2``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``ColumnInheritance``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``ColumnInheritance``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``ColumnInheritance``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``DeleteAllFromTableScriptTables`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- DeleteAllFromTableScriptTables.sql
DELETE FROM AllTypesNonNull
DELETE FROM AllTypesNull
DELETE FROM LengthTypes
DELETE FROM MaxLengthTypes
DELETE FROM TableWithIdentityCol"""
      userConfigureCmd cmd

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DeleteAllFromTableScriptTables``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DeleteAllFromTableScriptTables``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DeleteAllFromTableScriptTables``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeNonQueryAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeNonQuery connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``DesignTimeExecuteTest_All`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- DesignTimeExecuteTest_All
SELECT
  [Col]
FROM
  [dbo].[DesignTimeExecuteTest]"""
      userConfigureCmd cmd

    let initOrdinals = ignore<SqlDataReader>

    let getItem (reader: SqlDataReader) =
      reader.GetGuid 0

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DesignTimeExecuteTest_All``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DesignTimeExecuteTest_All``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DesignTimeExecuteTest_All``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``DynamicInsertIntoDesignTimeExecuteTest`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- DynamicInsertIntoDesignTimeExecuteTest.sql
DECLARE @sql NVARCHAR(MAX) = '
INSERT INTO dbo.DesignTimeExecuteTest VALUES (NEWID())
SELECT * FROM dbo.DesignTimeExecuteTest
'

IF 1 = 0 SET @sql += 'not used, but will force execute to get columns'

EXEC sp_executesql @sql, N''"""
      userConfigureCmd cmd

    let initOrdinals = ignore<SqlDataReader>

    let getItem (reader: SqlDataReader) =
      reader.GetGuid 0

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DynamicInsertIntoDesignTimeExecuteTest``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicInsertIntoDesignTimeExecuteTest``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DynamicInsertIntoDesignTimeExecuteTest``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``DynamicInsertIntoDesignTimeExecuteTest2`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- DynamicInsertIntoDesignTimeExecuteTest2.sql
DECLARE @sql NVARCHAR(MAX) = '
INSERT INTO dbo.DesignTimeExecuteTest VALUES (NEWID())
SELECT * FROM dbo.DesignTimeExecuteTest
'

EXEC sp_executesql @sql, N''"""
      userConfigureCmd cmd

    let initOrdinals = ignore<SqlDataReader>

    let getItem (reader: SqlDataReader) =
      reader.GetGuid 0

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DynamicInsertIntoDesignTimeExecuteTest2``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicInsertIntoDesignTimeExecuteTest2``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DynamicInsertIntoDesignTimeExecuteTest2``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``DynamicSqlSensitiveToParamValues_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- DynamicSqlSensitiveToParamValues.sql
DECLARE @sql NVARCHAR(MAX) = 'SELECT * FROM dbo.Table1 ORDER BY ' + @orderBy
EXEC sp_executesql @sql, N''"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``DynamicSqlSensitiveToParamValues`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DynamicSqlSensitiveToParamValues``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicSqlSensitiveToParamValues``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DynamicSqlSensitiveToParamValues``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``orderBy``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@orderBy", SqlDbType.NVarChar, Size = 0, Value = ``orderBy``)
        |]
      ``DynamicSqlSensitiveToParamValues_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@orderBy", SqlDbType.NVarChar, Size = 0, Value = (^a: (member ``OrderBy``: string) dto))
        |]
      ``DynamicSqlSensitiveToParamValues_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``DynamicSqlSensitiveToParamValuesWithResultSets_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- DynamicSqlSensitiveToParamValuesWithResultSets.sql
DECLARE @sql NVARCHAR(MAX) = 'SELECT * FROM dbo.Table1 ORDER BY ' + @orderBy
EXEC sp_executesql @sql, N''

WITH RESULT SETS (([TableCol1] NVARCHAR (42) NOT NULL, [TableCol2] INT NULL))"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``DynamicSqlSensitiveToParamValuesWithResultSets`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DynamicSqlSensitiveToParamValuesWithResultSets``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicSqlSensitiveToParamValuesWithResultSets``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DynamicSqlSensitiveToParamValuesWithResultSets``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``orderBy``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@orderBy", SqlDbType.NVarChar, Size = 0, Value = ``orderBy``)
        |]
      ``DynamicSqlSensitiveToParamValuesWithResultSets_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@orderBy", SqlDbType.NVarChar, Size = 0, Value = (^a: (member ``OrderBy``: string) dto))
        |]
      ``DynamicSqlSensitiveToParamValuesWithResultSets_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  type ``DynamicSqlWithConflictingBranches`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- DynamicSqlWithConflictingBranches.sql
DECLARE @sql NVARCHAR(MAX) = 'SELECT * FROM dbo.Table1'

IF 1 = 1 SET @sql += ' ORDER BY TableCol1'
IF 1 = 0 SET @sql += ' ORDER BY TableCol2'

EXEC sp_executesql @sql, N''"""
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DynamicSqlWithConflictingBranches``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicSqlWithConflictingBranches``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DynamicSqlWithConflictingBranches``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``DynamicSqlWithDeclaration_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- DynamicSqlWithDeclaration.sql
DECLARE @_col1Filter NVARCHAR(42) = @col1Filter

DECLARE @sql NVARCHAR(MAX) =
  'SELECT * FROM dbo.Table1 WHERE TableCol1 = @col1Filter'

DECLARE @paramList NVARCHAR(MAX) =
  '@col1Filter NVARCHAR(42)'

EXEC sp_executesql @sql, @paramList, @_col1Filter"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``DynamicSqlWithDeclaration`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DynamicSqlWithDeclaration``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicSqlWithDeclaration``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DynamicSqlWithDeclaration``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``col1Filter``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = ``col1Filter``)
        |]
      ``DynamicSqlWithDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Col1Filter``: string) dto))
        |]
      ``DynamicSqlWithDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``DynamicSqlWithoutDeclaration_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- DynamicSqlWithoutDeclaration.sql
DECLARE @sql NVARCHAR(MAX) =
  'SELECT * FROM dbo.Table1 WHERE TableCol1 = @col1Filter'

DECLARE @paramList NVARCHAR(MAX) =
  '@col1Filter NVARCHAR(42)'

EXEC sp_executesql @sql, @paramList, @col1Filter"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``DynamicSqlWithoutDeclaration`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DynamicSqlWithoutDeclaration``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicSqlWithoutDeclaration``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DynamicSqlWithoutDeclaration``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``col1Filter``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = ``col1Filter``)
        |]
      ``DynamicSqlWithoutDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Col1Filter``: string) dto))
        |]
      ``DynamicSqlWithoutDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``DynamicSqlWithStringSplitParam_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- DynamicSqlWithStringSplitParam.sql
DECLARE @sql NVARCHAR(MAX) = 'SELECT * FROM dbo.Table1'

IF @splitParam IS NOT NULL
  SET @sql += '
  WHERE TableCol1 IN (SELECT VALUE FROM STRING_SPLIT(@splitParam, '',''))
'

DECLARE @paramList NVARCHAR(MAX) =
  '@splitParam NVARCHAR(100)'

EXEC sp_executesql @sql, @paramList, @splitParam"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``DynamicSqlWithStringSplitParam`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DynamicSqlWithStringSplitParam``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicSqlWithStringSplitParam``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DynamicSqlWithStringSplitParam``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``splitParam``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@splitParam", SqlDbType.NVarChar, Size = 100, Value = ``splitParam``)
        |]
      ``DynamicSqlWithStringSplitParam_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@splitParam", SqlDbType.NVarChar, Size = 100, Value = (^a: (member ``SplitParam``: string) dto))
        |]
      ``DynamicSqlWithStringSplitParam_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``DynamicSqlWithTvp_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- DynamicSqlWithTvp.sql
DECLARE @sql NVARCHAR(MAX) =
  'SELECT * FROM dbo.Table1 WHERE TableCol2 IN (SELECT * FROM @tvp)'

DECLARE @paramList NVARCHAR(MAX) =
  '@tvp dbo.SingleColNonNull READONLY'

EXEC sp_executesql @sql, @paramList, @tvp"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``DynamicSqlWithTvp`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``DynamicSqlWithTvp``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicSqlWithTvp``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``DynamicSqlWithTvp``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``tvp``: seq<TableTypes.``dbo``.``SingleColNonNull``>
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty ``tvp``)
        |]
      ``DynamicSqlWithTvp_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``SingleColNonNull``>) dto))
        |]
      ``DynamicSqlWithTvp_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  type ``LengthTypes_All`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- LengthTypes_All
SELECT
  [key],
  [binary],
  [char],
  [nchar],
  [nvarchar],
  [varbinary],
  [varchar]
FROM
  [dbo].[LengthTypes]"""
      userConfigureCmd cmd

    let mutable ``ordinal_key`` = 0
    let mutable ``ordinal_binary`` = 0
    let mutable ``ordinal_char`` = 0
    let mutable ``ordinal_nchar`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_key`` <- reader.GetOrdinal "key"
      ``ordinal_binary`` <- reader.GetOrdinal "binary"
      ``ordinal_char`` <- reader.GetOrdinal "char"
      ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``LengthTypes`` =
      let ``key`` = reader.GetInt32 ``ordinal_key``
      let ``binary`` = reader.GetBytes ``ordinal_binary``
      let ``char`` = reader.GetString ``ordinal_char``
      let ``nchar`` = reader.GetString ``ordinal_nchar``
      let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
      let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
      let ``varchar`` = reader.GetString ``ordinal_varchar``
      {
        ``Key`` = ``key``
        ``Binary`` = ``binary``
        ``Char`` = ``char``
        ``Nchar`` = ``nchar``
        ``Nvarchar`` = ``nvarchar``
        ``Varbinary`` = ``varbinary``
        ``Varchar`` = ``varchar``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LengthTypes_All``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LengthTypes_All``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LengthTypes_All``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``LengthTypes_ById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- LengthTypes_ById
SELECT
  [key],
  [binary],
  [char],
  [nchar],
  [nvarchar],
  [varbinary],
  [varchar]
FROM
  [dbo].[LengthTypes]
WHERE
  [key] = @key"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_key`` = 0
    let mutable ``ordinal_binary`` = 0
    let mutable ``ordinal_char`` = 0
    let mutable ``ordinal_nchar`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_key`` <- reader.GetOrdinal "key"
      ``ordinal_binary`` <- reader.GetOrdinal "binary"
      ``ordinal_char`` <- reader.GetOrdinal "char"
      ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``LengthTypes`` =
      let ``key`` = reader.GetInt32 ``ordinal_key``
      let ``binary`` = reader.GetBytes ``ordinal_binary``
      let ``char`` = reader.GetString ``ordinal_char``
      let ``nchar`` = reader.GetString ``ordinal_nchar``
      let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
      let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
      let ``varchar`` = reader.GetString ``ordinal_varchar``
      {
        ``Key`` = ``key``
        ``Binary`` = ``binary``
        ``Char`` = ``char``
        ``Nchar`` = ``nchar``
        ``Nvarchar`` = ``nvarchar``
        ``Varbinary`` = ``varbinary``
        ``Varchar`` = ``varchar``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``LengthTypes_ById`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LengthTypes_ById``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LengthTypes_ById``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LengthTypes_ById``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
        |]
      ``LengthTypes_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
        |]
      ``LengthTypes_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``LengthTypes_Delete_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- LengthTypes_Delete
DELETE FROM [dbo].[LengthTypes]
WHERE
  [key] = @key"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``LengthTypes_Delete`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LengthTypes_Delete``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LengthTypes_Delete``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LengthTypes_Delete``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
        |]
      ``LengthTypes_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
        |]
      ``LengthTypes_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``LengthTypes_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- LengthTypes_Insert
INSERT INTO [dbo].[LengthTypes]
(
  [key],
  [binary],
  [char],
  [nchar],
  [nvarchar],
  [varbinary],
  [varchar]
)
VALUES
(
  @key,
  @binary,
  @char,
  @nchar,
  @nvarchar,
  @varbinary,
  @varchar
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``LengthTypes_Insert`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LengthTypes_Insert``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LengthTypes_Insert``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LengthTypes_Insert``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int,
        ``binary``: byte [],
        ``char``: string,
        ``nchar``: string,
        ``nvarchar``: string,
        ``varbinary``: byte [],
        ``varchar``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
          SqlParameter("binary", SqlDbType.Binary, Size = 3, Value = ``binary``)
          SqlParameter("char", SqlDbType.Char, Size = 3, Value = ``char``)
          SqlParameter("nchar", SqlDbType.NChar, Size = 3, Value = ``nchar``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 3, Value = ``nvarchar``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 3, Value = ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = 3, Value = ``varchar``)
        |]
      ``LengthTypes_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
          SqlParameter("binary", SqlDbType.Binary, Size = 3, Value = (^a: (member ``Binary``: byte []) dto))
          SqlParameter("char", SqlDbType.Char, Size = 3, Value = (^a: (member ``Char``: string) dto))
          SqlParameter("nchar", SqlDbType.NChar, Size = 3, Value = (^a: (member ``Nchar``: string) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 3, Value = (^a: (member ``Nvarchar``: string) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 3, Value = (^a: (member ``Varbinary``: byte []) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = 3, Value = (^a: (member ``Varchar``: string) dto))
        |]
      ``LengthTypes_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``LengthTypes_InsertBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key``: int,
          ``binary``: byte [],
          ``char``: string,
          ``nchar``: string,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) : ``args`` =
        [|
          ``key`` |> box
          ``binary`` |> box
          ``char`` |> box
          ``nchar`` |> box
          ``nvarchar`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key``: int) dto) |> box
          (^a: (member ``binary``: byte []) dto) |> box
          (^a: (member ``char``: string) dto) |> box
          (^a: (member ``nchar``: string) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``LengthTypes_InsertBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- LengthTypes_InsertBatch
INSERT INTO [dbo].[LengthTypes]
(
  [key],
  [binary],
  [char],
  [nchar],
  [nvarchar],
  [varbinary],
  [varchar]
)
SELECT
  [key],
  [binary],
  [char],
  [nchar],
  [nvarchar],
  [varbinary],
  [varchar]
FROM #args"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``LengthTypes_InsertBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LengthTypes_InsertBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LengthTypes_InsertBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LengthTypes_InsertBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``LengthTypes_InsertBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key] INT NOT NULL,
              [binary] BINARY(3) NOT NULL,
              [char] CHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [nchar] NCHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [nvarchar] NVARCHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [varbinary] VARBINARY(3) NOT NULL,
              [varchar] VARCHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            7,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``LengthTypes_InsertBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``LengthTypes_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``LengthTypes_InsertBatch``.``args``>) dto)
        )
      ``LengthTypes_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``LengthTypes_Merge_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- LengthTypes_Merge
MERGE [dbo].[LengthTypes]
USING
(
  SELECT
    [key] = @key,
    [binary] = @binary,
    [char] = @char,
    [nchar] = @nchar,
    [nvarchar] = @nvarchar,
    [varbinary] = @varbinary,
    [varchar] = @varchar
)
AS x
ON
  [LengthTypes].[key] = x.[key]

WHEN MATCHED THEN
  UPDATE
  SET
    [binary] = x.[binary],
    [char] = x.[char],
    [nchar] = x.[nchar],
    [nvarchar] = x.[nvarchar],
    [varbinary] = x.[varbinary],
    [varchar] = x.[varchar]

WHEN NOT MATCHED THEN
  INSERT
  (
    [key],
    [binary],
    [char],
    [nchar],
    [nvarchar],
    [varbinary],
    [varchar]
  )
  VALUES
  (
    x.[key],
    x.[binary],
    x.[char],
    x.[nchar],
    x.[nvarchar],
    x.[varbinary],
    x.[varchar]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``LengthTypes_Merge`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LengthTypes_Merge``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LengthTypes_Merge``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LengthTypes_Merge``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int,
        ``binary``: byte [],
        ``char``: string,
        ``nchar``: string,
        ``nvarchar``: string,
        ``varbinary``: byte [],
        ``varchar``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
          SqlParameter("binary", SqlDbType.Binary, Size = 3, Value = ``binary``)
          SqlParameter("char", SqlDbType.Char, Size = 3, Value = ``char``)
          SqlParameter("nchar", SqlDbType.NChar, Size = 3, Value = ``nchar``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 3, Value = ``nvarchar``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 3, Value = ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = 3, Value = ``varchar``)
        |]
      ``LengthTypes_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
          SqlParameter("binary", SqlDbType.Binary, Size = 3, Value = (^a: (member ``Binary``: byte []) dto))
          SqlParameter("char", SqlDbType.Char, Size = 3, Value = (^a: (member ``Char``: string) dto))
          SqlParameter("nchar", SqlDbType.NChar, Size = 3, Value = (^a: (member ``Nchar``: string) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 3, Value = (^a: (member ``Nvarchar``: string) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 3, Value = (^a: (member ``Varbinary``: byte []) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = 3, Value = (^a: (member ``Varchar``: string) dto))
        |]
      ``LengthTypes_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``LengthTypes_MergeBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key``: int,
          ``binary``: byte [],
          ``char``: string,
          ``nchar``: string,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) : ``args`` =
        [|
          ``key`` |> box
          ``binary`` |> box
          ``char`` |> box
          ``nchar`` |> box
          ``nvarchar`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key``: int) dto) |> box
          (^a: (member ``binary``: byte []) dto) |> box
          (^a: (member ``char``: string) dto) |> box
          (^a: (member ``nchar``: string) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``LengthTypes_MergeBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- LengthTypes_MergeBatch
MERGE [dbo].[LengthTypes]
USING
  #args
AS x
ON
  [LengthTypes].[key] = x.[key]

WHEN MATCHED THEN
  UPDATE
  SET
    [binary] = x.[binary],
    [char] = x.[char],
    [nchar] = x.[nchar],
    [nvarchar] = x.[nvarchar],
    [varbinary] = x.[varbinary],
    [varchar] = x.[varchar]

WHEN NOT MATCHED THEN
  INSERT
  (
    [key],
    [binary],
    [char],
    [nchar],
    [nvarchar],
    [varbinary],
    [varchar]
  )
  VALUES
  (
    x.[key],
    x.[binary],
    x.[char],
    x.[nchar],
    x.[nvarchar],
    x.[varbinary],
    x.[varchar]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``LengthTypes_MergeBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LengthTypes_MergeBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LengthTypes_MergeBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LengthTypes_MergeBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``LengthTypes_MergeBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key] INT NOT NULL,
              [binary] BINARY(3) NOT NULL,
              [char] CHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [nchar] NCHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [nvarchar] NVARCHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [varbinary] VARBINARY(3) NOT NULL,
              [varchar] VARCHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              PRIMARY KEY ([key])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            7,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``LengthTypes_MergeBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``LengthTypes_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``LengthTypes_MergeBatch``.``args``>) dto)
        )
      ``LengthTypes_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``LengthTypes_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- LengthTypes_Update
UPDATE
  [dbo].[LengthTypes]
SET
  [binary] = @binary,
  [char] = @char,
  [nchar] = @nchar,
  [nvarchar] = @nvarchar,
  [varbinary] = @varbinary,
  [varchar] = @varchar
WHERE
  [key] = @key"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``LengthTypes_Update`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LengthTypes_Update``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LengthTypes_Update``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LengthTypes_Update``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int,
        ``binary``: byte [],
        ``char``: string,
        ``nchar``: string,
        ``nvarchar``: string,
        ``varbinary``: byte [],
        ``varchar``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
          SqlParameter("binary", SqlDbType.Binary, Size = 3, Value = ``binary``)
          SqlParameter("char", SqlDbType.Char, Size = 3, Value = ``char``)
          SqlParameter("nchar", SqlDbType.NChar, Size = 3, Value = ``nchar``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 3, Value = ``nvarchar``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 3, Value = ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = 3, Value = ``varchar``)
        |]
      ``LengthTypes_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
          SqlParameter("binary", SqlDbType.Binary, Size = 3, Value = (^a: (member ``Binary``: byte []) dto))
          SqlParameter("char", SqlDbType.Char, Size = 3, Value = (^a: (member ``Char``: string) dto))
          SqlParameter("nchar", SqlDbType.NChar, Size = 3, Value = (^a: (member ``Nchar``: string) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 3, Value = (^a: (member ``Nvarchar``: string) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = 3, Value = (^a: (member ``Varbinary``: byte []) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = 3, Value = (^a: (member ``Varchar``: string) dto))
        |]
      ``LengthTypes_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``LengthTypes_UpdateBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key``: int,
          ``binary``: byte [],
          ``char``: string,
          ``nchar``: string,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) : ``args`` =
        [|
          ``key`` |> box
          ``binary`` |> box
          ``char`` |> box
          ``nchar`` |> box
          ``nvarchar`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key``: int) dto) |> box
          (^a: (member ``binary``: byte []) dto) |> box
          (^a: (member ``char``: string) dto) |> box
          (^a: (member ``nchar``: string) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``LengthTypes_UpdateBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- LengthTypes_UpdateBatch
UPDATE
  [dbo].[LengthTypes]
SET
  [binary] = x.[binary],
  [char] = x.[char],
  [nchar] = x.[nchar],
  [nvarchar] = x.[nvarchar],
  [varbinary] = x.[varbinary],
  [varchar] = x.[varchar]
FROM
  [dbo].[LengthTypes]
INNER JOIN
  #args AS x
    ON
      [LengthTypes].[key] = x.[key]"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``LengthTypes_UpdateBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LengthTypes_UpdateBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LengthTypes_UpdateBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LengthTypes_UpdateBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``LengthTypes_UpdateBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key] INT NOT NULL,
              [binary] BINARY(3) NOT NULL,
              [char] CHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [nchar] NCHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [nvarchar] NVARCHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [varbinary] VARBINARY(3) NOT NULL,
              [varchar] VARCHAR(3) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              PRIMARY KEY ([key])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            7,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``LengthTypes_UpdateBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``LengthTypes_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``LengthTypes_UpdateBatch``.``args``>) dto)
        )
      ``LengthTypes_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  type ``LongRunningNonQuery`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- LongRunningNonQuery.sql
WAITFOR DELAY '00:00:10'"""
      userConfigureCmd cmd

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LongRunningNonQuery``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LongRunningNonQuery``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LongRunningNonQuery``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeNonQueryAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeNonQuery connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``LongRunningQuery`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- LongRunningQuery.sql
WAITFOR DELAY '00:00:10'

SELECT 1"""
      userConfigureCmd cmd

    let initOrdinals = ignore<SqlDataReader>

    let getItem (reader: SqlDataReader) =
      reader.GetInt32 0

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``LongRunningQuery``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``LongRunningQuery``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``LongRunningQuery``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``ManualTableDtoResult`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- ManualTableDtoResult.sql
SELECT * FROM Table1"""
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``ManualTableDtoResult``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``ManualTableDtoResult``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``ManualTableDtoResult``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``ManyColumns`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- ManyColumns.sql
DECLARE @numCols INT = 600
DECLARE @sql NVARCHAR(MAX) = 'SELECT '

DECLARE @colNo INT = 1

WHILE (@colNo <= @numCols)
BEGIN
  SET @sql += 'Column' + CAST(@colNo AS NVARCHAR) + ' = NULL' + CASE @colNo WHEN @numCols THEN '' ELSE ', ' END
  SET @colNo += 1
END

EXEC sp_executesql @sql"""
      userConfigureCmd cmd

    let mutable ``ordinal_Column1`` = 0
    let mutable ``ordinal_Column2`` = 0
    let mutable ``ordinal_Column3`` = 0
    let mutable ``ordinal_Column4`` = 0
    let mutable ``ordinal_Column5`` = 0
    let mutable ``ordinal_Column6`` = 0
    let mutable ``ordinal_Column7`` = 0
    let mutable ``ordinal_Column8`` = 0
    let mutable ``ordinal_Column9`` = 0
    let mutable ``ordinal_Column10`` = 0
    let mutable ``ordinal_Column11`` = 0
    let mutable ``ordinal_Column12`` = 0
    let mutable ``ordinal_Column13`` = 0
    let mutable ``ordinal_Column14`` = 0
    let mutable ``ordinal_Column15`` = 0
    let mutable ``ordinal_Column16`` = 0
    let mutable ``ordinal_Column17`` = 0
    let mutable ``ordinal_Column18`` = 0
    let mutable ``ordinal_Column19`` = 0
    let mutable ``ordinal_Column20`` = 0
    let mutable ``ordinal_Column21`` = 0
    let mutable ``ordinal_Column22`` = 0
    let mutable ``ordinal_Column23`` = 0
    let mutable ``ordinal_Column24`` = 0
    let mutable ``ordinal_Column25`` = 0
    let mutable ``ordinal_Column26`` = 0
    let mutable ``ordinal_Column27`` = 0
    let mutable ``ordinal_Column28`` = 0
    let mutable ``ordinal_Column29`` = 0
    let mutable ``ordinal_Column30`` = 0
    let mutable ``ordinal_Column31`` = 0
    let mutable ``ordinal_Column32`` = 0
    let mutable ``ordinal_Column33`` = 0
    let mutable ``ordinal_Column34`` = 0
    let mutable ``ordinal_Column35`` = 0
    let mutable ``ordinal_Column36`` = 0
    let mutable ``ordinal_Column37`` = 0
    let mutable ``ordinal_Column38`` = 0
    let mutable ``ordinal_Column39`` = 0
    let mutable ``ordinal_Column40`` = 0
    let mutable ``ordinal_Column41`` = 0
    let mutable ``ordinal_Column42`` = 0
    let mutable ``ordinal_Column43`` = 0
    let mutable ``ordinal_Column44`` = 0
    let mutable ``ordinal_Column45`` = 0
    let mutable ``ordinal_Column46`` = 0
    let mutable ``ordinal_Column47`` = 0
    let mutable ``ordinal_Column48`` = 0
    let mutable ``ordinal_Column49`` = 0
    let mutable ``ordinal_Column50`` = 0
    let mutable ``ordinal_Column51`` = 0
    let mutable ``ordinal_Column52`` = 0
    let mutable ``ordinal_Column53`` = 0
    let mutable ``ordinal_Column54`` = 0
    let mutable ``ordinal_Column55`` = 0
    let mutable ``ordinal_Column56`` = 0
    let mutable ``ordinal_Column57`` = 0
    let mutable ``ordinal_Column58`` = 0
    let mutable ``ordinal_Column59`` = 0
    let mutable ``ordinal_Column60`` = 0
    let mutable ``ordinal_Column61`` = 0
    let mutable ``ordinal_Column62`` = 0
    let mutable ``ordinal_Column63`` = 0
    let mutable ``ordinal_Column64`` = 0
    let mutable ``ordinal_Column65`` = 0
    let mutable ``ordinal_Column66`` = 0
    let mutable ``ordinal_Column67`` = 0
    let mutable ``ordinal_Column68`` = 0
    let mutable ``ordinal_Column69`` = 0
    let mutable ``ordinal_Column70`` = 0
    let mutable ``ordinal_Column71`` = 0
    let mutable ``ordinal_Column72`` = 0
    let mutable ``ordinal_Column73`` = 0
    let mutable ``ordinal_Column74`` = 0
    let mutable ``ordinal_Column75`` = 0
    let mutable ``ordinal_Column76`` = 0
    let mutable ``ordinal_Column77`` = 0
    let mutable ``ordinal_Column78`` = 0
    let mutable ``ordinal_Column79`` = 0
    let mutable ``ordinal_Column80`` = 0
    let mutable ``ordinal_Column81`` = 0
    let mutable ``ordinal_Column82`` = 0
    let mutable ``ordinal_Column83`` = 0
    let mutable ``ordinal_Column84`` = 0
    let mutable ``ordinal_Column85`` = 0
    let mutable ``ordinal_Column86`` = 0
    let mutable ``ordinal_Column87`` = 0
    let mutable ``ordinal_Column88`` = 0
    let mutable ``ordinal_Column89`` = 0
    let mutable ``ordinal_Column90`` = 0
    let mutable ``ordinal_Column91`` = 0
    let mutable ``ordinal_Column92`` = 0
    let mutable ``ordinal_Column93`` = 0
    let mutable ``ordinal_Column94`` = 0
    let mutable ``ordinal_Column95`` = 0
    let mutable ``ordinal_Column96`` = 0
    let mutable ``ordinal_Column97`` = 0
    let mutable ``ordinal_Column98`` = 0
    let mutable ``ordinal_Column99`` = 0
    let mutable ``ordinal_Column100`` = 0
    let mutable ``ordinal_Column101`` = 0
    let mutable ``ordinal_Column102`` = 0
    let mutable ``ordinal_Column103`` = 0
    let mutable ``ordinal_Column104`` = 0
    let mutable ``ordinal_Column105`` = 0
    let mutable ``ordinal_Column106`` = 0
    let mutable ``ordinal_Column107`` = 0
    let mutable ``ordinal_Column108`` = 0
    let mutable ``ordinal_Column109`` = 0
    let mutable ``ordinal_Column110`` = 0
    let mutable ``ordinal_Column111`` = 0
    let mutable ``ordinal_Column112`` = 0
    let mutable ``ordinal_Column113`` = 0
    let mutable ``ordinal_Column114`` = 0
    let mutable ``ordinal_Column115`` = 0
    let mutable ``ordinal_Column116`` = 0
    let mutable ``ordinal_Column117`` = 0
    let mutable ``ordinal_Column118`` = 0
    let mutable ``ordinal_Column119`` = 0
    let mutable ``ordinal_Column120`` = 0
    let mutable ``ordinal_Column121`` = 0
    let mutable ``ordinal_Column122`` = 0
    let mutable ``ordinal_Column123`` = 0
    let mutable ``ordinal_Column124`` = 0
    let mutable ``ordinal_Column125`` = 0
    let mutable ``ordinal_Column126`` = 0
    let mutable ``ordinal_Column127`` = 0
    let mutable ``ordinal_Column128`` = 0
    let mutable ``ordinal_Column129`` = 0
    let mutable ``ordinal_Column130`` = 0
    let mutable ``ordinal_Column131`` = 0
    let mutable ``ordinal_Column132`` = 0
    let mutable ``ordinal_Column133`` = 0
    let mutable ``ordinal_Column134`` = 0
    let mutable ``ordinal_Column135`` = 0
    let mutable ``ordinal_Column136`` = 0
    let mutable ``ordinal_Column137`` = 0
    let mutable ``ordinal_Column138`` = 0
    let mutable ``ordinal_Column139`` = 0
    let mutable ``ordinal_Column140`` = 0
    let mutable ``ordinal_Column141`` = 0
    let mutable ``ordinal_Column142`` = 0
    let mutable ``ordinal_Column143`` = 0
    let mutable ``ordinal_Column144`` = 0
    let mutable ``ordinal_Column145`` = 0
    let mutable ``ordinal_Column146`` = 0
    let mutable ``ordinal_Column147`` = 0
    let mutable ``ordinal_Column148`` = 0
    let mutable ``ordinal_Column149`` = 0
    let mutable ``ordinal_Column150`` = 0
    let mutable ``ordinal_Column151`` = 0
    let mutable ``ordinal_Column152`` = 0
    let mutable ``ordinal_Column153`` = 0
    let mutable ``ordinal_Column154`` = 0
    let mutable ``ordinal_Column155`` = 0
    let mutable ``ordinal_Column156`` = 0
    let mutable ``ordinal_Column157`` = 0
    let mutable ``ordinal_Column158`` = 0
    let mutable ``ordinal_Column159`` = 0
    let mutable ``ordinal_Column160`` = 0
    let mutable ``ordinal_Column161`` = 0
    let mutable ``ordinal_Column162`` = 0
    let mutable ``ordinal_Column163`` = 0
    let mutable ``ordinal_Column164`` = 0
    let mutable ``ordinal_Column165`` = 0
    let mutable ``ordinal_Column166`` = 0
    let mutable ``ordinal_Column167`` = 0
    let mutable ``ordinal_Column168`` = 0
    let mutable ``ordinal_Column169`` = 0
    let mutable ``ordinal_Column170`` = 0
    let mutable ``ordinal_Column171`` = 0
    let mutable ``ordinal_Column172`` = 0
    let mutable ``ordinal_Column173`` = 0
    let mutable ``ordinal_Column174`` = 0
    let mutable ``ordinal_Column175`` = 0
    let mutable ``ordinal_Column176`` = 0
    let mutable ``ordinal_Column177`` = 0
    let mutable ``ordinal_Column178`` = 0
    let mutable ``ordinal_Column179`` = 0
    let mutable ``ordinal_Column180`` = 0
    let mutable ``ordinal_Column181`` = 0
    let mutable ``ordinal_Column182`` = 0
    let mutable ``ordinal_Column183`` = 0
    let mutable ``ordinal_Column184`` = 0
    let mutable ``ordinal_Column185`` = 0
    let mutable ``ordinal_Column186`` = 0
    let mutable ``ordinal_Column187`` = 0
    let mutable ``ordinal_Column188`` = 0
    let mutable ``ordinal_Column189`` = 0
    let mutable ``ordinal_Column190`` = 0
    let mutable ``ordinal_Column191`` = 0
    let mutable ``ordinal_Column192`` = 0
    let mutable ``ordinal_Column193`` = 0
    let mutable ``ordinal_Column194`` = 0
    let mutable ``ordinal_Column195`` = 0
    let mutable ``ordinal_Column196`` = 0
    let mutable ``ordinal_Column197`` = 0
    let mutable ``ordinal_Column198`` = 0
    let mutable ``ordinal_Column199`` = 0
    let mutable ``ordinal_Column200`` = 0
    let mutable ``ordinal_Column201`` = 0
    let mutable ``ordinal_Column202`` = 0
    let mutable ``ordinal_Column203`` = 0
    let mutable ``ordinal_Column204`` = 0
    let mutable ``ordinal_Column205`` = 0
    let mutable ``ordinal_Column206`` = 0
    let mutable ``ordinal_Column207`` = 0
    let mutable ``ordinal_Column208`` = 0
    let mutable ``ordinal_Column209`` = 0
    let mutable ``ordinal_Column210`` = 0
    let mutable ``ordinal_Column211`` = 0
    let mutable ``ordinal_Column212`` = 0
    let mutable ``ordinal_Column213`` = 0
    let mutable ``ordinal_Column214`` = 0
    let mutable ``ordinal_Column215`` = 0
    let mutable ``ordinal_Column216`` = 0
    let mutable ``ordinal_Column217`` = 0
    let mutable ``ordinal_Column218`` = 0
    let mutable ``ordinal_Column219`` = 0
    let mutable ``ordinal_Column220`` = 0
    let mutable ``ordinal_Column221`` = 0
    let mutable ``ordinal_Column222`` = 0
    let mutable ``ordinal_Column223`` = 0
    let mutable ``ordinal_Column224`` = 0
    let mutable ``ordinal_Column225`` = 0
    let mutable ``ordinal_Column226`` = 0
    let mutable ``ordinal_Column227`` = 0
    let mutable ``ordinal_Column228`` = 0
    let mutable ``ordinal_Column229`` = 0
    let mutable ``ordinal_Column230`` = 0
    let mutable ``ordinal_Column231`` = 0
    let mutable ``ordinal_Column232`` = 0
    let mutable ``ordinal_Column233`` = 0
    let mutable ``ordinal_Column234`` = 0
    let mutable ``ordinal_Column235`` = 0
    let mutable ``ordinal_Column236`` = 0
    let mutable ``ordinal_Column237`` = 0
    let mutable ``ordinal_Column238`` = 0
    let mutable ``ordinal_Column239`` = 0
    let mutable ``ordinal_Column240`` = 0
    let mutable ``ordinal_Column241`` = 0
    let mutable ``ordinal_Column242`` = 0
    let mutable ``ordinal_Column243`` = 0
    let mutable ``ordinal_Column244`` = 0
    let mutable ``ordinal_Column245`` = 0
    let mutable ``ordinal_Column246`` = 0
    let mutable ``ordinal_Column247`` = 0
    let mutable ``ordinal_Column248`` = 0
    let mutable ``ordinal_Column249`` = 0
    let mutable ``ordinal_Column250`` = 0
    let mutable ``ordinal_Column251`` = 0
    let mutable ``ordinal_Column252`` = 0
    let mutable ``ordinal_Column253`` = 0
    let mutable ``ordinal_Column254`` = 0
    let mutable ``ordinal_Column255`` = 0
    let mutable ``ordinal_Column256`` = 0
    let mutable ``ordinal_Column257`` = 0
    let mutable ``ordinal_Column258`` = 0
    let mutable ``ordinal_Column259`` = 0
    let mutable ``ordinal_Column260`` = 0
    let mutable ``ordinal_Column261`` = 0
    let mutable ``ordinal_Column262`` = 0
    let mutable ``ordinal_Column263`` = 0
    let mutable ``ordinal_Column264`` = 0
    let mutable ``ordinal_Column265`` = 0
    let mutable ``ordinal_Column266`` = 0
    let mutable ``ordinal_Column267`` = 0
    let mutable ``ordinal_Column268`` = 0
    let mutable ``ordinal_Column269`` = 0
    let mutable ``ordinal_Column270`` = 0
    let mutable ``ordinal_Column271`` = 0
    let mutable ``ordinal_Column272`` = 0
    let mutable ``ordinal_Column273`` = 0
    let mutable ``ordinal_Column274`` = 0
    let mutable ``ordinal_Column275`` = 0
    let mutable ``ordinal_Column276`` = 0
    let mutable ``ordinal_Column277`` = 0
    let mutable ``ordinal_Column278`` = 0
    let mutable ``ordinal_Column279`` = 0
    let mutable ``ordinal_Column280`` = 0
    let mutable ``ordinal_Column281`` = 0
    let mutable ``ordinal_Column282`` = 0
    let mutable ``ordinal_Column283`` = 0
    let mutable ``ordinal_Column284`` = 0
    let mutable ``ordinal_Column285`` = 0
    let mutable ``ordinal_Column286`` = 0
    let mutable ``ordinal_Column287`` = 0
    let mutable ``ordinal_Column288`` = 0
    let mutable ``ordinal_Column289`` = 0
    let mutable ``ordinal_Column290`` = 0
    let mutable ``ordinal_Column291`` = 0
    let mutable ``ordinal_Column292`` = 0
    let mutable ``ordinal_Column293`` = 0
    let mutable ``ordinal_Column294`` = 0
    let mutable ``ordinal_Column295`` = 0
    let mutable ``ordinal_Column296`` = 0
    let mutable ``ordinal_Column297`` = 0
    let mutable ``ordinal_Column298`` = 0
    let mutable ``ordinal_Column299`` = 0
    let mutable ``ordinal_Column300`` = 0
    let mutable ``ordinal_Column301`` = 0
    let mutable ``ordinal_Column302`` = 0
    let mutable ``ordinal_Column303`` = 0
    let mutable ``ordinal_Column304`` = 0
    let mutable ``ordinal_Column305`` = 0
    let mutable ``ordinal_Column306`` = 0
    let mutable ``ordinal_Column307`` = 0
    let mutable ``ordinal_Column308`` = 0
    let mutable ``ordinal_Column309`` = 0
    let mutable ``ordinal_Column310`` = 0
    let mutable ``ordinal_Column311`` = 0
    let mutable ``ordinal_Column312`` = 0
    let mutable ``ordinal_Column313`` = 0
    let mutable ``ordinal_Column314`` = 0
    let mutable ``ordinal_Column315`` = 0
    let mutable ``ordinal_Column316`` = 0
    let mutable ``ordinal_Column317`` = 0
    let mutable ``ordinal_Column318`` = 0
    let mutable ``ordinal_Column319`` = 0
    let mutable ``ordinal_Column320`` = 0
    let mutable ``ordinal_Column321`` = 0
    let mutable ``ordinal_Column322`` = 0
    let mutable ``ordinal_Column323`` = 0
    let mutable ``ordinal_Column324`` = 0
    let mutable ``ordinal_Column325`` = 0
    let mutable ``ordinal_Column326`` = 0
    let mutable ``ordinal_Column327`` = 0
    let mutable ``ordinal_Column328`` = 0
    let mutable ``ordinal_Column329`` = 0
    let mutable ``ordinal_Column330`` = 0
    let mutable ``ordinal_Column331`` = 0
    let mutable ``ordinal_Column332`` = 0
    let mutable ``ordinal_Column333`` = 0
    let mutable ``ordinal_Column334`` = 0
    let mutable ``ordinal_Column335`` = 0
    let mutable ``ordinal_Column336`` = 0
    let mutable ``ordinal_Column337`` = 0
    let mutable ``ordinal_Column338`` = 0
    let mutable ``ordinal_Column339`` = 0
    let mutable ``ordinal_Column340`` = 0
    let mutable ``ordinal_Column341`` = 0
    let mutable ``ordinal_Column342`` = 0
    let mutable ``ordinal_Column343`` = 0
    let mutable ``ordinal_Column344`` = 0
    let mutable ``ordinal_Column345`` = 0
    let mutable ``ordinal_Column346`` = 0
    let mutable ``ordinal_Column347`` = 0
    let mutable ``ordinal_Column348`` = 0
    let mutable ``ordinal_Column349`` = 0
    let mutable ``ordinal_Column350`` = 0
    let mutable ``ordinal_Column351`` = 0
    let mutable ``ordinal_Column352`` = 0
    let mutable ``ordinal_Column353`` = 0
    let mutable ``ordinal_Column354`` = 0
    let mutable ``ordinal_Column355`` = 0
    let mutable ``ordinal_Column356`` = 0
    let mutable ``ordinal_Column357`` = 0
    let mutable ``ordinal_Column358`` = 0
    let mutable ``ordinal_Column359`` = 0
    let mutable ``ordinal_Column360`` = 0
    let mutable ``ordinal_Column361`` = 0
    let mutable ``ordinal_Column362`` = 0
    let mutable ``ordinal_Column363`` = 0
    let mutable ``ordinal_Column364`` = 0
    let mutable ``ordinal_Column365`` = 0
    let mutable ``ordinal_Column366`` = 0
    let mutable ``ordinal_Column367`` = 0
    let mutable ``ordinal_Column368`` = 0
    let mutable ``ordinal_Column369`` = 0
    let mutable ``ordinal_Column370`` = 0
    let mutable ``ordinal_Column371`` = 0
    let mutable ``ordinal_Column372`` = 0
    let mutable ``ordinal_Column373`` = 0
    let mutable ``ordinal_Column374`` = 0
    let mutable ``ordinal_Column375`` = 0
    let mutable ``ordinal_Column376`` = 0
    let mutable ``ordinal_Column377`` = 0
    let mutable ``ordinal_Column378`` = 0
    let mutable ``ordinal_Column379`` = 0
    let mutable ``ordinal_Column380`` = 0
    let mutable ``ordinal_Column381`` = 0
    let mutable ``ordinal_Column382`` = 0
    let mutable ``ordinal_Column383`` = 0
    let mutable ``ordinal_Column384`` = 0
    let mutable ``ordinal_Column385`` = 0
    let mutable ``ordinal_Column386`` = 0
    let mutable ``ordinal_Column387`` = 0
    let mutable ``ordinal_Column388`` = 0
    let mutable ``ordinal_Column389`` = 0
    let mutable ``ordinal_Column390`` = 0
    let mutable ``ordinal_Column391`` = 0
    let mutable ``ordinal_Column392`` = 0
    let mutable ``ordinal_Column393`` = 0
    let mutable ``ordinal_Column394`` = 0
    let mutable ``ordinal_Column395`` = 0
    let mutable ``ordinal_Column396`` = 0
    let mutable ``ordinal_Column397`` = 0
    let mutable ``ordinal_Column398`` = 0
    let mutable ``ordinal_Column399`` = 0
    let mutable ``ordinal_Column400`` = 0
    let mutable ``ordinal_Column401`` = 0
    let mutable ``ordinal_Column402`` = 0
    let mutable ``ordinal_Column403`` = 0
    let mutable ``ordinal_Column404`` = 0
    let mutable ``ordinal_Column405`` = 0
    let mutable ``ordinal_Column406`` = 0
    let mutable ``ordinal_Column407`` = 0
    let mutable ``ordinal_Column408`` = 0
    let mutable ``ordinal_Column409`` = 0
    let mutable ``ordinal_Column410`` = 0
    let mutable ``ordinal_Column411`` = 0
    let mutable ``ordinal_Column412`` = 0
    let mutable ``ordinal_Column413`` = 0
    let mutable ``ordinal_Column414`` = 0
    let mutable ``ordinal_Column415`` = 0
    let mutable ``ordinal_Column416`` = 0
    let mutable ``ordinal_Column417`` = 0
    let mutable ``ordinal_Column418`` = 0
    let mutable ``ordinal_Column419`` = 0
    let mutable ``ordinal_Column420`` = 0
    let mutable ``ordinal_Column421`` = 0
    let mutable ``ordinal_Column422`` = 0
    let mutable ``ordinal_Column423`` = 0
    let mutable ``ordinal_Column424`` = 0
    let mutable ``ordinal_Column425`` = 0
    let mutable ``ordinal_Column426`` = 0
    let mutable ``ordinal_Column427`` = 0
    let mutable ``ordinal_Column428`` = 0
    let mutable ``ordinal_Column429`` = 0
    let mutable ``ordinal_Column430`` = 0
    let mutable ``ordinal_Column431`` = 0
    let mutable ``ordinal_Column432`` = 0
    let mutable ``ordinal_Column433`` = 0
    let mutable ``ordinal_Column434`` = 0
    let mutable ``ordinal_Column435`` = 0
    let mutable ``ordinal_Column436`` = 0
    let mutable ``ordinal_Column437`` = 0
    let mutable ``ordinal_Column438`` = 0
    let mutable ``ordinal_Column439`` = 0
    let mutable ``ordinal_Column440`` = 0
    let mutable ``ordinal_Column441`` = 0
    let mutable ``ordinal_Column442`` = 0
    let mutable ``ordinal_Column443`` = 0
    let mutable ``ordinal_Column444`` = 0
    let mutable ``ordinal_Column445`` = 0
    let mutable ``ordinal_Column446`` = 0
    let mutable ``ordinal_Column447`` = 0
    let mutable ``ordinal_Column448`` = 0
    let mutable ``ordinal_Column449`` = 0
    let mutable ``ordinal_Column450`` = 0
    let mutable ``ordinal_Column451`` = 0
    let mutable ``ordinal_Column452`` = 0
    let mutable ``ordinal_Column453`` = 0
    let mutable ``ordinal_Column454`` = 0
    let mutable ``ordinal_Column455`` = 0
    let mutable ``ordinal_Column456`` = 0
    let mutable ``ordinal_Column457`` = 0
    let mutable ``ordinal_Column458`` = 0
    let mutable ``ordinal_Column459`` = 0
    let mutable ``ordinal_Column460`` = 0
    let mutable ``ordinal_Column461`` = 0
    let mutable ``ordinal_Column462`` = 0
    let mutable ``ordinal_Column463`` = 0
    let mutable ``ordinal_Column464`` = 0
    let mutable ``ordinal_Column465`` = 0
    let mutable ``ordinal_Column466`` = 0
    let mutable ``ordinal_Column467`` = 0
    let mutable ``ordinal_Column468`` = 0
    let mutable ``ordinal_Column469`` = 0
    let mutable ``ordinal_Column470`` = 0
    let mutable ``ordinal_Column471`` = 0
    let mutable ``ordinal_Column472`` = 0
    let mutable ``ordinal_Column473`` = 0
    let mutable ``ordinal_Column474`` = 0
    let mutable ``ordinal_Column475`` = 0
    let mutable ``ordinal_Column476`` = 0
    let mutable ``ordinal_Column477`` = 0
    let mutable ``ordinal_Column478`` = 0
    let mutable ``ordinal_Column479`` = 0
    let mutable ``ordinal_Column480`` = 0
    let mutable ``ordinal_Column481`` = 0
    let mutable ``ordinal_Column482`` = 0
    let mutable ``ordinal_Column483`` = 0
    let mutable ``ordinal_Column484`` = 0
    let mutable ``ordinal_Column485`` = 0
    let mutable ``ordinal_Column486`` = 0
    let mutable ``ordinal_Column487`` = 0
    let mutable ``ordinal_Column488`` = 0
    let mutable ``ordinal_Column489`` = 0
    let mutable ``ordinal_Column490`` = 0
    let mutable ``ordinal_Column491`` = 0
    let mutable ``ordinal_Column492`` = 0
    let mutable ``ordinal_Column493`` = 0
    let mutable ``ordinal_Column494`` = 0
    let mutable ``ordinal_Column495`` = 0
    let mutable ``ordinal_Column496`` = 0
    let mutable ``ordinal_Column497`` = 0
    let mutable ``ordinal_Column498`` = 0
    let mutable ``ordinal_Column499`` = 0
    let mutable ``ordinal_Column500`` = 0
    let mutable ``ordinal_Column501`` = 0
    let mutable ``ordinal_Column502`` = 0
    let mutable ``ordinal_Column503`` = 0
    let mutable ``ordinal_Column504`` = 0
    let mutable ``ordinal_Column505`` = 0
    let mutable ``ordinal_Column506`` = 0
    let mutable ``ordinal_Column507`` = 0
    let mutable ``ordinal_Column508`` = 0
    let mutable ``ordinal_Column509`` = 0
    let mutable ``ordinal_Column510`` = 0
    let mutable ``ordinal_Column511`` = 0
    let mutable ``ordinal_Column512`` = 0
    let mutable ``ordinal_Column513`` = 0
    let mutable ``ordinal_Column514`` = 0
    let mutable ``ordinal_Column515`` = 0
    let mutable ``ordinal_Column516`` = 0
    let mutable ``ordinal_Column517`` = 0
    let mutable ``ordinal_Column518`` = 0
    let mutable ``ordinal_Column519`` = 0
    let mutable ``ordinal_Column520`` = 0
    let mutable ``ordinal_Column521`` = 0
    let mutable ``ordinal_Column522`` = 0
    let mutable ``ordinal_Column523`` = 0
    let mutable ``ordinal_Column524`` = 0
    let mutable ``ordinal_Column525`` = 0
    let mutable ``ordinal_Column526`` = 0
    let mutable ``ordinal_Column527`` = 0
    let mutable ``ordinal_Column528`` = 0
    let mutable ``ordinal_Column529`` = 0
    let mutable ``ordinal_Column530`` = 0
    let mutable ``ordinal_Column531`` = 0
    let mutable ``ordinal_Column532`` = 0
    let mutable ``ordinal_Column533`` = 0
    let mutable ``ordinal_Column534`` = 0
    let mutable ``ordinal_Column535`` = 0
    let mutable ``ordinal_Column536`` = 0
    let mutable ``ordinal_Column537`` = 0
    let mutable ``ordinal_Column538`` = 0
    let mutable ``ordinal_Column539`` = 0
    let mutable ``ordinal_Column540`` = 0
    let mutable ``ordinal_Column541`` = 0
    let mutable ``ordinal_Column542`` = 0
    let mutable ``ordinal_Column543`` = 0
    let mutable ``ordinal_Column544`` = 0
    let mutable ``ordinal_Column545`` = 0
    let mutable ``ordinal_Column546`` = 0
    let mutable ``ordinal_Column547`` = 0
    let mutable ``ordinal_Column548`` = 0
    let mutable ``ordinal_Column549`` = 0
    let mutable ``ordinal_Column550`` = 0
    let mutable ``ordinal_Column551`` = 0
    let mutable ``ordinal_Column552`` = 0
    let mutable ``ordinal_Column553`` = 0
    let mutable ``ordinal_Column554`` = 0
    let mutable ``ordinal_Column555`` = 0
    let mutable ``ordinal_Column556`` = 0
    let mutable ``ordinal_Column557`` = 0
    let mutable ``ordinal_Column558`` = 0
    let mutable ``ordinal_Column559`` = 0
    let mutable ``ordinal_Column560`` = 0
    let mutable ``ordinal_Column561`` = 0
    let mutable ``ordinal_Column562`` = 0
    let mutable ``ordinal_Column563`` = 0
    let mutable ``ordinal_Column564`` = 0
    let mutable ``ordinal_Column565`` = 0
    let mutable ``ordinal_Column566`` = 0
    let mutable ``ordinal_Column567`` = 0
    let mutable ``ordinal_Column568`` = 0
    let mutable ``ordinal_Column569`` = 0
    let mutable ``ordinal_Column570`` = 0
    let mutable ``ordinal_Column571`` = 0
    let mutable ``ordinal_Column572`` = 0
    let mutable ``ordinal_Column573`` = 0
    let mutable ``ordinal_Column574`` = 0
    let mutable ``ordinal_Column575`` = 0
    let mutable ``ordinal_Column576`` = 0
    let mutable ``ordinal_Column577`` = 0
    let mutable ``ordinal_Column578`` = 0
    let mutable ``ordinal_Column579`` = 0
    let mutable ``ordinal_Column580`` = 0
    let mutable ``ordinal_Column581`` = 0
    let mutable ``ordinal_Column582`` = 0
    let mutable ``ordinal_Column583`` = 0
    let mutable ``ordinal_Column584`` = 0
    let mutable ``ordinal_Column585`` = 0
    let mutable ``ordinal_Column586`` = 0
    let mutable ``ordinal_Column587`` = 0
    let mutable ``ordinal_Column588`` = 0
    let mutable ``ordinal_Column589`` = 0
    let mutable ``ordinal_Column590`` = 0
    let mutable ``ordinal_Column591`` = 0
    let mutable ``ordinal_Column592`` = 0
    let mutable ``ordinal_Column593`` = 0
    let mutable ``ordinal_Column594`` = 0
    let mutable ``ordinal_Column595`` = 0
    let mutable ``ordinal_Column596`` = 0
    let mutable ``ordinal_Column597`` = 0
    let mutable ``ordinal_Column598`` = 0
    let mutable ``ordinal_Column599`` = 0
    let mutable ``ordinal_Column600`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Column1`` <- reader.GetOrdinal "Column1"
      ``ordinal_Column2`` <- reader.GetOrdinal "Column2"
      ``ordinal_Column3`` <- reader.GetOrdinal "Column3"
      ``ordinal_Column4`` <- reader.GetOrdinal "Column4"
      ``ordinal_Column5`` <- reader.GetOrdinal "Column5"
      ``ordinal_Column6`` <- reader.GetOrdinal "Column6"
      ``ordinal_Column7`` <- reader.GetOrdinal "Column7"
      ``ordinal_Column8`` <- reader.GetOrdinal "Column8"
      ``ordinal_Column9`` <- reader.GetOrdinal "Column9"
      ``ordinal_Column10`` <- reader.GetOrdinal "Column10"
      ``ordinal_Column11`` <- reader.GetOrdinal "Column11"
      ``ordinal_Column12`` <- reader.GetOrdinal "Column12"
      ``ordinal_Column13`` <- reader.GetOrdinal "Column13"
      ``ordinal_Column14`` <- reader.GetOrdinal "Column14"
      ``ordinal_Column15`` <- reader.GetOrdinal "Column15"
      ``ordinal_Column16`` <- reader.GetOrdinal "Column16"
      ``ordinal_Column17`` <- reader.GetOrdinal "Column17"
      ``ordinal_Column18`` <- reader.GetOrdinal "Column18"
      ``ordinal_Column19`` <- reader.GetOrdinal "Column19"
      ``ordinal_Column20`` <- reader.GetOrdinal "Column20"
      ``ordinal_Column21`` <- reader.GetOrdinal "Column21"
      ``ordinal_Column22`` <- reader.GetOrdinal "Column22"
      ``ordinal_Column23`` <- reader.GetOrdinal "Column23"
      ``ordinal_Column24`` <- reader.GetOrdinal "Column24"
      ``ordinal_Column25`` <- reader.GetOrdinal "Column25"
      ``ordinal_Column26`` <- reader.GetOrdinal "Column26"
      ``ordinal_Column27`` <- reader.GetOrdinal "Column27"
      ``ordinal_Column28`` <- reader.GetOrdinal "Column28"
      ``ordinal_Column29`` <- reader.GetOrdinal "Column29"
      ``ordinal_Column30`` <- reader.GetOrdinal "Column30"
      ``ordinal_Column31`` <- reader.GetOrdinal "Column31"
      ``ordinal_Column32`` <- reader.GetOrdinal "Column32"
      ``ordinal_Column33`` <- reader.GetOrdinal "Column33"
      ``ordinal_Column34`` <- reader.GetOrdinal "Column34"
      ``ordinal_Column35`` <- reader.GetOrdinal "Column35"
      ``ordinal_Column36`` <- reader.GetOrdinal "Column36"
      ``ordinal_Column37`` <- reader.GetOrdinal "Column37"
      ``ordinal_Column38`` <- reader.GetOrdinal "Column38"
      ``ordinal_Column39`` <- reader.GetOrdinal "Column39"
      ``ordinal_Column40`` <- reader.GetOrdinal "Column40"
      ``ordinal_Column41`` <- reader.GetOrdinal "Column41"
      ``ordinal_Column42`` <- reader.GetOrdinal "Column42"
      ``ordinal_Column43`` <- reader.GetOrdinal "Column43"
      ``ordinal_Column44`` <- reader.GetOrdinal "Column44"
      ``ordinal_Column45`` <- reader.GetOrdinal "Column45"
      ``ordinal_Column46`` <- reader.GetOrdinal "Column46"
      ``ordinal_Column47`` <- reader.GetOrdinal "Column47"
      ``ordinal_Column48`` <- reader.GetOrdinal "Column48"
      ``ordinal_Column49`` <- reader.GetOrdinal "Column49"
      ``ordinal_Column50`` <- reader.GetOrdinal "Column50"
      ``ordinal_Column51`` <- reader.GetOrdinal "Column51"
      ``ordinal_Column52`` <- reader.GetOrdinal "Column52"
      ``ordinal_Column53`` <- reader.GetOrdinal "Column53"
      ``ordinal_Column54`` <- reader.GetOrdinal "Column54"
      ``ordinal_Column55`` <- reader.GetOrdinal "Column55"
      ``ordinal_Column56`` <- reader.GetOrdinal "Column56"
      ``ordinal_Column57`` <- reader.GetOrdinal "Column57"
      ``ordinal_Column58`` <- reader.GetOrdinal "Column58"
      ``ordinal_Column59`` <- reader.GetOrdinal "Column59"
      ``ordinal_Column60`` <- reader.GetOrdinal "Column60"
      ``ordinal_Column61`` <- reader.GetOrdinal "Column61"
      ``ordinal_Column62`` <- reader.GetOrdinal "Column62"
      ``ordinal_Column63`` <- reader.GetOrdinal "Column63"
      ``ordinal_Column64`` <- reader.GetOrdinal "Column64"
      ``ordinal_Column65`` <- reader.GetOrdinal "Column65"
      ``ordinal_Column66`` <- reader.GetOrdinal "Column66"
      ``ordinal_Column67`` <- reader.GetOrdinal "Column67"
      ``ordinal_Column68`` <- reader.GetOrdinal "Column68"
      ``ordinal_Column69`` <- reader.GetOrdinal "Column69"
      ``ordinal_Column70`` <- reader.GetOrdinal "Column70"
      ``ordinal_Column71`` <- reader.GetOrdinal "Column71"
      ``ordinal_Column72`` <- reader.GetOrdinal "Column72"
      ``ordinal_Column73`` <- reader.GetOrdinal "Column73"
      ``ordinal_Column74`` <- reader.GetOrdinal "Column74"
      ``ordinal_Column75`` <- reader.GetOrdinal "Column75"
      ``ordinal_Column76`` <- reader.GetOrdinal "Column76"
      ``ordinal_Column77`` <- reader.GetOrdinal "Column77"
      ``ordinal_Column78`` <- reader.GetOrdinal "Column78"
      ``ordinal_Column79`` <- reader.GetOrdinal "Column79"
      ``ordinal_Column80`` <- reader.GetOrdinal "Column80"
      ``ordinal_Column81`` <- reader.GetOrdinal "Column81"
      ``ordinal_Column82`` <- reader.GetOrdinal "Column82"
      ``ordinal_Column83`` <- reader.GetOrdinal "Column83"
      ``ordinal_Column84`` <- reader.GetOrdinal "Column84"
      ``ordinal_Column85`` <- reader.GetOrdinal "Column85"
      ``ordinal_Column86`` <- reader.GetOrdinal "Column86"
      ``ordinal_Column87`` <- reader.GetOrdinal "Column87"
      ``ordinal_Column88`` <- reader.GetOrdinal "Column88"
      ``ordinal_Column89`` <- reader.GetOrdinal "Column89"
      ``ordinal_Column90`` <- reader.GetOrdinal "Column90"
      ``ordinal_Column91`` <- reader.GetOrdinal "Column91"
      ``ordinal_Column92`` <- reader.GetOrdinal "Column92"
      ``ordinal_Column93`` <- reader.GetOrdinal "Column93"
      ``ordinal_Column94`` <- reader.GetOrdinal "Column94"
      ``ordinal_Column95`` <- reader.GetOrdinal "Column95"
      ``ordinal_Column96`` <- reader.GetOrdinal "Column96"
      ``ordinal_Column97`` <- reader.GetOrdinal "Column97"
      ``ordinal_Column98`` <- reader.GetOrdinal "Column98"
      ``ordinal_Column99`` <- reader.GetOrdinal "Column99"
      ``ordinal_Column100`` <- reader.GetOrdinal "Column100"
      ``ordinal_Column101`` <- reader.GetOrdinal "Column101"
      ``ordinal_Column102`` <- reader.GetOrdinal "Column102"
      ``ordinal_Column103`` <- reader.GetOrdinal "Column103"
      ``ordinal_Column104`` <- reader.GetOrdinal "Column104"
      ``ordinal_Column105`` <- reader.GetOrdinal "Column105"
      ``ordinal_Column106`` <- reader.GetOrdinal "Column106"
      ``ordinal_Column107`` <- reader.GetOrdinal "Column107"
      ``ordinal_Column108`` <- reader.GetOrdinal "Column108"
      ``ordinal_Column109`` <- reader.GetOrdinal "Column109"
      ``ordinal_Column110`` <- reader.GetOrdinal "Column110"
      ``ordinal_Column111`` <- reader.GetOrdinal "Column111"
      ``ordinal_Column112`` <- reader.GetOrdinal "Column112"
      ``ordinal_Column113`` <- reader.GetOrdinal "Column113"
      ``ordinal_Column114`` <- reader.GetOrdinal "Column114"
      ``ordinal_Column115`` <- reader.GetOrdinal "Column115"
      ``ordinal_Column116`` <- reader.GetOrdinal "Column116"
      ``ordinal_Column117`` <- reader.GetOrdinal "Column117"
      ``ordinal_Column118`` <- reader.GetOrdinal "Column118"
      ``ordinal_Column119`` <- reader.GetOrdinal "Column119"
      ``ordinal_Column120`` <- reader.GetOrdinal "Column120"
      ``ordinal_Column121`` <- reader.GetOrdinal "Column121"
      ``ordinal_Column122`` <- reader.GetOrdinal "Column122"
      ``ordinal_Column123`` <- reader.GetOrdinal "Column123"
      ``ordinal_Column124`` <- reader.GetOrdinal "Column124"
      ``ordinal_Column125`` <- reader.GetOrdinal "Column125"
      ``ordinal_Column126`` <- reader.GetOrdinal "Column126"
      ``ordinal_Column127`` <- reader.GetOrdinal "Column127"
      ``ordinal_Column128`` <- reader.GetOrdinal "Column128"
      ``ordinal_Column129`` <- reader.GetOrdinal "Column129"
      ``ordinal_Column130`` <- reader.GetOrdinal "Column130"
      ``ordinal_Column131`` <- reader.GetOrdinal "Column131"
      ``ordinal_Column132`` <- reader.GetOrdinal "Column132"
      ``ordinal_Column133`` <- reader.GetOrdinal "Column133"
      ``ordinal_Column134`` <- reader.GetOrdinal "Column134"
      ``ordinal_Column135`` <- reader.GetOrdinal "Column135"
      ``ordinal_Column136`` <- reader.GetOrdinal "Column136"
      ``ordinal_Column137`` <- reader.GetOrdinal "Column137"
      ``ordinal_Column138`` <- reader.GetOrdinal "Column138"
      ``ordinal_Column139`` <- reader.GetOrdinal "Column139"
      ``ordinal_Column140`` <- reader.GetOrdinal "Column140"
      ``ordinal_Column141`` <- reader.GetOrdinal "Column141"
      ``ordinal_Column142`` <- reader.GetOrdinal "Column142"
      ``ordinal_Column143`` <- reader.GetOrdinal "Column143"
      ``ordinal_Column144`` <- reader.GetOrdinal "Column144"
      ``ordinal_Column145`` <- reader.GetOrdinal "Column145"
      ``ordinal_Column146`` <- reader.GetOrdinal "Column146"
      ``ordinal_Column147`` <- reader.GetOrdinal "Column147"
      ``ordinal_Column148`` <- reader.GetOrdinal "Column148"
      ``ordinal_Column149`` <- reader.GetOrdinal "Column149"
      ``ordinal_Column150`` <- reader.GetOrdinal "Column150"
      ``ordinal_Column151`` <- reader.GetOrdinal "Column151"
      ``ordinal_Column152`` <- reader.GetOrdinal "Column152"
      ``ordinal_Column153`` <- reader.GetOrdinal "Column153"
      ``ordinal_Column154`` <- reader.GetOrdinal "Column154"
      ``ordinal_Column155`` <- reader.GetOrdinal "Column155"
      ``ordinal_Column156`` <- reader.GetOrdinal "Column156"
      ``ordinal_Column157`` <- reader.GetOrdinal "Column157"
      ``ordinal_Column158`` <- reader.GetOrdinal "Column158"
      ``ordinal_Column159`` <- reader.GetOrdinal "Column159"
      ``ordinal_Column160`` <- reader.GetOrdinal "Column160"
      ``ordinal_Column161`` <- reader.GetOrdinal "Column161"
      ``ordinal_Column162`` <- reader.GetOrdinal "Column162"
      ``ordinal_Column163`` <- reader.GetOrdinal "Column163"
      ``ordinal_Column164`` <- reader.GetOrdinal "Column164"
      ``ordinal_Column165`` <- reader.GetOrdinal "Column165"
      ``ordinal_Column166`` <- reader.GetOrdinal "Column166"
      ``ordinal_Column167`` <- reader.GetOrdinal "Column167"
      ``ordinal_Column168`` <- reader.GetOrdinal "Column168"
      ``ordinal_Column169`` <- reader.GetOrdinal "Column169"
      ``ordinal_Column170`` <- reader.GetOrdinal "Column170"
      ``ordinal_Column171`` <- reader.GetOrdinal "Column171"
      ``ordinal_Column172`` <- reader.GetOrdinal "Column172"
      ``ordinal_Column173`` <- reader.GetOrdinal "Column173"
      ``ordinal_Column174`` <- reader.GetOrdinal "Column174"
      ``ordinal_Column175`` <- reader.GetOrdinal "Column175"
      ``ordinal_Column176`` <- reader.GetOrdinal "Column176"
      ``ordinal_Column177`` <- reader.GetOrdinal "Column177"
      ``ordinal_Column178`` <- reader.GetOrdinal "Column178"
      ``ordinal_Column179`` <- reader.GetOrdinal "Column179"
      ``ordinal_Column180`` <- reader.GetOrdinal "Column180"
      ``ordinal_Column181`` <- reader.GetOrdinal "Column181"
      ``ordinal_Column182`` <- reader.GetOrdinal "Column182"
      ``ordinal_Column183`` <- reader.GetOrdinal "Column183"
      ``ordinal_Column184`` <- reader.GetOrdinal "Column184"
      ``ordinal_Column185`` <- reader.GetOrdinal "Column185"
      ``ordinal_Column186`` <- reader.GetOrdinal "Column186"
      ``ordinal_Column187`` <- reader.GetOrdinal "Column187"
      ``ordinal_Column188`` <- reader.GetOrdinal "Column188"
      ``ordinal_Column189`` <- reader.GetOrdinal "Column189"
      ``ordinal_Column190`` <- reader.GetOrdinal "Column190"
      ``ordinal_Column191`` <- reader.GetOrdinal "Column191"
      ``ordinal_Column192`` <- reader.GetOrdinal "Column192"
      ``ordinal_Column193`` <- reader.GetOrdinal "Column193"
      ``ordinal_Column194`` <- reader.GetOrdinal "Column194"
      ``ordinal_Column195`` <- reader.GetOrdinal "Column195"
      ``ordinal_Column196`` <- reader.GetOrdinal "Column196"
      ``ordinal_Column197`` <- reader.GetOrdinal "Column197"
      ``ordinal_Column198`` <- reader.GetOrdinal "Column198"
      ``ordinal_Column199`` <- reader.GetOrdinal "Column199"
      ``ordinal_Column200`` <- reader.GetOrdinal "Column200"
      ``ordinal_Column201`` <- reader.GetOrdinal "Column201"
      ``ordinal_Column202`` <- reader.GetOrdinal "Column202"
      ``ordinal_Column203`` <- reader.GetOrdinal "Column203"
      ``ordinal_Column204`` <- reader.GetOrdinal "Column204"
      ``ordinal_Column205`` <- reader.GetOrdinal "Column205"
      ``ordinal_Column206`` <- reader.GetOrdinal "Column206"
      ``ordinal_Column207`` <- reader.GetOrdinal "Column207"
      ``ordinal_Column208`` <- reader.GetOrdinal "Column208"
      ``ordinal_Column209`` <- reader.GetOrdinal "Column209"
      ``ordinal_Column210`` <- reader.GetOrdinal "Column210"
      ``ordinal_Column211`` <- reader.GetOrdinal "Column211"
      ``ordinal_Column212`` <- reader.GetOrdinal "Column212"
      ``ordinal_Column213`` <- reader.GetOrdinal "Column213"
      ``ordinal_Column214`` <- reader.GetOrdinal "Column214"
      ``ordinal_Column215`` <- reader.GetOrdinal "Column215"
      ``ordinal_Column216`` <- reader.GetOrdinal "Column216"
      ``ordinal_Column217`` <- reader.GetOrdinal "Column217"
      ``ordinal_Column218`` <- reader.GetOrdinal "Column218"
      ``ordinal_Column219`` <- reader.GetOrdinal "Column219"
      ``ordinal_Column220`` <- reader.GetOrdinal "Column220"
      ``ordinal_Column221`` <- reader.GetOrdinal "Column221"
      ``ordinal_Column222`` <- reader.GetOrdinal "Column222"
      ``ordinal_Column223`` <- reader.GetOrdinal "Column223"
      ``ordinal_Column224`` <- reader.GetOrdinal "Column224"
      ``ordinal_Column225`` <- reader.GetOrdinal "Column225"
      ``ordinal_Column226`` <- reader.GetOrdinal "Column226"
      ``ordinal_Column227`` <- reader.GetOrdinal "Column227"
      ``ordinal_Column228`` <- reader.GetOrdinal "Column228"
      ``ordinal_Column229`` <- reader.GetOrdinal "Column229"
      ``ordinal_Column230`` <- reader.GetOrdinal "Column230"
      ``ordinal_Column231`` <- reader.GetOrdinal "Column231"
      ``ordinal_Column232`` <- reader.GetOrdinal "Column232"
      ``ordinal_Column233`` <- reader.GetOrdinal "Column233"
      ``ordinal_Column234`` <- reader.GetOrdinal "Column234"
      ``ordinal_Column235`` <- reader.GetOrdinal "Column235"
      ``ordinal_Column236`` <- reader.GetOrdinal "Column236"
      ``ordinal_Column237`` <- reader.GetOrdinal "Column237"
      ``ordinal_Column238`` <- reader.GetOrdinal "Column238"
      ``ordinal_Column239`` <- reader.GetOrdinal "Column239"
      ``ordinal_Column240`` <- reader.GetOrdinal "Column240"
      ``ordinal_Column241`` <- reader.GetOrdinal "Column241"
      ``ordinal_Column242`` <- reader.GetOrdinal "Column242"
      ``ordinal_Column243`` <- reader.GetOrdinal "Column243"
      ``ordinal_Column244`` <- reader.GetOrdinal "Column244"
      ``ordinal_Column245`` <- reader.GetOrdinal "Column245"
      ``ordinal_Column246`` <- reader.GetOrdinal "Column246"
      ``ordinal_Column247`` <- reader.GetOrdinal "Column247"
      ``ordinal_Column248`` <- reader.GetOrdinal "Column248"
      ``ordinal_Column249`` <- reader.GetOrdinal "Column249"
      ``ordinal_Column250`` <- reader.GetOrdinal "Column250"
      ``ordinal_Column251`` <- reader.GetOrdinal "Column251"
      ``ordinal_Column252`` <- reader.GetOrdinal "Column252"
      ``ordinal_Column253`` <- reader.GetOrdinal "Column253"
      ``ordinal_Column254`` <- reader.GetOrdinal "Column254"
      ``ordinal_Column255`` <- reader.GetOrdinal "Column255"
      ``ordinal_Column256`` <- reader.GetOrdinal "Column256"
      ``ordinal_Column257`` <- reader.GetOrdinal "Column257"
      ``ordinal_Column258`` <- reader.GetOrdinal "Column258"
      ``ordinal_Column259`` <- reader.GetOrdinal "Column259"
      ``ordinal_Column260`` <- reader.GetOrdinal "Column260"
      ``ordinal_Column261`` <- reader.GetOrdinal "Column261"
      ``ordinal_Column262`` <- reader.GetOrdinal "Column262"
      ``ordinal_Column263`` <- reader.GetOrdinal "Column263"
      ``ordinal_Column264`` <- reader.GetOrdinal "Column264"
      ``ordinal_Column265`` <- reader.GetOrdinal "Column265"
      ``ordinal_Column266`` <- reader.GetOrdinal "Column266"
      ``ordinal_Column267`` <- reader.GetOrdinal "Column267"
      ``ordinal_Column268`` <- reader.GetOrdinal "Column268"
      ``ordinal_Column269`` <- reader.GetOrdinal "Column269"
      ``ordinal_Column270`` <- reader.GetOrdinal "Column270"
      ``ordinal_Column271`` <- reader.GetOrdinal "Column271"
      ``ordinal_Column272`` <- reader.GetOrdinal "Column272"
      ``ordinal_Column273`` <- reader.GetOrdinal "Column273"
      ``ordinal_Column274`` <- reader.GetOrdinal "Column274"
      ``ordinal_Column275`` <- reader.GetOrdinal "Column275"
      ``ordinal_Column276`` <- reader.GetOrdinal "Column276"
      ``ordinal_Column277`` <- reader.GetOrdinal "Column277"
      ``ordinal_Column278`` <- reader.GetOrdinal "Column278"
      ``ordinal_Column279`` <- reader.GetOrdinal "Column279"
      ``ordinal_Column280`` <- reader.GetOrdinal "Column280"
      ``ordinal_Column281`` <- reader.GetOrdinal "Column281"
      ``ordinal_Column282`` <- reader.GetOrdinal "Column282"
      ``ordinal_Column283`` <- reader.GetOrdinal "Column283"
      ``ordinal_Column284`` <- reader.GetOrdinal "Column284"
      ``ordinal_Column285`` <- reader.GetOrdinal "Column285"
      ``ordinal_Column286`` <- reader.GetOrdinal "Column286"
      ``ordinal_Column287`` <- reader.GetOrdinal "Column287"
      ``ordinal_Column288`` <- reader.GetOrdinal "Column288"
      ``ordinal_Column289`` <- reader.GetOrdinal "Column289"
      ``ordinal_Column290`` <- reader.GetOrdinal "Column290"
      ``ordinal_Column291`` <- reader.GetOrdinal "Column291"
      ``ordinal_Column292`` <- reader.GetOrdinal "Column292"
      ``ordinal_Column293`` <- reader.GetOrdinal "Column293"
      ``ordinal_Column294`` <- reader.GetOrdinal "Column294"
      ``ordinal_Column295`` <- reader.GetOrdinal "Column295"
      ``ordinal_Column296`` <- reader.GetOrdinal "Column296"
      ``ordinal_Column297`` <- reader.GetOrdinal "Column297"
      ``ordinal_Column298`` <- reader.GetOrdinal "Column298"
      ``ordinal_Column299`` <- reader.GetOrdinal "Column299"
      ``ordinal_Column300`` <- reader.GetOrdinal "Column300"
      ``ordinal_Column301`` <- reader.GetOrdinal "Column301"
      ``ordinal_Column302`` <- reader.GetOrdinal "Column302"
      ``ordinal_Column303`` <- reader.GetOrdinal "Column303"
      ``ordinal_Column304`` <- reader.GetOrdinal "Column304"
      ``ordinal_Column305`` <- reader.GetOrdinal "Column305"
      ``ordinal_Column306`` <- reader.GetOrdinal "Column306"
      ``ordinal_Column307`` <- reader.GetOrdinal "Column307"
      ``ordinal_Column308`` <- reader.GetOrdinal "Column308"
      ``ordinal_Column309`` <- reader.GetOrdinal "Column309"
      ``ordinal_Column310`` <- reader.GetOrdinal "Column310"
      ``ordinal_Column311`` <- reader.GetOrdinal "Column311"
      ``ordinal_Column312`` <- reader.GetOrdinal "Column312"
      ``ordinal_Column313`` <- reader.GetOrdinal "Column313"
      ``ordinal_Column314`` <- reader.GetOrdinal "Column314"
      ``ordinal_Column315`` <- reader.GetOrdinal "Column315"
      ``ordinal_Column316`` <- reader.GetOrdinal "Column316"
      ``ordinal_Column317`` <- reader.GetOrdinal "Column317"
      ``ordinal_Column318`` <- reader.GetOrdinal "Column318"
      ``ordinal_Column319`` <- reader.GetOrdinal "Column319"
      ``ordinal_Column320`` <- reader.GetOrdinal "Column320"
      ``ordinal_Column321`` <- reader.GetOrdinal "Column321"
      ``ordinal_Column322`` <- reader.GetOrdinal "Column322"
      ``ordinal_Column323`` <- reader.GetOrdinal "Column323"
      ``ordinal_Column324`` <- reader.GetOrdinal "Column324"
      ``ordinal_Column325`` <- reader.GetOrdinal "Column325"
      ``ordinal_Column326`` <- reader.GetOrdinal "Column326"
      ``ordinal_Column327`` <- reader.GetOrdinal "Column327"
      ``ordinal_Column328`` <- reader.GetOrdinal "Column328"
      ``ordinal_Column329`` <- reader.GetOrdinal "Column329"
      ``ordinal_Column330`` <- reader.GetOrdinal "Column330"
      ``ordinal_Column331`` <- reader.GetOrdinal "Column331"
      ``ordinal_Column332`` <- reader.GetOrdinal "Column332"
      ``ordinal_Column333`` <- reader.GetOrdinal "Column333"
      ``ordinal_Column334`` <- reader.GetOrdinal "Column334"
      ``ordinal_Column335`` <- reader.GetOrdinal "Column335"
      ``ordinal_Column336`` <- reader.GetOrdinal "Column336"
      ``ordinal_Column337`` <- reader.GetOrdinal "Column337"
      ``ordinal_Column338`` <- reader.GetOrdinal "Column338"
      ``ordinal_Column339`` <- reader.GetOrdinal "Column339"
      ``ordinal_Column340`` <- reader.GetOrdinal "Column340"
      ``ordinal_Column341`` <- reader.GetOrdinal "Column341"
      ``ordinal_Column342`` <- reader.GetOrdinal "Column342"
      ``ordinal_Column343`` <- reader.GetOrdinal "Column343"
      ``ordinal_Column344`` <- reader.GetOrdinal "Column344"
      ``ordinal_Column345`` <- reader.GetOrdinal "Column345"
      ``ordinal_Column346`` <- reader.GetOrdinal "Column346"
      ``ordinal_Column347`` <- reader.GetOrdinal "Column347"
      ``ordinal_Column348`` <- reader.GetOrdinal "Column348"
      ``ordinal_Column349`` <- reader.GetOrdinal "Column349"
      ``ordinal_Column350`` <- reader.GetOrdinal "Column350"
      ``ordinal_Column351`` <- reader.GetOrdinal "Column351"
      ``ordinal_Column352`` <- reader.GetOrdinal "Column352"
      ``ordinal_Column353`` <- reader.GetOrdinal "Column353"
      ``ordinal_Column354`` <- reader.GetOrdinal "Column354"
      ``ordinal_Column355`` <- reader.GetOrdinal "Column355"
      ``ordinal_Column356`` <- reader.GetOrdinal "Column356"
      ``ordinal_Column357`` <- reader.GetOrdinal "Column357"
      ``ordinal_Column358`` <- reader.GetOrdinal "Column358"
      ``ordinal_Column359`` <- reader.GetOrdinal "Column359"
      ``ordinal_Column360`` <- reader.GetOrdinal "Column360"
      ``ordinal_Column361`` <- reader.GetOrdinal "Column361"
      ``ordinal_Column362`` <- reader.GetOrdinal "Column362"
      ``ordinal_Column363`` <- reader.GetOrdinal "Column363"
      ``ordinal_Column364`` <- reader.GetOrdinal "Column364"
      ``ordinal_Column365`` <- reader.GetOrdinal "Column365"
      ``ordinal_Column366`` <- reader.GetOrdinal "Column366"
      ``ordinal_Column367`` <- reader.GetOrdinal "Column367"
      ``ordinal_Column368`` <- reader.GetOrdinal "Column368"
      ``ordinal_Column369`` <- reader.GetOrdinal "Column369"
      ``ordinal_Column370`` <- reader.GetOrdinal "Column370"
      ``ordinal_Column371`` <- reader.GetOrdinal "Column371"
      ``ordinal_Column372`` <- reader.GetOrdinal "Column372"
      ``ordinal_Column373`` <- reader.GetOrdinal "Column373"
      ``ordinal_Column374`` <- reader.GetOrdinal "Column374"
      ``ordinal_Column375`` <- reader.GetOrdinal "Column375"
      ``ordinal_Column376`` <- reader.GetOrdinal "Column376"
      ``ordinal_Column377`` <- reader.GetOrdinal "Column377"
      ``ordinal_Column378`` <- reader.GetOrdinal "Column378"
      ``ordinal_Column379`` <- reader.GetOrdinal "Column379"
      ``ordinal_Column380`` <- reader.GetOrdinal "Column380"
      ``ordinal_Column381`` <- reader.GetOrdinal "Column381"
      ``ordinal_Column382`` <- reader.GetOrdinal "Column382"
      ``ordinal_Column383`` <- reader.GetOrdinal "Column383"
      ``ordinal_Column384`` <- reader.GetOrdinal "Column384"
      ``ordinal_Column385`` <- reader.GetOrdinal "Column385"
      ``ordinal_Column386`` <- reader.GetOrdinal "Column386"
      ``ordinal_Column387`` <- reader.GetOrdinal "Column387"
      ``ordinal_Column388`` <- reader.GetOrdinal "Column388"
      ``ordinal_Column389`` <- reader.GetOrdinal "Column389"
      ``ordinal_Column390`` <- reader.GetOrdinal "Column390"
      ``ordinal_Column391`` <- reader.GetOrdinal "Column391"
      ``ordinal_Column392`` <- reader.GetOrdinal "Column392"
      ``ordinal_Column393`` <- reader.GetOrdinal "Column393"
      ``ordinal_Column394`` <- reader.GetOrdinal "Column394"
      ``ordinal_Column395`` <- reader.GetOrdinal "Column395"
      ``ordinal_Column396`` <- reader.GetOrdinal "Column396"
      ``ordinal_Column397`` <- reader.GetOrdinal "Column397"
      ``ordinal_Column398`` <- reader.GetOrdinal "Column398"
      ``ordinal_Column399`` <- reader.GetOrdinal "Column399"
      ``ordinal_Column400`` <- reader.GetOrdinal "Column400"
      ``ordinal_Column401`` <- reader.GetOrdinal "Column401"
      ``ordinal_Column402`` <- reader.GetOrdinal "Column402"
      ``ordinal_Column403`` <- reader.GetOrdinal "Column403"
      ``ordinal_Column404`` <- reader.GetOrdinal "Column404"
      ``ordinal_Column405`` <- reader.GetOrdinal "Column405"
      ``ordinal_Column406`` <- reader.GetOrdinal "Column406"
      ``ordinal_Column407`` <- reader.GetOrdinal "Column407"
      ``ordinal_Column408`` <- reader.GetOrdinal "Column408"
      ``ordinal_Column409`` <- reader.GetOrdinal "Column409"
      ``ordinal_Column410`` <- reader.GetOrdinal "Column410"
      ``ordinal_Column411`` <- reader.GetOrdinal "Column411"
      ``ordinal_Column412`` <- reader.GetOrdinal "Column412"
      ``ordinal_Column413`` <- reader.GetOrdinal "Column413"
      ``ordinal_Column414`` <- reader.GetOrdinal "Column414"
      ``ordinal_Column415`` <- reader.GetOrdinal "Column415"
      ``ordinal_Column416`` <- reader.GetOrdinal "Column416"
      ``ordinal_Column417`` <- reader.GetOrdinal "Column417"
      ``ordinal_Column418`` <- reader.GetOrdinal "Column418"
      ``ordinal_Column419`` <- reader.GetOrdinal "Column419"
      ``ordinal_Column420`` <- reader.GetOrdinal "Column420"
      ``ordinal_Column421`` <- reader.GetOrdinal "Column421"
      ``ordinal_Column422`` <- reader.GetOrdinal "Column422"
      ``ordinal_Column423`` <- reader.GetOrdinal "Column423"
      ``ordinal_Column424`` <- reader.GetOrdinal "Column424"
      ``ordinal_Column425`` <- reader.GetOrdinal "Column425"
      ``ordinal_Column426`` <- reader.GetOrdinal "Column426"
      ``ordinal_Column427`` <- reader.GetOrdinal "Column427"
      ``ordinal_Column428`` <- reader.GetOrdinal "Column428"
      ``ordinal_Column429`` <- reader.GetOrdinal "Column429"
      ``ordinal_Column430`` <- reader.GetOrdinal "Column430"
      ``ordinal_Column431`` <- reader.GetOrdinal "Column431"
      ``ordinal_Column432`` <- reader.GetOrdinal "Column432"
      ``ordinal_Column433`` <- reader.GetOrdinal "Column433"
      ``ordinal_Column434`` <- reader.GetOrdinal "Column434"
      ``ordinal_Column435`` <- reader.GetOrdinal "Column435"
      ``ordinal_Column436`` <- reader.GetOrdinal "Column436"
      ``ordinal_Column437`` <- reader.GetOrdinal "Column437"
      ``ordinal_Column438`` <- reader.GetOrdinal "Column438"
      ``ordinal_Column439`` <- reader.GetOrdinal "Column439"
      ``ordinal_Column440`` <- reader.GetOrdinal "Column440"
      ``ordinal_Column441`` <- reader.GetOrdinal "Column441"
      ``ordinal_Column442`` <- reader.GetOrdinal "Column442"
      ``ordinal_Column443`` <- reader.GetOrdinal "Column443"
      ``ordinal_Column444`` <- reader.GetOrdinal "Column444"
      ``ordinal_Column445`` <- reader.GetOrdinal "Column445"
      ``ordinal_Column446`` <- reader.GetOrdinal "Column446"
      ``ordinal_Column447`` <- reader.GetOrdinal "Column447"
      ``ordinal_Column448`` <- reader.GetOrdinal "Column448"
      ``ordinal_Column449`` <- reader.GetOrdinal "Column449"
      ``ordinal_Column450`` <- reader.GetOrdinal "Column450"
      ``ordinal_Column451`` <- reader.GetOrdinal "Column451"
      ``ordinal_Column452`` <- reader.GetOrdinal "Column452"
      ``ordinal_Column453`` <- reader.GetOrdinal "Column453"
      ``ordinal_Column454`` <- reader.GetOrdinal "Column454"
      ``ordinal_Column455`` <- reader.GetOrdinal "Column455"
      ``ordinal_Column456`` <- reader.GetOrdinal "Column456"
      ``ordinal_Column457`` <- reader.GetOrdinal "Column457"
      ``ordinal_Column458`` <- reader.GetOrdinal "Column458"
      ``ordinal_Column459`` <- reader.GetOrdinal "Column459"
      ``ordinal_Column460`` <- reader.GetOrdinal "Column460"
      ``ordinal_Column461`` <- reader.GetOrdinal "Column461"
      ``ordinal_Column462`` <- reader.GetOrdinal "Column462"
      ``ordinal_Column463`` <- reader.GetOrdinal "Column463"
      ``ordinal_Column464`` <- reader.GetOrdinal "Column464"
      ``ordinal_Column465`` <- reader.GetOrdinal "Column465"
      ``ordinal_Column466`` <- reader.GetOrdinal "Column466"
      ``ordinal_Column467`` <- reader.GetOrdinal "Column467"
      ``ordinal_Column468`` <- reader.GetOrdinal "Column468"
      ``ordinal_Column469`` <- reader.GetOrdinal "Column469"
      ``ordinal_Column470`` <- reader.GetOrdinal "Column470"
      ``ordinal_Column471`` <- reader.GetOrdinal "Column471"
      ``ordinal_Column472`` <- reader.GetOrdinal "Column472"
      ``ordinal_Column473`` <- reader.GetOrdinal "Column473"
      ``ordinal_Column474`` <- reader.GetOrdinal "Column474"
      ``ordinal_Column475`` <- reader.GetOrdinal "Column475"
      ``ordinal_Column476`` <- reader.GetOrdinal "Column476"
      ``ordinal_Column477`` <- reader.GetOrdinal "Column477"
      ``ordinal_Column478`` <- reader.GetOrdinal "Column478"
      ``ordinal_Column479`` <- reader.GetOrdinal "Column479"
      ``ordinal_Column480`` <- reader.GetOrdinal "Column480"
      ``ordinal_Column481`` <- reader.GetOrdinal "Column481"
      ``ordinal_Column482`` <- reader.GetOrdinal "Column482"
      ``ordinal_Column483`` <- reader.GetOrdinal "Column483"
      ``ordinal_Column484`` <- reader.GetOrdinal "Column484"
      ``ordinal_Column485`` <- reader.GetOrdinal "Column485"
      ``ordinal_Column486`` <- reader.GetOrdinal "Column486"
      ``ordinal_Column487`` <- reader.GetOrdinal "Column487"
      ``ordinal_Column488`` <- reader.GetOrdinal "Column488"
      ``ordinal_Column489`` <- reader.GetOrdinal "Column489"
      ``ordinal_Column490`` <- reader.GetOrdinal "Column490"
      ``ordinal_Column491`` <- reader.GetOrdinal "Column491"
      ``ordinal_Column492`` <- reader.GetOrdinal "Column492"
      ``ordinal_Column493`` <- reader.GetOrdinal "Column493"
      ``ordinal_Column494`` <- reader.GetOrdinal "Column494"
      ``ordinal_Column495`` <- reader.GetOrdinal "Column495"
      ``ordinal_Column496`` <- reader.GetOrdinal "Column496"
      ``ordinal_Column497`` <- reader.GetOrdinal "Column497"
      ``ordinal_Column498`` <- reader.GetOrdinal "Column498"
      ``ordinal_Column499`` <- reader.GetOrdinal "Column499"
      ``ordinal_Column500`` <- reader.GetOrdinal "Column500"
      ``ordinal_Column501`` <- reader.GetOrdinal "Column501"
      ``ordinal_Column502`` <- reader.GetOrdinal "Column502"
      ``ordinal_Column503`` <- reader.GetOrdinal "Column503"
      ``ordinal_Column504`` <- reader.GetOrdinal "Column504"
      ``ordinal_Column505`` <- reader.GetOrdinal "Column505"
      ``ordinal_Column506`` <- reader.GetOrdinal "Column506"
      ``ordinal_Column507`` <- reader.GetOrdinal "Column507"
      ``ordinal_Column508`` <- reader.GetOrdinal "Column508"
      ``ordinal_Column509`` <- reader.GetOrdinal "Column509"
      ``ordinal_Column510`` <- reader.GetOrdinal "Column510"
      ``ordinal_Column511`` <- reader.GetOrdinal "Column511"
      ``ordinal_Column512`` <- reader.GetOrdinal "Column512"
      ``ordinal_Column513`` <- reader.GetOrdinal "Column513"
      ``ordinal_Column514`` <- reader.GetOrdinal "Column514"
      ``ordinal_Column515`` <- reader.GetOrdinal "Column515"
      ``ordinal_Column516`` <- reader.GetOrdinal "Column516"
      ``ordinal_Column517`` <- reader.GetOrdinal "Column517"
      ``ordinal_Column518`` <- reader.GetOrdinal "Column518"
      ``ordinal_Column519`` <- reader.GetOrdinal "Column519"
      ``ordinal_Column520`` <- reader.GetOrdinal "Column520"
      ``ordinal_Column521`` <- reader.GetOrdinal "Column521"
      ``ordinal_Column522`` <- reader.GetOrdinal "Column522"
      ``ordinal_Column523`` <- reader.GetOrdinal "Column523"
      ``ordinal_Column524`` <- reader.GetOrdinal "Column524"
      ``ordinal_Column525`` <- reader.GetOrdinal "Column525"
      ``ordinal_Column526`` <- reader.GetOrdinal "Column526"
      ``ordinal_Column527`` <- reader.GetOrdinal "Column527"
      ``ordinal_Column528`` <- reader.GetOrdinal "Column528"
      ``ordinal_Column529`` <- reader.GetOrdinal "Column529"
      ``ordinal_Column530`` <- reader.GetOrdinal "Column530"
      ``ordinal_Column531`` <- reader.GetOrdinal "Column531"
      ``ordinal_Column532`` <- reader.GetOrdinal "Column532"
      ``ordinal_Column533`` <- reader.GetOrdinal "Column533"
      ``ordinal_Column534`` <- reader.GetOrdinal "Column534"
      ``ordinal_Column535`` <- reader.GetOrdinal "Column535"
      ``ordinal_Column536`` <- reader.GetOrdinal "Column536"
      ``ordinal_Column537`` <- reader.GetOrdinal "Column537"
      ``ordinal_Column538`` <- reader.GetOrdinal "Column538"
      ``ordinal_Column539`` <- reader.GetOrdinal "Column539"
      ``ordinal_Column540`` <- reader.GetOrdinal "Column540"
      ``ordinal_Column541`` <- reader.GetOrdinal "Column541"
      ``ordinal_Column542`` <- reader.GetOrdinal "Column542"
      ``ordinal_Column543`` <- reader.GetOrdinal "Column543"
      ``ordinal_Column544`` <- reader.GetOrdinal "Column544"
      ``ordinal_Column545`` <- reader.GetOrdinal "Column545"
      ``ordinal_Column546`` <- reader.GetOrdinal "Column546"
      ``ordinal_Column547`` <- reader.GetOrdinal "Column547"
      ``ordinal_Column548`` <- reader.GetOrdinal "Column548"
      ``ordinal_Column549`` <- reader.GetOrdinal "Column549"
      ``ordinal_Column550`` <- reader.GetOrdinal "Column550"
      ``ordinal_Column551`` <- reader.GetOrdinal "Column551"
      ``ordinal_Column552`` <- reader.GetOrdinal "Column552"
      ``ordinal_Column553`` <- reader.GetOrdinal "Column553"
      ``ordinal_Column554`` <- reader.GetOrdinal "Column554"
      ``ordinal_Column555`` <- reader.GetOrdinal "Column555"
      ``ordinal_Column556`` <- reader.GetOrdinal "Column556"
      ``ordinal_Column557`` <- reader.GetOrdinal "Column557"
      ``ordinal_Column558`` <- reader.GetOrdinal "Column558"
      ``ordinal_Column559`` <- reader.GetOrdinal "Column559"
      ``ordinal_Column560`` <- reader.GetOrdinal "Column560"
      ``ordinal_Column561`` <- reader.GetOrdinal "Column561"
      ``ordinal_Column562`` <- reader.GetOrdinal "Column562"
      ``ordinal_Column563`` <- reader.GetOrdinal "Column563"
      ``ordinal_Column564`` <- reader.GetOrdinal "Column564"
      ``ordinal_Column565`` <- reader.GetOrdinal "Column565"
      ``ordinal_Column566`` <- reader.GetOrdinal "Column566"
      ``ordinal_Column567`` <- reader.GetOrdinal "Column567"
      ``ordinal_Column568`` <- reader.GetOrdinal "Column568"
      ``ordinal_Column569`` <- reader.GetOrdinal "Column569"
      ``ordinal_Column570`` <- reader.GetOrdinal "Column570"
      ``ordinal_Column571`` <- reader.GetOrdinal "Column571"
      ``ordinal_Column572`` <- reader.GetOrdinal "Column572"
      ``ordinal_Column573`` <- reader.GetOrdinal "Column573"
      ``ordinal_Column574`` <- reader.GetOrdinal "Column574"
      ``ordinal_Column575`` <- reader.GetOrdinal "Column575"
      ``ordinal_Column576`` <- reader.GetOrdinal "Column576"
      ``ordinal_Column577`` <- reader.GetOrdinal "Column577"
      ``ordinal_Column578`` <- reader.GetOrdinal "Column578"
      ``ordinal_Column579`` <- reader.GetOrdinal "Column579"
      ``ordinal_Column580`` <- reader.GetOrdinal "Column580"
      ``ordinal_Column581`` <- reader.GetOrdinal "Column581"
      ``ordinal_Column582`` <- reader.GetOrdinal "Column582"
      ``ordinal_Column583`` <- reader.GetOrdinal "Column583"
      ``ordinal_Column584`` <- reader.GetOrdinal "Column584"
      ``ordinal_Column585`` <- reader.GetOrdinal "Column585"
      ``ordinal_Column586`` <- reader.GetOrdinal "Column586"
      ``ordinal_Column587`` <- reader.GetOrdinal "Column587"
      ``ordinal_Column588`` <- reader.GetOrdinal "Column588"
      ``ordinal_Column589`` <- reader.GetOrdinal "Column589"
      ``ordinal_Column590`` <- reader.GetOrdinal "Column590"
      ``ordinal_Column591`` <- reader.GetOrdinal "Column591"
      ``ordinal_Column592`` <- reader.GetOrdinal "Column592"
      ``ordinal_Column593`` <- reader.GetOrdinal "Column593"
      ``ordinal_Column594`` <- reader.GetOrdinal "Column594"
      ``ordinal_Column595`` <- reader.GetOrdinal "Column595"
      ``ordinal_Column596`` <- reader.GetOrdinal "Column596"
      ``ordinal_Column597`` <- reader.GetOrdinal "Column597"
      ``ordinal_Column598`` <- reader.GetOrdinal "Column598"
      ``ordinal_Column599`` <- reader.GetOrdinal "Column599"
      ``ordinal_Column600`` <- reader.GetOrdinal "Column600"

    let getItem (reader: SqlDataReader) =
      let ``Column1`` = if reader.IsDBNull ``ordinal_Column1`` then None else reader.GetInt32 ``ordinal_Column1`` |> Some
      let ``Column2`` = if reader.IsDBNull ``ordinal_Column2`` then None else reader.GetInt32 ``ordinal_Column2`` |> Some
      let ``Column3`` = if reader.IsDBNull ``ordinal_Column3`` then None else reader.GetInt32 ``ordinal_Column3`` |> Some
      let ``Column4`` = if reader.IsDBNull ``ordinal_Column4`` then None else reader.GetInt32 ``ordinal_Column4`` |> Some
      let ``Column5`` = if reader.IsDBNull ``ordinal_Column5`` then None else reader.GetInt32 ``ordinal_Column5`` |> Some
      let ``Column6`` = if reader.IsDBNull ``ordinal_Column6`` then None else reader.GetInt32 ``ordinal_Column6`` |> Some
      let ``Column7`` = if reader.IsDBNull ``ordinal_Column7`` then None else reader.GetInt32 ``ordinal_Column7`` |> Some
      let ``Column8`` = if reader.IsDBNull ``ordinal_Column8`` then None else reader.GetInt32 ``ordinal_Column8`` |> Some
      let ``Column9`` = if reader.IsDBNull ``ordinal_Column9`` then None else reader.GetInt32 ``ordinal_Column9`` |> Some
      let ``Column10`` = if reader.IsDBNull ``ordinal_Column10`` then None else reader.GetInt32 ``ordinal_Column10`` |> Some
      let ``Column11`` = if reader.IsDBNull ``ordinal_Column11`` then None else reader.GetInt32 ``ordinal_Column11`` |> Some
      let ``Column12`` = if reader.IsDBNull ``ordinal_Column12`` then None else reader.GetInt32 ``ordinal_Column12`` |> Some
      let ``Column13`` = if reader.IsDBNull ``ordinal_Column13`` then None else reader.GetInt32 ``ordinal_Column13`` |> Some
      let ``Column14`` = if reader.IsDBNull ``ordinal_Column14`` then None else reader.GetInt32 ``ordinal_Column14`` |> Some
      let ``Column15`` = if reader.IsDBNull ``ordinal_Column15`` then None else reader.GetInt32 ``ordinal_Column15`` |> Some
      let ``Column16`` = if reader.IsDBNull ``ordinal_Column16`` then None else reader.GetInt32 ``ordinal_Column16`` |> Some
      let ``Column17`` = if reader.IsDBNull ``ordinal_Column17`` then None else reader.GetInt32 ``ordinal_Column17`` |> Some
      let ``Column18`` = if reader.IsDBNull ``ordinal_Column18`` then None else reader.GetInt32 ``ordinal_Column18`` |> Some
      let ``Column19`` = if reader.IsDBNull ``ordinal_Column19`` then None else reader.GetInt32 ``ordinal_Column19`` |> Some
      let ``Column20`` = if reader.IsDBNull ``ordinal_Column20`` then None else reader.GetInt32 ``ordinal_Column20`` |> Some
      let ``Column21`` = if reader.IsDBNull ``ordinal_Column21`` then None else reader.GetInt32 ``ordinal_Column21`` |> Some
      let ``Column22`` = if reader.IsDBNull ``ordinal_Column22`` then None else reader.GetInt32 ``ordinal_Column22`` |> Some
      let ``Column23`` = if reader.IsDBNull ``ordinal_Column23`` then None else reader.GetInt32 ``ordinal_Column23`` |> Some
      let ``Column24`` = if reader.IsDBNull ``ordinal_Column24`` then None else reader.GetInt32 ``ordinal_Column24`` |> Some
      let ``Column25`` = if reader.IsDBNull ``ordinal_Column25`` then None else reader.GetInt32 ``ordinal_Column25`` |> Some
      let ``Column26`` = if reader.IsDBNull ``ordinal_Column26`` then None else reader.GetInt32 ``ordinal_Column26`` |> Some
      let ``Column27`` = if reader.IsDBNull ``ordinal_Column27`` then None else reader.GetInt32 ``ordinal_Column27`` |> Some
      let ``Column28`` = if reader.IsDBNull ``ordinal_Column28`` then None else reader.GetInt32 ``ordinal_Column28`` |> Some
      let ``Column29`` = if reader.IsDBNull ``ordinal_Column29`` then None else reader.GetInt32 ``ordinal_Column29`` |> Some
      let ``Column30`` = if reader.IsDBNull ``ordinal_Column30`` then None else reader.GetInt32 ``ordinal_Column30`` |> Some
      let ``Column31`` = if reader.IsDBNull ``ordinal_Column31`` then None else reader.GetInt32 ``ordinal_Column31`` |> Some
      let ``Column32`` = if reader.IsDBNull ``ordinal_Column32`` then None else reader.GetInt32 ``ordinal_Column32`` |> Some
      let ``Column33`` = if reader.IsDBNull ``ordinal_Column33`` then None else reader.GetInt32 ``ordinal_Column33`` |> Some
      let ``Column34`` = if reader.IsDBNull ``ordinal_Column34`` then None else reader.GetInt32 ``ordinal_Column34`` |> Some
      let ``Column35`` = if reader.IsDBNull ``ordinal_Column35`` then None else reader.GetInt32 ``ordinal_Column35`` |> Some
      let ``Column36`` = if reader.IsDBNull ``ordinal_Column36`` then None else reader.GetInt32 ``ordinal_Column36`` |> Some
      let ``Column37`` = if reader.IsDBNull ``ordinal_Column37`` then None else reader.GetInt32 ``ordinal_Column37`` |> Some
      let ``Column38`` = if reader.IsDBNull ``ordinal_Column38`` then None else reader.GetInt32 ``ordinal_Column38`` |> Some
      let ``Column39`` = if reader.IsDBNull ``ordinal_Column39`` then None else reader.GetInt32 ``ordinal_Column39`` |> Some
      let ``Column40`` = if reader.IsDBNull ``ordinal_Column40`` then None else reader.GetInt32 ``ordinal_Column40`` |> Some
      let ``Column41`` = if reader.IsDBNull ``ordinal_Column41`` then None else reader.GetInt32 ``ordinal_Column41`` |> Some
      let ``Column42`` = if reader.IsDBNull ``ordinal_Column42`` then None else reader.GetInt32 ``ordinal_Column42`` |> Some
      let ``Column43`` = if reader.IsDBNull ``ordinal_Column43`` then None else reader.GetInt32 ``ordinal_Column43`` |> Some
      let ``Column44`` = if reader.IsDBNull ``ordinal_Column44`` then None else reader.GetInt32 ``ordinal_Column44`` |> Some
      let ``Column45`` = if reader.IsDBNull ``ordinal_Column45`` then None else reader.GetInt32 ``ordinal_Column45`` |> Some
      let ``Column46`` = if reader.IsDBNull ``ordinal_Column46`` then None else reader.GetInt32 ``ordinal_Column46`` |> Some
      let ``Column47`` = if reader.IsDBNull ``ordinal_Column47`` then None else reader.GetInt32 ``ordinal_Column47`` |> Some
      let ``Column48`` = if reader.IsDBNull ``ordinal_Column48`` then None else reader.GetInt32 ``ordinal_Column48`` |> Some
      let ``Column49`` = if reader.IsDBNull ``ordinal_Column49`` then None else reader.GetInt32 ``ordinal_Column49`` |> Some
      let ``Column50`` = if reader.IsDBNull ``ordinal_Column50`` then None else reader.GetInt32 ``ordinal_Column50`` |> Some
      let ``Column51`` = if reader.IsDBNull ``ordinal_Column51`` then None else reader.GetInt32 ``ordinal_Column51`` |> Some
      let ``Column52`` = if reader.IsDBNull ``ordinal_Column52`` then None else reader.GetInt32 ``ordinal_Column52`` |> Some
      let ``Column53`` = if reader.IsDBNull ``ordinal_Column53`` then None else reader.GetInt32 ``ordinal_Column53`` |> Some
      let ``Column54`` = if reader.IsDBNull ``ordinal_Column54`` then None else reader.GetInt32 ``ordinal_Column54`` |> Some
      let ``Column55`` = if reader.IsDBNull ``ordinal_Column55`` then None else reader.GetInt32 ``ordinal_Column55`` |> Some
      let ``Column56`` = if reader.IsDBNull ``ordinal_Column56`` then None else reader.GetInt32 ``ordinal_Column56`` |> Some
      let ``Column57`` = if reader.IsDBNull ``ordinal_Column57`` then None else reader.GetInt32 ``ordinal_Column57`` |> Some
      let ``Column58`` = if reader.IsDBNull ``ordinal_Column58`` then None else reader.GetInt32 ``ordinal_Column58`` |> Some
      let ``Column59`` = if reader.IsDBNull ``ordinal_Column59`` then None else reader.GetInt32 ``ordinal_Column59`` |> Some
      let ``Column60`` = if reader.IsDBNull ``ordinal_Column60`` then None else reader.GetInt32 ``ordinal_Column60`` |> Some
      let ``Column61`` = if reader.IsDBNull ``ordinal_Column61`` then None else reader.GetInt32 ``ordinal_Column61`` |> Some
      let ``Column62`` = if reader.IsDBNull ``ordinal_Column62`` then None else reader.GetInt32 ``ordinal_Column62`` |> Some
      let ``Column63`` = if reader.IsDBNull ``ordinal_Column63`` then None else reader.GetInt32 ``ordinal_Column63`` |> Some
      let ``Column64`` = if reader.IsDBNull ``ordinal_Column64`` then None else reader.GetInt32 ``ordinal_Column64`` |> Some
      let ``Column65`` = if reader.IsDBNull ``ordinal_Column65`` then None else reader.GetInt32 ``ordinal_Column65`` |> Some
      let ``Column66`` = if reader.IsDBNull ``ordinal_Column66`` then None else reader.GetInt32 ``ordinal_Column66`` |> Some
      let ``Column67`` = if reader.IsDBNull ``ordinal_Column67`` then None else reader.GetInt32 ``ordinal_Column67`` |> Some
      let ``Column68`` = if reader.IsDBNull ``ordinal_Column68`` then None else reader.GetInt32 ``ordinal_Column68`` |> Some
      let ``Column69`` = if reader.IsDBNull ``ordinal_Column69`` then None else reader.GetInt32 ``ordinal_Column69`` |> Some
      let ``Column70`` = if reader.IsDBNull ``ordinal_Column70`` then None else reader.GetInt32 ``ordinal_Column70`` |> Some
      let ``Column71`` = if reader.IsDBNull ``ordinal_Column71`` then None else reader.GetInt32 ``ordinal_Column71`` |> Some
      let ``Column72`` = if reader.IsDBNull ``ordinal_Column72`` then None else reader.GetInt32 ``ordinal_Column72`` |> Some
      let ``Column73`` = if reader.IsDBNull ``ordinal_Column73`` then None else reader.GetInt32 ``ordinal_Column73`` |> Some
      let ``Column74`` = if reader.IsDBNull ``ordinal_Column74`` then None else reader.GetInt32 ``ordinal_Column74`` |> Some
      let ``Column75`` = if reader.IsDBNull ``ordinal_Column75`` then None else reader.GetInt32 ``ordinal_Column75`` |> Some
      let ``Column76`` = if reader.IsDBNull ``ordinal_Column76`` then None else reader.GetInt32 ``ordinal_Column76`` |> Some
      let ``Column77`` = if reader.IsDBNull ``ordinal_Column77`` then None else reader.GetInt32 ``ordinal_Column77`` |> Some
      let ``Column78`` = if reader.IsDBNull ``ordinal_Column78`` then None else reader.GetInt32 ``ordinal_Column78`` |> Some
      let ``Column79`` = if reader.IsDBNull ``ordinal_Column79`` then None else reader.GetInt32 ``ordinal_Column79`` |> Some
      let ``Column80`` = if reader.IsDBNull ``ordinal_Column80`` then None else reader.GetInt32 ``ordinal_Column80`` |> Some
      let ``Column81`` = if reader.IsDBNull ``ordinal_Column81`` then None else reader.GetInt32 ``ordinal_Column81`` |> Some
      let ``Column82`` = if reader.IsDBNull ``ordinal_Column82`` then None else reader.GetInt32 ``ordinal_Column82`` |> Some
      let ``Column83`` = if reader.IsDBNull ``ordinal_Column83`` then None else reader.GetInt32 ``ordinal_Column83`` |> Some
      let ``Column84`` = if reader.IsDBNull ``ordinal_Column84`` then None else reader.GetInt32 ``ordinal_Column84`` |> Some
      let ``Column85`` = if reader.IsDBNull ``ordinal_Column85`` then None else reader.GetInt32 ``ordinal_Column85`` |> Some
      let ``Column86`` = if reader.IsDBNull ``ordinal_Column86`` then None else reader.GetInt32 ``ordinal_Column86`` |> Some
      let ``Column87`` = if reader.IsDBNull ``ordinal_Column87`` then None else reader.GetInt32 ``ordinal_Column87`` |> Some
      let ``Column88`` = if reader.IsDBNull ``ordinal_Column88`` then None else reader.GetInt32 ``ordinal_Column88`` |> Some
      let ``Column89`` = if reader.IsDBNull ``ordinal_Column89`` then None else reader.GetInt32 ``ordinal_Column89`` |> Some
      let ``Column90`` = if reader.IsDBNull ``ordinal_Column90`` then None else reader.GetInt32 ``ordinal_Column90`` |> Some
      let ``Column91`` = if reader.IsDBNull ``ordinal_Column91`` then None else reader.GetInt32 ``ordinal_Column91`` |> Some
      let ``Column92`` = if reader.IsDBNull ``ordinal_Column92`` then None else reader.GetInt32 ``ordinal_Column92`` |> Some
      let ``Column93`` = if reader.IsDBNull ``ordinal_Column93`` then None else reader.GetInt32 ``ordinal_Column93`` |> Some
      let ``Column94`` = if reader.IsDBNull ``ordinal_Column94`` then None else reader.GetInt32 ``ordinal_Column94`` |> Some
      let ``Column95`` = if reader.IsDBNull ``ordinal_Column95`` then None else reader.GetInt32 ``ordinal_Column95`` |> Some
      let ``Column96`` = if reader.IsDBNull ``ordinal_Column96`` then None else reader.GetInt32 ``ordinal_Column96`` |> Some
      let ``Column97`` = if reader.IsDBNull ``ordinal_Column97`` then None else reader.GetInt32 ``ordinal_Column97`` |> Some
      let ``Column98`` = if reader.IsDBNull ``ordinal_Column98`` then None else reader.GetInt32 ``ordinal_Column98`` |> Some
      let ``Column99`` = if reader.IsDBNull ``ordinal_Column99`` then None else reader.GetInt32 ``ordinal_Column99`` |> Some
      let ``Column100`` = if reader.IsDBNull ``ordinal_Column100`` then None else reader.GetInt32 ``ordinal_Column100`` |> Some
      let ``Column101`` = if reader.IsDBNull ``ordinal_Column101`` then None else reader.GetInt32 ``ordinal_Column101`` |> Some
      let ``Column102`` = if reader.IsDBNull ``ordinal_Column102`` then None else reader.GetInt32 ``ordinal_Column102`` |> Some
      let ``Column103`` = if reader.IsDBNull ``ordinal_Column103`` then None else reader.GetInt32 ``ordinal_Column103`` |> Some
      let ``Column104`` = if reader.IsDBNull ``ordinal_Column104`` then None else reader.GetInt32 ``ordinal_Column104`` |> Some
      let ``Column105`` = if reader.IsDBNull ``ordinal_Column105`` then None else reader.GetInt32 ``ordinal_Column105`` |> Some
      let ``Column106`` = if reader.IsDBNull ``ordinal_Column106`` then None else reader.GetInt32 ``ordinal_Column106`` |> Some
      let ``Column107`` = if reader.IsDBNull ``ordinal_Column107`` then None else reader.GetInt32 ``ordinal_Column107`` |> Some
      let ``Column108`` = if reader.IsDBNull ``ordinal_Column108`` then None else reader.GetInt32 ``ordinal_Column108`` |> Some
      let ``Column109`` = if reader.IsDBNull ``ordinal_Column109`` then None else reader.GetInt32 ``ordinal_Column109`` |> Some
      let ``Column110`` = if reader.IsDBNull ``ordinal_Column110`` then None else reader.GetInt32 ``ordinal_Column110`` |> Some
      let ``Column111`` = if reader.IsDBNull ``ordinal_Column111`` then None else reader.GetInt32 ``ordinal_Column111`` |> Some
      let ``Column112`` = if reader.IsDBNull ``ordinal_Column112`` then None else reader.GetInt32 ``ordinal_Column112`` |> Some
      let ``Column113`` = if reader.IsDBNull ``ordinal_Column113`` then None else reader.GetInt32 ``ordinal_Column113`` |> Some
      let ``Column114`` = if reader.IsDBNull ``ordinal_Column114`` then None else reader.GetInt32 ``ordinal_Column114`` |> Some
      let ``Column115`` = if reader.IsDBNull ``ordinal_Column115`` then None else reader.GetInt32 ``ordinal_Column115`` |> Some
      let ``Column116`` = if reader.IsDBNull ``ordinal_Column116`` then None else reader.GetInt32 ``ordinal_Column116`` |> Some
      let ``Column117`` = if reader.IsDBNull ``ordinal_Column117`` then None else reader.GetInt32 ``ordinal_Column117`` |> Some
      let ``Column118`` = if reader.IsDBNull ``ordinal_Column118`` then None else reader.GetInt32 ``ordinal_Column118`` |> Some
      let ``Column119`` = if reader.IsDBNull ``ordinal_Column119`` then None else reader.GetInt32 ``ordinal_Column119`` |> Some
      let ``Column120`` = if reader.IsDBNull ``ordinal_Column120`` then None else reader.GetInt32 ``ordinal_Column120`` |> Some
      let ``Column121`` = if reader.IsDBNull ``ordinal_Column121`` then None else reader.GetInt32 ``ordinal_Column121`` |> Some
      let ``Column122`` = if reader.IsDBNull ``ordinal_Column122`` then None else reader.GetInt32 ``ordinal_Column122`` |> Some
      let ``Column123`` = if reader.IsDBNull ``ordinal_Column123`` then None else reader.GetInt32 ``ordinal_Column123`` |> Some
      let ``Column124`` = if reader.IsDBNull ``ordinal_Column124`` then None else reader.GetInt32 ``ordinal_Column124`` |> Some
      let ``Column125`` = if reader.IsDBNull ``ordinal_Column125`` then None else reader.GetInt32 ``ordinal_Column125`` |> Some
      let ``Column126`` = if reader.IsDBNull ``ordinal_Column126`` then None else reader.GetInt32 ``ordinal_Column126`` |> Some
      let ``Column127`` = if reader.IsDBNull ``ordinal_Column127`` then None else reader.GetInt32 ``ordinal_Column127`` |> Some
      let ``Column128`` = if reader.IsDBNull ``ordinal_Column128`` then None else reader.GetInt32 ``ordinal_Column128`` |> Some
      let ``Column129`` = if reader.IsDBNull ``ordinal_Column129`` then None else reader.GetInt32 ``ordinal_Column129`` |> Some
      let ``Column130`` = if reader.IsDBNull ``ordinal_Column130`` then None else reader.GetInt32 ``ordinal_Column130`` |> Some
      let ``Column131`` = if reader.IsDBNull ``ordinal_Column131`` then None else reader.GetInt32 ``ordinal_Column131`` |> Some
      let ``Column132`` = if reader.IsDBNull ``ordinal_Column132`` then None else reader.GetInt32 ``ordinal_Column132`` |> Some
      let ``Column133`` = if reader.IsDBNull ``ordinal_Column133`` then None else reader.GetInt32 ``ordinal_Column133`` |> Some
      let ``Column134`` = if reader.IsDBNull ``ordinal_Column134`` then None else reader.GetInt32 ``ordinal_Column134`` |> Some
      let ``Column135`` = if reader.IsDBNull ``ordinal_Column135`` then None else reader.GetInt32 ``ordinal_Column135`` |> Some
      let ``Column136`` = if reader.IsDBNull ``ordinal_Column136`` then None else reader.GetInt32 ``ordinal_Column136`` |> Some
      let ``Column137`` = if reader.IsDBNull ``ordinal_Column137`` then None else reader.GetInt32 ``ordinal_Column137`` |> Some
      let ``Column138`` = if reader.IsDBNull ``ordinal_Column138`` then None else reader.GetInt32 ``ordinal_Column138`` |> Some
      let ``Column139`` = if reader.IsDBNull ``ordinal_Column139`` then None else reader.GetInt32 ``ordinal_Column139`` |> Some
      let ``Column140`` = if reader.IsDBNull ``ordinal_Column140`` then None else reader.GetInt32 ``ordinal_Column140`` |> Some
      let ``Column141`` = if reader.IsDBNull ``ordinal_Column141`` then None else reader.GetInt32 ``ordinal_Column141`` |> Some
      let ``Column142`` = if reader.IsDBNull ``ordinal_Column142`` then None else reader.GetInt32 ``ordinal_Column142`` |> Some
      let ``Column143`` = if reader.IsDBNull ``ordinal_Column143`` then None else reader.GetInt32 ``ordinal_Column143`` |> Some
      let ``Column144`` = if reader.IsDBNull ``ordinal_Column144`` then None else reader.GetInt32 ``ordinal_Column144`` |> Some
      let ``Column145`` = if reader.IsDBNull ``ordinal_Column145`` then None else reader.GetInt32 ``ordinal_Column145`` |> Some
      let ``Column146`` = if reader.IsDBNull ``ordinal_Column146`` then None else reader.GetInt32 ``ordinal_Column146`` |> Some
      let ``Column147`` = if reader.IsDBNull ``ordinal_Column147`` then None else reader.GetInt32 ``ordinal_Column147`` |> Some
      let ``Column148`` = if reader.IsDBNull ``ordinal_Column148`` then None else reader.GetInt32 ``ordinal_Column148`` |> Some
      let ``Column149`` = if reader.IsDBNull ``ordinal_Column149`` then None else reader.GetInt32 ``ordinal_Column149`` |> Some
      let ``Column150`` = if reader.IsDBNull ``ordinal_Column150`` then None else reader.GetInt32 ``ordinal_Column150`` |> Some
      let ``Column151`` = if reader.IsDBNull ``ordinal_Column151`` then None else reader.GetInt32 ``ordinal_Column151`` |> Some
      let ``Column152`` = if reader.IsDBNull ``ordinal_Column152`` then None else reader.GetInt32 ``ordinal_Column152`` |> Some
      let ``Column153`` = if reader.IsDBNull ``ordinal_Column153`` then None else reader.GetInt32 ``ordinal_Column153`` |> Some
      let ``Column154`` = if reader.IsDBNull ``ordinal_Column154`` then None else reader.GetInt32 ``ordinal_Column154`` |> Some
      let ``Column155`` = if reader.IsDBNull ``ordinal_Column155`` then None else reader.GetInt32 ``ordinal_Column155`` |> Some
      let ``Column156`` = if reader.IsDBNull ``ordinal_Column156`` then None else reader.GetInt32 ``ordinal_Column156`` |> Some
      let ``Column157`` = if reader.IsDBNull ``ordinal_Column157`` then None else reader.GetInt32 ``ordinal_Column157`` |> Some
      let ``Column158`` = if reader.IsDBNull ``ordinal_Column158`` then None else reader.GetInt32 ``ordinal_Column158`` |> Some
      let ``Column159`` = if reader.IsDBNull ``ordinal_Column159`` then None else reader.GetInt32 ``ordinal_Column159`` |> Some
      let ``Column160`` = if reader.IsDBNull ``ordinal_Column160`` then None else reader.GetInt32 ``ordinal_Column160`` |> Some
      let ``Column161`` = if reader.IsDBNull ``ordinal_Column161`` then None else reader.GetInt32 ``ordinal_Column161`` |> Some
      let ``Column162`` = if reader.IsDBNull ``ordinal_Column162`` then None else reader.GetInt32 ``ordinal_Column162`` |> Some
      let ``Column163`` = if reader.IsDBNull ``ordinal_Column163`` then None else reader.GetInt32 ``ordinal_Column163`` |> Some
      let ``Column164`` = if reader.IsDBNull ``ordinal_Column164`` then None else reader.GetInt32 ``ordinal_Column164`` |> Some
      let ``Column165`` = if reader.IsDBNull ``ordinal_Column165`` then None else reader.GetInt32 ``ordinal_Column165`` |> Some
      let ``Column166`` = if reader.IsDBNull ``ordinal_Column166`` then None else reader.GetInt32 ``ordinal_Column166`` |> Some
      let ``Column167`` = if reader.IsDBNull ``ordinal_Column167`` then None else reader.GetInt32 ``ordinal_Column167`` |> Some
      let ``Column168`` = if reader.IsDBNull ``ordinal_Column168`` then None else reader.GetInt32 ``ordinal_Column168`` |> Some
      let ``Column169`` = if reader.IsDBNull ``ordinal_Column169`` then None else reader.GetInt32 ``ordinal_Column169`` |> Some
      let ``Column170`` = if reader.IsDBNull ``ordinal_Column170`` then None else reader.GetInt32 ``ordinal_Column170`` |> Some
      let ``Column171`` = if reader.IsDBNull ``ordinal_Column171`` then None else reader.GetInt32 ``ordinal_Column171`` |> Some
      let ``Column172`` = if reader.IsDBNull ``ordinal_Column172`` then None else reader.GetInt32 ``ordinal_Column172`` |> Some
      let ``Column173`` = if reader.IsDBNull ``ordinal_Column173`` then None else reader.GetInt32 ``ordinal_Column173`` |> Some
      let ``Column174`` = if reader.IsDBNull ``ordinal_Column174`` then None else reader.GetInt32 ``ordinal_Column174`` |> Some
      let ``Column175`` = if reader.IsDBNull ``ordinal_Column175`` then None else reader.GetInt32 ``ordinal_Column175`` |> Some
      let ``Column176`` = if reader.IsDBNull ``ordinal_Column176`` then None else reader.GetInt32 ``ordinal_Column176`` |> Some
      let ``Column177`` = if reader.IsDBNull ``ordinal_Column177`` then None else reader.GetInt32 ``ordinal_Column177`` |> Some
      let ``Column178`` = if reader.IsDBNull ``ordinal_Column178`` then None else reader.GetInt32 ``ordinal_Column178`` |> Some
      let ``Column179`` = if reader.IsDBNull ``ordinal_Column179`` then None else reader.GetInt32 ``ordinal_Column179`` |> Some
      let ``Column180`` = if reader.IsDBNull ``ordinal_Column180`` then None else reader.GetInt32 ``ordinal_Column180`` |> Some
      let ``Column181`` = if reader.IsDBNull ``ordinal_Column181`` then None else reader.GetInt32 ``ordinal_Column181`` |> Some
      let ``Column182`` = if reader.IsDBNull ``ordinal_Column182`` then None else reader.GetInt32 ``ordinal_Column182`` |> Some
      let ``Column183`` = if reader.IsDBNull ``ordinal_Column183`` then None else reader.GetInt32 ``ordinal_Column183`` |> Some
      let ``Column184`` = if reader.IsDBNull ``ordinal_Column184`` then None else reader.GetInt32 ``ordinal_Column184`` |> Some
      let ``Column185`` = if reader.IsDBNull ``ordinal_Column185`` then None else reader.GetInt32 ``ordinal_Column185`` |> Some
      let ``Column186`` = if reader.IsDBNull ``ordinal_Column186`` then None else reader.GetInt32 ``ordinal_Column186`` |> Some
      let ``Column187`` = if reader.IsDBNull ``ordinal_Column187`` then None else reader.GetInt32 ``ordinal_Column187`` |> Some
      let ``Column188`` = if reader.IsDBNull ``ordinal_Column188`` then None else reader.GetInt32 ``ordinal_Column188`` |> Some
      let ``Column189`` = if reader.IsDBNull ``ordinal_Column189`` then None else reader.GetInt32 ``ordinal_Column189`` |> Some
      let ``Column190`` = if reader.IsDBNull ``ordinal_Column190`` then None else reader.GetInt32 ``ordinal_Column190`` |> Some
      let ``Column191`` = if reader.IsDBNull ``ordinal_Column191`` then None else reader.GetInt32 ``ordinal_Column191`` |> Some
      let ``Column192`` = if reader.IsDBNull ``ordinal_Column192`` then None else reader.GetInt32 ``ordinal_Column192`` |> Some
      let ``Column193`` = if reader.IsDBNull ``ordinal_Column193`` then None else reader.GetInt32 ``ordinal_Column193`` |> Some
      let ``Column194`` = if reader.IsDBNull ``ordinal_Column194`` then None else reader.GetInt32 ``ordinal_Column194`` |> Some
      let ``Column195`` = if reader.IsDBNull ``ordinal_Column195`` then None else reader.GetInt32 ``ordinal_Column195`` |> Some
      let ``Column196`` = if reader.IsDBNull ``ordinal_Column196`` then None else reader.GetInt32 ``ordinal_Column196`` |> Some
      let ``Column197`` = if reader.IsDBNull ``ordinal_Column197`` then None else reader.GetInt32 ``ordinal_Column197`` |> Some
      let ``Column198`` = if reader.IsDBNull ``ordinal_Column198`` then None else reader.GetInt32 ``ordinal_Column198`` |> Some
      let ``Column199`` = if reader.IsDBNull ``ordinal_Column199`` then None else reader.GetInt32 ``ordinal_Column199`` |> Some
      let ``Column200`` = if reader.IsDBNull ``ordinal_Column200`` then None else reader.GetInt32 ``ordinal_Column200`` |> Some
      let ``Column201`` = if reader.IsDBNull ``ordinal_Column201`` then None else reader.GetInt32 ``ordinal_Column201`` |> Some
      let ``Column202`` = if reader.IsDBNull ``ordinal_Column202`` then None else reader.GetInt32 ``ordinal_Column202`` |> Some
      let ``Column203`` = if reader.IsDBNull ``ordinal_Column203`` then None else reader.GetInt32 ``ordinal_Column203`` |> Some
      let ``Column204`` = if reader.IsDBNull ``ordinal_Column204`` then None else reader.GetInt32 ``ordinal_Column204`` |> Some
      let ``Column205`` = if reader.IsDBNull ``ordinal_Column205`` then None else reader.GetInt32 ``ordinal_Column205`` |> Some
      let ``Column206`` = if reader.IsDBNull ``ordinal_Column206`` then None else reader.GetInt32 ``ordinal_Column206`` |> Some
      let ``Column207`` = if reader.IsDBNull ``ordinal_Column207`` then None else reader.GetInt32 ``ordinal_Column207`` |> Some
      let ``Column208`` = if reader.IsDBNull ``ordinal_Column208`` then None else reader.GetInt32 ``ordinal_Column208`` |> Some
      let ``Column209`` = if reader.IsDBNull ``ordinal_Column209`` then None else reader.GetInt32 ``ordinal_Column209`` |> Some
      let ``Column210`` = if reader.IsDBNull ``ordinal_Column210`` then None else reader.GetInt32 ``ordinal_Column210`` |> Some
      let ``Column211`` = if reader.IsDBNull ``ordinal_Column211`` then None else reader.GetInt32 ``ordinal_Column211`` |> Some
      let ``Column212`` = if reader.IsDBNull ``ordinal_Column212`` then None else reader.GetInt32 ``ordinal_Column212`` |> Some
      let ``Column213`` = if reader.IsDBNull ``ordinal_Column213`` then None else reader.GetInt32 ``ordinal_Column213`` |> Some
      let ``Column214`` = if reader.IsDBNull ``ordinal_Column214`` then None else reader.GetInt32 ``ordinal_Column214`` |> Some
      let ``Column215`` = if reader.IsDBNull ``ordinal_Column215`` then None else reader.GetInt32 ``ordinal_Column215`` |> Some
      let ``Column216`` = if reader.IsDBNull ``ordinal_Column216`` then None else reader.GetInt32 ``ordinal_Column216`` |> Some
      let ``Column217`` = if reader.IsDBNull ``ordinal_Column217`` then None else reader.GetInt32 ``ordinal_Column217`` |> Some
      let ``Column218`` = if reader.IsDBNull ``ordinal_Column218`` then None else reader.GetInt32 ``ordinal_Column218`` |> Some
      let ``Column219`` = if reader.IsDBNull ``ordinal_Column219`` then None else reader.GetInt32 ``ordinal_Column219`` |> Some
      let ``Column220`` = if reader.IsDBNull ``ordinal_Column220`` then None else reader.GetInt32 ``ordinal_Column220`` |> Some
      let ``Column221`` = if reader.IsDBNull ``ordinal_Column221`` then None else reader.GetInt32 ``ordinal_Column221`` |> Some
      let ``Column222`` = if reader.IsDBNull ``ordinal_Column222`` then None else reader.GetInt32 ``ordinal_Column222`` |> Some
      let ``Column223`` = if reader.IsDBNull ``ordinal_Column223`` then None else reader.GetInt32 ``ordinal_Column223`` |> Some
      let ``Column224`` = if reader.IsDBNull ``ordinal_Column224`` then None else reader.GetInt32 ``ordinal_Column224`` |> Some
      let ``Column225`` = if reader.IsDBNull ``ordinal_Column225`` then None else reader.GetInt32 ``ordinal_Column225`` |> Some
      let ``Column226`` = if reader.IsDBNull ``ordinal_Column226`` then None else reader.GetInt32 ``ordinal_Column226`` |> Some
      let ``Column227`` = if reader.IsDBNull ``ordinal_Column227`` then None else reader.GetInt32 ``ordinal_Column227`` |> Some
      let ``Column228`` = if reader.IsDBNull ``ordinal_Column228`` then None else reader.GetInt32 ``ordinal_Column228`` |> Some
      let ``Column229`` = if reader.IsDBNull ``ordinal_Column229`` then None else reader.GetInt32 ``ordinal_Column229`` |> Some
      let ``Column230`` = if reader.IsDBNull ``ordinal_Column230`` then None else reader.GetInt32 ``ordinal_Column230`` |> Some
      let ``Column231`` = if reader.IsDBNull ``ordinal_Column231`` then None else reader.GetInt32 ``ordinal_Column231`` |> Some
      let ``Column232`` = if reader.IsDBNull ``ordinal_Column232`` then None else reader.GetInt32 ``ordinal_Column232`` |> Some
      let ``Column233`` = if reader.IsDBNull ``ordinal_Column233`` then None else reader.GetInt32 ``ordinal_Column233`` |> Some
      let ``Column234`` = if reader.IsDBNull ``ordinal_Column234`` then None else reader.GetInt32 ``ordinal_Column234`` |> Some
      let ``Column235`` = if reader.IsDBNull ``ordinal_Column235`` then None else reader.GetInt32 ``ordinal_Column235`` |> Some
      let ``Column236`` = if reader.IsDBNull ``ordinal_Column236`` then None else reader.GetInt32 ``ordinal_Column236`` |> Some
      let ``Column237`` = if reader.IsDBNull ``ordinal_Column237`` then None else reader.GetInt32 ``ordinal_Column237`` |> Some
      let ``Column238`` = if reader.IsDBNull ``ordinal_Column238`` then None else reader.GetInt32 ``ordinal_Column238`` |> Some
      let ``Column239`` = if reader.IsDBNull ``ordinal_Column239`` then None else reader.GetInt32 ``ordinal_Column239`` |> Some
      let ``Column240`` = if reader.IsDBNull ``ordinal_Column240`` then None else reader.GetInt32 ``ordinal_Column240`` |> Some
      let ``Column241`` = if reader.IsDBNull ``ordinal_Column241`` then None else reader.GetInt32 ``ordinal_Column241`` |> Some
      let ``Column242`` = if reader.IsDBNull ``ordinal_Column242`` then None else reader.GetInt32 ``ordinal_Column242`` |> Some
      let ``Column243`` = if reader.IsDBNull ``ordinal_Column243`` then None else reader.GetInt32 ``ordinal_Column243`` |> Some
      let ``Column244`` = if reader.IsDBNull ``ordinal_Column244`` then None else reader.GetInt32 ``ordinal_Column244`` |> Some
      let ``Column245`` = if reader.IsDBNull ``ordinal_Column245`` then None else reader.GetInt32 ``ordinal_Column245`` |> Some
      let ``Column246`` = if reader.IsDBNull ``ordinal_Column246`` then None else reader.GetInt32 ``ordinal_Column246`` |> Some
      let ``Column247`` = if reader.IsDBNull ``ordinal_Column247`` then None else reader.GetInt32 ``ordinal_Column247`` |> Some
      let ``Column248`` = if reader.IsDBNull ``ordinal_Column248`` then None else reader.GetInt32 ``ordinal_Column248`` |> Some
      let ``Column249`` = if reader.IsDBNull ``ordinal_Column249`` then None else reader.GetInt32 ``ordinal_Column249`` |> Some
      let ``Column250`` = if reader.IsDBNull ``ordinal_Column250`` then None else reader.GetInt32 ``ordinal_Column250`` |> Some
      let ``Column251`` = if reader.IsDBNull ``ordinal_Column251`` then None else reader.GetInt32 ``ordinal_Column251`` |> Some
      let ``Column252`` = if reader.IsDBNull ``ordinal_Column252`` then None else reader.GetInt32 ``ordinal_Column252`` |> Some
      let ``Column253`` = if reader.IsDBNull ``ordinal_Column253`` then None else reader.GetInt32 ``ordinal_Column253`` |> Some
      let ``Column254`` = if reader.IsDBNull ``ordinal_Column254`` then None else reader.GetInt32 ``ordinal_Column254`` |> Some
      let ``Column255`` = if reader.IsDBNull ``ordinal_Column255`` then None else reader.GetInt32 ``ordinal_Column255`` |> Some
      let ``Column256`` = if reader.IsDBNull ``ordinal_Column256`` then None else reader.GetInt32 ``ordinal_Column256`` |> Some
      let ``Column257`` = if reader.IsDBNull ``ordinal_Column257`` then None else reader.GetInt32 ``ordinal_Column257`` |> Some
      let ``Column258`` = if reader.IsDBNull ``ordinal_Column258`` then None else reader.GetInt32 ``ordinal_Column258`` |> Some
      let ``Column259`` = if reader.IsDBNull ``ordinal_Column259`` then None else reader.GetInt32 ``ordinal_Column259`` |> Some
      let ``Column260`` = if reader.IsDBNull ``ordinal_Column260`` then None else reader.GetInt32 ``ordinal_Column260`` |> Some
      let ``Column261`` = if reader.IsDBNull ``ordinal_Column261`` then None else reader.GetInt32 ``ordinal_Column261`` |> Some
      let ``Column262`` = if reader.IsDBNull ``ordinal_Column262`` then None else reader.GetInt32 ``ordinal_Column262`` |> Some
      let ``Column263`` = if reader.IsDBNull ``ordinal_Column263`` then None else reader.GetInt32 ``ordinal_Column263`` |> Some
      let ``Column264`` = if reader.IsDBNull ``ordinal_Column264`` then None else reader.GetInt32 ``ordinal_Column264`` |> Some
      let ``Column265`` = if reader.IsDBNull ``ordinal_Column265`` then None else reader.GetInt32 ``ordinal_Column265`` |> Some
      let ``Column266`` = if reader.IsDBNull ``ordinal_Column266`` then None else reader.GetInt32 ``ordinal_Column266`` |> Some
      let ``Column267`` = if reader.IsDBNull ``ordinal_Column267`` then None else reader.GetInt32 ``ordinal_Column267`` |> Some
      let ``Column268`` = if reader.IsDBNull ``ordinal_Column268`` then None else reader.GetInt32 ``ordinal_Column268`` |> Some
      let ``Column269`` = if reader.IsDBNull ``ordinal_Column269`` then None else reader.GetInt32 ``ordinal_Column269`` |> Some
      let ``Column270`` = if reader.IsDBNull ``ordinal_Column270`` then None else reader.GetInt32 ``ordinal_Column270`` |> Some
      let ``Column271`` = if reader.IsDBNull ``ordinal_Column271`` then None else reader.GetInt32 ``ordinal_Column271`` |> Some
      let ``Column272`` = if reader.IsDBNull ``ordinal_Column272`` then None else reader.GetInt32 ``ordinal_Column272`` |> Some
      let ``Column273`` = if reader.IsDBNull ``ordinal_Column273`` then None else reader.GetInt32 ``ordinal_Column273`` |> Some
      let ``Column274`` = if reader.IsDBNull ``ordinal_Column274`` then None else reader.GetInt32 ``ordinal_Column274`` |> Some
      let ``Column275`` = if reader.IsDBNull ``ordinal_Column275`` then None else reader.GetInt32 ``ordinal_Column275`` |> Some
      let ``Column276`` = if reader.IsDBNull ``ordinal_Column276`` then None else reader.GetInt32 ``ordinal_Column276`` |> Some
      let ``Column277`` = if reader.IsDBNull ``ordinal_Column277`` then None else reader.GetInt32 ``ordinal_Column277`` |> Some
      let ``Column278`` = if reader.IsDBNull ``ordinal_Column278`` then None else reader.GetInt32 ``ordinal_Column278`` |> Some
      let ``Column279`` = if reader.IsDBNull ``ordinal_Column279`` then None else reader.GetInt32 ``ordinal_Column279`` |> Some
      let ``Column280`` = if reader.IsDBNull ``ordinal_Column280`` then None else reader.GetInt32 ``ordinal_Column280`` |> Some
      let ``Column281`` = if reader.IsDBNull ``ordinal_Column281`` then None else reader.GetInt32 ``ordinal_Column281`` |> Some
      let ``Column282`` = if reader.IsDBNull ``ordinal_Column282`` then None else reader.GetInt32 ``ordinal_Column282`` |> Some
      let ``Column283`` = if reader.IsDBNull ``ordinal_Column283`` then None else reader.GetInt32 ``ordinal_Column283`` |> Some
      let ``Column284`` = if reader.IsDBNull ``ordinal_Column284`` then None else reader.GetInt32 ``ordinal_Column284`` |> Some
      let ``Column285`` = if reader.IsDBNull ``ordinal_Column285`` then None else reader.GetInt32 ``ordinal_Column285`` |> Some
      let ``Column286`` = if reader.IsDBNull ``ordinal_Column286`` then None else reader.GetInt32 ``ordinal_Column286`` |> Some
      let ``Column287`` = if reader.IsDBNull ``ordinal_Column287`` then None else reader.GetInt32 ``ordinal_Column287`` |> Some
      let ``Column288`` = if reader.IsDBNull ``ordinal_Column288`` then None else reader.GetInt32 ``ordinal_Column288`` |> Some
      let ``Column289`` = if reader.IsDBNull ``ordinal_Column289`` then None else reader.GetInt32 ``ordinal_Column289`` |> Some
      let ``Column290`` = if reader.IsDBNull ``ordinal_Column290`` then None else reader.GetInt32 ``ordinal_Column290`` |> Some
      let ``Column291`` = if reader.IsDBNull ``ordinal_Column291`` then None else reader.GetInt32 ``ordinal_Column291`` |> Some
      let ``Column292`` = if reader.IsDBNull ``ordinal_Column292`` then None else reader.GetInt32 ``ordinal_Column292`` |> Some
      let ``Column293`` = if reader.IsDBNull ``ordinal_Column293`` then None else reader.GetInt32 ``ordinal_Column293`` |> Some
      let ``Column294`` = if reader.IsDBNull ``ordinal_Column294`` then None else reader.GetInt32 ``ordinal_Column294`` |> Some
      let ``Column295`` = if reader.IsDBNull ``ordinal_Column295`` then None else reader.GetInt32 ``ordinal_Column295`` |> Some
      let ``Column296`` = if reader.IsDBNull ``ordinal_Column296`` then None else reader.GetInt32 ``ordinal_Column296`` |> Some
      let ``Column297`` = if reader.IsDBNull ``ordinal_Column297`` then None else reader.GetInt32 ``ordinal_Column297`` |> Some
      let ``Column298`` = if reader.IsDBNull ``ordinal_Column298`` then None else reader.GetInt32 ``ordinal_Column298`` |> Some
      let ``Column299`` = if reader.IsDBNull ``ordinal_Column299`` then None else reader.GetInt32 ``ordinal_Column299`` |> Some
      let ``Column300`` = if reader.IsDBNull ``ordinal_Column300`` then None else reader.GetInt32 ``ordinal_Column300`` |> Some
      let ``Column301`` = if reader.IsDBNull ``ordinal_Column301`` then None else reader.GetInt32 ``ordinal_Column301`` |> Some
      let ``Column302`` = if reader.IsDBNull ``ordinal_Column302`` then None else reader.GetInt32 ``ordinal_Column302`` |> Some
      let ``Column303`` = if reader.IsDBNull ``ordinal_Column303`` then None else reader.GetInt32 ``ordinal_Column303`` |> Some
      let ``Column304`` = if reader.IsDBNull ``ordinal_Column304`` then None else reader.GetInt32 ``ordinal_Column304`` |> Some
      let ``Column305`` = if reader.IsDBNull ``ordinal_Column305`` then None else reader.GetInt32 ``ordinal_Column305`` |> Some
      let ``Column306`` = if reader.IsDBNull ``ordinal_Column306`` then None else reader.GetInt32 ``ordinal_Column306`` |> Some
      let ``Column307`` = if reader.IsDBNull ``ordinal_Column307`` then None else reader.GetInt32 ``ordinal_Column307`` |> Some
      let ``Column308`` = if reader.IsDBNull ``ordinal_Column308`` then None else reader.GetInt32 ``ordinal_Column308`` |> Some
      let ``Column309`` = if reader.IsDBNull ``ordinal_Column309`` then None else reader.GetInt32 ``ordinal_Column309`` |> Some
      let ``Column310`` = if reader.IsDBNull ``ordinal_Column310`` then None else reader.GetInt32 ``ordinal_Column310`` |> Some
      let ``Column311`` = if reader.IsDBNull ``ordinal_Column311`` then None else reader.GetInt32 ``ordinal_Column311`` |> Some
      let ``Column312`` = if reader.IsDBNull ``ordinal_Column312`` then None else reader.GetInt32 ``ordinal_Column312`` |> Some
      let ``Column313`` = if reader.IsDBNull ``ordinal_Column313`` then None else reader.GetInt32 ``ordinal_Column313`` |> Some
      let ``Column314`` = if reader.IsDBNull ``ordinal_Column314`` then None else reader.GetInt32 ``ordinal_Column314`` |> Some
      let ``Column315`` = if reader.IsDBNull ``ordinal_Column315`` then None else reader.GetInt32 ``ordinal_Column315`` |> Some
      let ``Column316`` = if reader.IsDBNull ``ordinal_Column316`` then None else reader.GetInt32 ``ordinal_Column316`` |> Some
      let ``Column317`` = if reader.IsDBNull ``ordinal_Column317`` then None else reader.GetInt32 ``ordinal_Column317`` |> Some
      let ``Column318`` = if reader.IsDBNull ``ordinal_Column318`` then None else reader.GetInt32 ``ordinal_Column318`` |> Some
      let ``Column319`` = if reader.IsDBNull ``ordinal_Column319`` then None else reader.GetInt32 ``ordinal_Column319`` |> Some
      let ``Column320`` = if reader.IsDBNull ``ordinal_Column320`` then None else reader.GetInt32 ``ordinal_Column320`` |> Some
      let ``Column321`` = if reader.IsDBNull ``ordinal_Column321`` then None else reader.GetInt32 ``ordinal_Column321`` |> Some
      let ``Column322`` = if reader.IsDBNull ``ordinal_Column322`` then None else reader.GetInt32 ``ordinal_Column322`` |> Some
      let ``Column323`` = if reader.IsDBNull ``ordinal_Column323`` then None else reader.GetInt32 ``ordinal_Column323`` |> Some
      let ``Column324`` = if reader.IsDBNull ``ordinal_Column324`` then None else reader.GetInt32 ``ordinal_Column324`` |> Some
      let ``Column325`` = if reader.IsDBNull ``ordinal_Column325`` then None else reader.GetInt32 ``ordinal_Column325`` |> Some
      let ``Column326`` = if reader.IsDBNull ``ordinal_Column326`` then None else reader.GetInt32 ``ordinal_Column326`` |> Some
      let ``Column327`` = if reader.IsDBNull ``ordinal_Column327`` then None else reader.GetInt32 ``ordinal_Column327`` |> Some
      let ``Column328`` = if reader.IsDBNull ``ordinal_Column328`` then None else reader.GetInt32 ``ordinal_Column328`` |> Some
      let ``Column329`` = if reader.IsDBNull ``ordinal_Column329`` then None else reader.GetInt32 ``ordinal_Column329`` |> Some
      let ``Column330`` = if reader.IsDBNull ``ordinal_Column330`` then None else reader.GetInt32 ``ordinal_Column330`` |> Some
      let ``Column331`` = if reader.IsDBNull ``ordinal_Column331`` then None else reader.GetInt32 ``ordinal_Column331`` |> Some
      let ``Column332`` = if reader.IsDBNull ``ordinal_Column332`` then None else reader.GetInt32 ``ordinal_Column332`` |> Some
      let ``Column333`` = if reader.IsDBNull ``ordinal_Column333`` then None else reader.GetInt32 ``ordinal_Column333`` |> Some
      let ``Column334`` = if reader.IsDBNull ``ordinal_Column334`` then None else reader.GetInt32 ``ordinal_Column334`` |> Some
      let ``Column335`` = if reader.IsDBNull ``ordinal_Column335`` then None else reader.GetInt32 ``ordinal_Column335`` |> Some
      let ``Column336`` = if reader.IsDBNull ``ordinal_Column336`` then None else reader.GetInt32 ``ordinal_Column336`` |> Some
      let ``Column337`` = if reader.IsDBNull ``ordinal_Column337`` then None else reader.GetInt32 ``ordinal_Column337`` |> Some
      let ``Column338`` = if reader.IsDBNull ``ordinal_Column338`` then None else reader.GetInt32 ``ordinal_Column338`` |> Some
      let ``Column339`` = if reader.IsDBNull ``ordinal_Column339`` then None else reader.GetInt32 ``ordinal_Column339`` |> Some
      let ``Column340`` = if reader.IsDBNull ``ordinal_Column340`` then None else reader.GetInt32 ``ordinal_Column340`` |> Some
      let ``Column341`` = if reader.IsDBNull ``ordinal_Column341`` then None else reader.GetInt32 ``ordinal_Column341`` |> Some
      let ``Column342`` = if reader.IsDBNull ``ordinal_Column342`` then None else reader.GetInt32 ``ordinal_Column342`` |> Some
      let ``Column343`` = if reader.IsDBNull ``ordinal_Column343`` then None else reader.GetInt32 ``ordinal_Column343`` |> Some
      let ``Column344`` = if reader.IsDBNull ``ordinal_Column344`` then None else reader.GetInt32 ``ordinal_Column344`` |> Some
      let ``Column345`` = if reader.IsDBNull ``ordinal_Column345`` then None else reader.GetInt32 ``ordinal_Column345`` |> Some
      let ``Column346`` = if reader.IsDBNull ``ordinal_Column346`` then None else reader.GetInt32 ``ordinal_Column346`` |> Some
      let ``Column347`` = if reader.IsDBNull ``ordinal_Column347`` then None else reader.GetInt32 ``ordinal_Column347`` |> Some
      let ``Column348`` = if reader.IsDBNull ``ordinal_Column348`` then None else reader.GetInt32 ``ordinal_Column348`` |> Some
      let ``Column349`` = if reader.IsDBNull ``ordinal_Column349`` then None else reader.GetInt32 ``ordinal_Column349`` |> Some
      let ``Column350`` = if reader.IsDBNull ``ordinal_Column350`` then None else reader.GetInt32 ``ordinal_Column350`` |> Some
      let ``Column351`` = if reader.IsDBNull ``ordinal_Column351`` then None else reader.GetInt32 ``ordinal_Column351`` |> Some
      let ``Column352`` = if reader.IsDBNull ``ordinal_Column352`` then None else reader.GetInt32 ``ordinal_Column352`` |> Some
      let ``Column353`` = if reader.IsDBNull ``ordinal_Column353`` then None else reader.GetInt32 ``ordinal_Column353`` |> Some
      let ``Column354`` = if reader.IsDBNull ``ordinal_Column354`` then None else reader.GetInt32 ``ordinal_Column354`` |> Some
      let ``Column355`` = if reader.IsDBNull ``ordinal_Column355`` then None else reader.GetInt32 ``ordinal_Column355`` |> Some
      let ``Column356`` = if reader.IsDBNull ``ordinal_Column356`` then None else reader.GetInt32 ``ordinal_Column356`` |> Some
      let ``Column357`` = if reader.IsDBNull ``ordinal_Column357`` then None else reader.GetInt32 ``ordinal_Column357`` |> Some
      let ``Column358`` = if reader.IsDBNull ``ordinal_Column358`` then None else reader.GetInt32 ``ordinal_Column358`` |> Some
      let ``Column359`` = if reader.IsDBNull ``ordinal_Column359`` then None else reader.GetInt32 ``ordinal_Column359`` |> Some
      let ``Column360`` = if reader.IsDBNull ``ordinal_Column360`` then None else reader.GetInt32 ``ordinal_Column360`` |> Some
      let ``Column361`` = if reader.IsDBNull ``ordinal_Column361`` then None else reader.GetInt32 ``ordinal_Column361`` |> Some
      let ``Column362`` = if reader.IsDBNull ``ordinal_Column362`` then None else reader.GetInt32 ``ordinal_Column362`` |> Some
      let ``Column363`` = if reader.IsDBNull ``ordinal_Column363`` then None else reader.GetInt32 ``ordinal_Column363`` |> Some
      let ``Column364`` = if reader.IsDBNull ``ordinal_Column364`` then None else reader.GetInt32 ``ordinal_Column364`` |> Some
      let ``Column365`` = if reader.IsDBNull ``ordinal_Column365`` then None else reader.GetInt32 ``ordinal_Column365`` |> Some
      let ``Column366`` = if reader.IsDBNull ``ordinal_Column366`` then None else reader.GetInt32 ``ordinal_Column366`` |> Some
      let ``Column367`` = if reader.IsDBNull ``ordinal_Column367`` then None else reader.GetInt32 ``ordinal_Column367`` |> Some
      let ``Column368`` = if reader.IsDBNull ``ordinal_Column368`` then None else reader.GetInt32 ``ordinal_Column368`` |> Some
      let ``Column369`` = if reader.IsDBNull ``ordinal_Column369`` then None else reader.GetInt32 ``ordinal_Column369`` |> Some
      let ``Column370`` = if reader.IsDBNull ``ordinal_Column370`` then None else reader.GetInt32 ``ordinal_Column370`` |> Some
      let ``Column371`` = if reader.IsDBNull ``ordinal_Column371`` then None else reader.GetInt32 ``ordinal_Column371`` |> Some
      let ``Column372`` = if reader.IsDBNull ``ordinal_Column372`` then None else reader.GetInt32 ``ordinal_Column372`` |> Some
      let ``Column373`` = if reader.IsDBNull ``ordinal_Column373`` then None else reader.GetInt32 ``ordinal_Column373`` |> Some
      let ``Column374`` = if reader.IsDBNull ``ordinal_Column374`` then None else reader.GetInt32 ``ordinal_Column374`` |> Some
      let ``Column375`` = if reader.IsDBNull ``ordinal_Column375`` then None else reader.GetInt32 ``ordinal_Column375`` |> Some
      let ``Column376`` = if reader.IsDBNull ``ordinal_Column376`` then None else reader.GetInt32 ``ordinal_Column376`` |> Some
      let ``Column377`` = if reader.IsDBNull ``ordinal_Column377`` then None else reader.GetInt32 ``ordinal_Column377`` |> Some
      let ``Column378`` = if reader.IsDBNull ``ordinal_Column378`` then None else reader.GetInt32 ``ordinal_Column378`` |> Some
      let ``Column379`` = if reader.IsDBNull ``ordinal_Column379`` then None else reader.GetInt32 ``ordinal_Column379`` |> Some
      let ``Column380`` = if reader.IsDBNull ``ordinal_Column380`` then None else reader.GetInt32 ``ordinal_Column380`` |> Some
      let ``Column381`` = if reader.IsDBNull ``ordinal_Column381`` then None else reader.GetInt32 ``ordinal_Column381`` |> Some
      let ``Column382`` = if reader.IsDBNull ``ordinal_Column382`` then None else reader.GetInt32 ``ordinal_Column382`` |> Some
      let ``Column383`` = if reader.IsDBNull ``ordinal_Column383`` then None else reader.GetInt32 ``ordinal_Column383`` |> Some
      let ``Column384`` = if reader.IsDBNull ``ordinal_Column384`` then None else reader.GetInt32 ``ordinal_Column384`` |> Some
      let ``Column385`` = if reader.IsDBNull ``ordinal_Column385`` then None else reader.GetInt32 ``ordinal_Column385`` |> Some
      let ``Column386`` = if reader.IsDBNull ``ordinal_Column386`` then None else reader.GetInt32 ``ordinal_Column386`` |> Some
      let ``Column387`` = if reader.IsDBNull ``ordinal_Column387`` then None else reader.GetInt32 ``ordinal_Column387`` |> Some
      let ``Column388`` = if reader.IsDBNull ``ordinal_Column388`` then None else reader.GetInt32 ``ordinal_Column388`` |> Some
      let ``Column389`` = if reader.IsDBNull ``ordinal_Column389`` then None else reader.GetInt32 ``ordinal_Column389`` |> Some
      let ``Column390`` = if reader.IsDBNull ``ordinal_Column390`` then None else reader.GetInt32 ``ordinal_Column390`` |> Some
      let ``Column391`` = if reader.IsDBNull ``ordinal_Column391`` then None else reader.GetInt32 ``ordinal_Column391`` |> Some
      let ``Column392`` = if reader.IsDBNull ``ordinal_Column392`` then None else reader.GetInt32 ``ordinal_Column392`` |> Some
      let ``Column393`` = if reader.IsDBNull ``ordinal_Column393`` then None else reader.GetInt32 ``ordinal_Column393`` |> Some
      let ``Column394`` = if reader.IsDBNull ``ordinal_Column394`` then None else reader.GetInt32 ``ordinal_Column394`` |> Some
      let ``Column395`` = if reader.IsDBNull ``ordinal_Column395`` then None else reader.GetInt32 ``ordinal_Column395`` |> Some
      let ``Column396`` = if reader.IsDBNull ``ordinal_Column396`` then None else reader.GetInt32 ``ordinal_Column396`` |> Some
      let ``Column397`` = if reader.IsDBNull ``ordinal_Column397`` then None else reader.GetInt32 ``ordinal_Column397`` |> Some
      let ``Column398`` = if reader.IsDBNull ``ordinal_Column398`` then None else reader.GetInt32 ``ordinal_Column398`` |> Some
      let ``Column399`` = if reader.IsDBNull ``ordinal_Column399`` then None else reader.GetInt32 ``ordinal_Column399`` |> Some
      let ``Column400`` = if reader.IsDBNull ``ordinal_Column400`` then None else reader.GetInt32 ``ordinal_Column400`` |> Some
      let ``Column401`` = if reader.IsDBNull ``ordinal_Column401`` then None else reader.GetInt32 ``ordinal_Column401`` |> Some
      let ``Column402`` = if reader.IsDBNull ``ordinal_Column402`` then None else reader.GetInt32 ``ordinal_Column402`` |> Some
      let ``Column403`` = if reader.IsDBNull ``ordinal_Column403`` then None else reader.GetInt32 ``ordinal_Column403`` |> Some
      let ``Column404`` = if reader.IsDBNull ``ordinal_Column404`` then None else reader.GetInt32 ``ordinal_Column404`` |> Some
      let ``Column405`` = if reader.IsDBNull ``ordinal_Column405`` then None else reader.GetInt32 ``ordinal_Column405`` |> Some
      let ``Column406`` = if reader.IsDBNull ``ordinal_Column406`` then None else reader.GetInt32 ``ordinal_Column406`` |> Some
      let ``Column407`` = if reader.IsDBNull ``ordinal_Column407`` then None else reader.GetInt32 ``ordinal_Column407`` |> Some
      let ``Column408`` = if reader.IsDBNull ``ordinal_Column408`` then None else reader.GetInt32 ``ordinal_Column408`` |> Some
      let ``Column409`` = if reader.IsDBNull ``ordinal_Column409`` then None else reader.GetInt32 ``ordinal_Column409`` |> Some
      let ``Column410`` = if reader.IsDBNull ``ordinal_Column410`` then None else reader.GetInt32 ``ordinal_Column410`` |> Some
      let ``Column411`` = if reader.IsDBNull ``ordinal_Column411`` then None else reader.GetInt32 ``ordinal_Column411`` |> Some
      let ``Column412`` = if reader.IsDBNull ``ordinal_Column412`` then None else reader.GetInt32 ``ordinal_Column412`` |> Some
      let ``Column413`` = if reader.IsDBNull ``ordinal_Column413`` then None else reader.GetInt32 ``ordinal_Column413`` |> Some
      let ``Column414`` = if reader.IsDBNull ``ordinal_Column414`` then None else reader.GetInt32 ``ordinal_Column414`` |> Some
      let ``Column415`` = if reader.IsDBNull ``ordinal_Column415`` then None else reader.GetInt32 ``ordinal_Column415`` |> Some
      let ``Column416`` = if reader.IsDBNull ``ordinal_Column416`` then None else reader.GetInt32 ``ordinal_Column416`` |> Some
      let ``Column417`` = if reader.IsDBNull ``ordinal_Column417`` then None else reader.GetInt32 ``ordinal_Column417`` |> Some
      let ``Column418`` = if reader.IsDBNull ``ordinal_Column418`` then None else reader.GetInt32 ``ordinal_Column418`` |> Some
      let ``Column419`` = if reader.IsDBNull ``ordinal_Column419`` then None else reader.GetInt32 ``ordinal_Column419`` |> Some
      let ``Column420`` = if reader.IsDBNull ``ordinal_Column420`` then None else reader.GetInt32 ``ordinal_Column420`` |> Some
      let ``Column421`` = if reader.IsDBNull ``ordinal_Column421`` then None else reader.GetInt32 ``ordinal_Column421`` |> Some
      let ``Column422`` = if reader.IsDBNull ``ordinal_Column422`` then None else reader.GetInt32 ``ordinal_Column422`` |> Some
      let ``Column423`` = if reader.IsDBNull ``ordinal_Column423`` then None else reader.GetInt32 ``ordinal_Column423`` |> Some
      let ``Column424`` = if reader.IsDBNull ``ordinal_Column424`` then None else reader.GetInt32 ``ordinal_Column424`` |> Some
      let ``Column425`` = if reader.IsDBNull ``ordinal_Column425`` then None else reader.GetInt32 ``ordinal_Column425`` |> Some
      let ``Column426`` = if reader.IsDBNull ``ordinal_Column426`` then None else reader.GetInt32 ``ordinal_Column426`` |> Some
      let ``Column427`` = if reader.IsDBNull ``ordinal_Column427`` then None else reader.GetInt32 ``ordinal_Column427`` |> Some
      let ``Column428`` = if reader.IsDBNull ``ordinal_Column428`` then None else reader.GetInt32 ``ordinal_Column428`` |> Some
      let ``Column429`` = if reader.IsDBNull ``ordinal_Column429`` then None else reader.GetInt32 ``ordinal_Column429`` |> Some
      let ``Column430`` = if reader.IsDBNull ``ordinal_Column430`` then None else reader.GetInt32 ``ordinal_Column430`` |> Some
      let ``Column431`` = if reader.IsDBNull ``ordinal_Column431`` then None else reader.GetInt32 ``ordinal_Column431`` |> Some
      let ``Column432`` = if reader.IsDBNull ``ordinal_Column432`` then None else reader.GetInt32 ``ordinal_Column432`` |> Some
      let ``Column433`` = if reader.IsDBNull ``ordinal_Column433`` then None else reader.GetInt32 ``ordinal_Column433`` |> Some
      let ``Column434`` = if reader.IsDBNull ``ordinal_Column434`` then None else reader.GetInt32 ``ordinal_Column434`` |> Some
      let ``Column435`` = if reader.IsDBNull ``ordinal_Column435`` then None else reader.GetInt32 ``ordinal_Column435`` |> Some
      let ``Column436`` = if reader.IsDBNull ``ordinal_Column436`` then None else reader.GetInt32 ``ordinal_Column436`` |> Some
      let ``Column437`` = if reader.IsDBNull ``ordinal_Column437`` then None else reader.GetInt32 ``ordinal_Column437`` |> Some
      let ``Column438`` = if reader.IsDBNull ``ordinal_Column438`` then None else reader.GetInt32 ``ordinal_Column438`` |> Some
      let ``Column439`` = if reader.IsDBNull ``ordinal_Column439`` then None else reader.GetInt32 ``ordinal_Column439`` |> Some
      let ``Column440`` = if reader.IsDBNull ``ordinal_Column440`` then None else reader.GetInt32 ``ordinal_Column440`` |> Some
      let ``Column441`` = if reader.IsDBNull ``ordinal_Column441`` then None else reader.GetInt32 ``ordinal_Column441`` |> Some
      let ``Column442`` = if reader.IsDBNull ``ordinal_Column442`` then None else reader.GetInt32 ``ordinal_Column442`` |> Some
      let ``Column443`` = if reader.IsDBNull ``ordinal_Column443`` then None else reader.GetInt32 ``ordinal_Column443`` |> Some
      let ``Column444`` = if reader.IsDBNull ``ordinal_Column444`` then None else reader.GetInt32 ``ordinal_Column444`` |> Some
      let ``Column445`` = if reader.IsDBNull ``ordinal_Column445`` then None else reader.GetInt32 ``ordinal_Column445`` |> Some
      let ``Column446`` = if reader.IsDBNull ``ordinal_Column446`` then None else reader.GetInt32 ``ordinal_Column446`` |> Some
      let ``Column447`` = if reader.IsDBNull ``ordinal_Column447`` then None else reader.GetInt32 ``ordinal_Column447`` |> Some
      let ``Column448`` = if reader.IsDBNull ``ordinal_Column448`` then None else reader.GetInt32 ``ordinal_Column448`` |> Some
      let ``Column449`` = if reader.IsDBNull ``ordinal_Column449`` then None else reader.GetInt32 ``ordinal_Column449`` |> Some
      let ``Column450`` = if reader.IsDBNull ``ordinal_Column450`` then None else reader.GetInt32 ``ordinal_Column450`` |> Some
      let ``Column451`` = if reader.IsDBNull ``ordinal_Column451`` then None else reader.GetInt32 ``ordinal_Column451`` |> Some
      let ``Column452`` = if reader.IsDBNull ``ordinal_Column452`` then None else reader.GetInt32 ``ordinal_Column452`` |> Some
      let ``Column453`` = if reader.IsDBNull ``ordinal_Column453`` then None else reader.GetInt32 ``ordinal_Column453`` |> Some
      let ``Column454`` = if reader.IsDBNull ``ordinal_Column454`` then None else reader.GetInt32 ``ordinal_Column454`` |> Some
      let ``Column455`` = if reader.IsDBNull ``ordinal_Column455`` then None else reader.GetInt32 ``ordinal_Column455`` |> Some
      let ``Column456`` = if reader.IsDBNull ``ordinal_Column456`` then None else reader.GetInt32 ``ordinal_Column456`` |> Some
      let ``Column457`` = if reader.IsDBNull ``ordinal_Column457`` then None else reader.GetInt32 ``ordinal_Column457`` |> Some
      let ``Column458`` = if reader.IsDBNull ``ordinal_Column458`` then None else reader.GetInt32 ``ordinal_Column458`` |> Some
      let ``Column459`` = if reader.IsDBNull ``ordinal_Column459`` then None else reader.GetInt32 ``ordinal_Column459`` |> Some
      let ``Column460`` = if reader.IsDBNull ``ordinal_Column460`` then None else reader.GetInt32 ``ordinal_Column460`` |> Some
      let ``Column461`` = if reader.IsDBNull ``ordinal_Column461`` then None else reader.GetInt32 ``ordinal_Column461`` |> Some
      let ``Column462`` = if reader.IsDBNull ``ordinal_Column462`` then None else reader.GetInt32 ``ordinal_Column462`` |> Some
      let ``Column463`` = if reader.IsDBNull ``ordinal_Column463`` then None else reader.GetInt32 ``ordinal_Column463`` |> Some
      let ``Column464`` = if reader.IsDBNull ``ordinal_Column464`` then None else reader.GetInt32 ``ordinal_Column464`` |> Some
      let ``Column465`` = if reader.IsDBNull ``ordinal_Column465`` then None else reader.GetInt32 ``ordinal_Column465`` |> Some
      let ``Column466`` = if reader.IsDBNull ``ordinal_Column466`` then None else reader.GetInt32 ``ordinal_Column466`` |> Some
      let ``Column467`` = if reader.IsDBNull ``ordinal_Column467`` then None else reader.GetInt32 ``ordinal_Column467`` |> Some
      let ``Column468`` = if reader.IsDBNull ``ordinal_Column468`` then None else reader.GetInt32 ``ordinal_Column468`` |> Some
      let ``Column469`` = if reader.IsDBNull ``ordinal_Column469`` then None else reader.GetInt32 ``ordinal_Column469`` |> Some
      let ``Column470`` = if reader.IsDBNull ``ordinal_Column470`` then None else reader.GetInt32 ``ordinal_Column470`` |> Some
      let ``Column471`` = if reader.IsDBNull ``ordinal_Column471`` then None else reader.GetInt32 ``ordinal_Column471`` |> Some
      let ``Column472`` = if reader.IsDBNull ``ordinal_Column472`` then None else reader.GetInt32 ``ordinal_Column472`` |> Some
      let ``Column473`` = if reader.IsDBNull ``ordinal_Column473`` then None else reader.GetInt32 ``ordinal_Column473`` |> Some
      let ``Column474`` = if reader.IsDBNull ``ordinal_Column474`` then None else reader.GetInt32 ``ordinal_Column474`` |> Some
      let ``Column475`` = if reader.IsDBNull ``ordinal_Column475`` then None else reader.GetInt32 ``ordinal_Column475`` |> Some
      let ``Column476`` = if reader.IsDBNull ``ordinal_Column476`` then None else reader.GetInt32 ``ordinal_Column476`` |> Some
      let ``Column477`` = if reader.IsDBNull ``ordinal_Column477`` then None else reader.GetInt32 ``ordinal_Column477`` |> Some
      let ``Column478`` = if reader.IsDBNull ``ordinal_Column478`` then None else reader.GetInt32 ``ordinal_Column478`` |> Some
      let ``Column479`` = if reader.IsDBNull ``ordinal_Column479`` then None else reader.GetInt32 ``ordinal_Column479`` |> Some
      let ``Column480`` = if reader.IsDBNull ``ordinal_Column480`` then None else reader.GetInt32 ``ordinal_Column480`` |> Some
      let ``Column481`` = if reader.IsDBNull ``ordinal_Column481`` then None else reader.GetInt32 ``ordinal_Column481`` |> Some
      let ``Column482`` = if reader.IsDBNull ``ordinal_Column482`` then None else reader.GetInt32 ``ordinal_Column482`` |> Some
      let ``Column483`` = if reader.IsDBNull ``ordinal_Column483`` then None else reader.GetInt32 ``ordinal_Column483`` |> Some
      let ``Column484`` = if reader.IsDBNull ``ordinal_Column484`` then None else reader.GetInt32 ``ordinal_Column484`` |> Some
      let ``Column485`` = if reader.IsDBNull ``ordinal_Column485`` then None else reader.GetInt32 ``ordinal_Column485`` |> Some
      let ``Column486`` = if reader.IsDBNull ``ordinal_Column486`` then None else reader.GetInt32 ``ordinal_Column486`` |> Some
      let ``Column487`` = if reader.IsDBNull ``ordinal_Column487`` then None else reader.GetInt32 ``ordinal_Column487`` |> Some
      let ``Column488`` = if reader.IsDBNull ``ordinal_Column488`` then None else reader.GetInt32 ``ordinal_Column488`` |> Some
      let ``Column489`` = if reader.IsDBNull ``ordinal_Column489`` then None else reader.GetInt32 ``ordinal_Column489`` |> Some
      let ``Column490`` = if reader.IsDBNull ``ordinal_Column490`` then None else reader.GetInt32 ``ordinal_Column490`` |> Some
      let ``Column491`` = if reader.IsDBNull ``ordinal_Column491`` then None else reader.GetInt32 ``ordinal_Column491`` |> Some
      let ``Column492`` = if reader.IsDBNull ``ordinal_Column492`` then None else reader.GetInt32 ``ordinal_Column492`` |> Some
      let ``Column493`` = if reader.IsDBNull ``ordinal_Column493`` then None else reader.GetInt32 ``ordinal_Column493`` |> Some
      let ``Column494`` = if reader.IsDBNull ``ordinal_Column494`` then None else reader.GetInt32 ``ordinal_Column494`` |> Some
      let ``Column495`` = if reader.IsDBNull ``ordinal_Column495`` then None else reader.GetInt32 ``ordinal_Column495`` |> Some
      let ``Column496`` = if reader.IsDBNull ``ordinal_Column496`` then None else reader.GetInt32 ``ordinal_Column496`` |> Some
      let ``Column497`` = if reader.IsDBNull ``ordinal_Column497`` then None else reader.GetInt32 ``ordinal_Column497`` |> Some
      let ``Column498`` = if reader.IsDBNull ``ordinal_Column498`` then None else reader.GetInt32 ``ordinal_Column498`` |> Some
      let ``Column499`` = if reader.IsDBNull ``ordinal_Column499`` then None else reader.GetInt32 ``ordinal_Column499`` |> Some
      let ``Column500`` = if reader.IsDBNull ``ordinal_Column500`` then None else reader.GetInt32 ``ordinal_Column500`` |> Some
      let ``Column501`` = if reader.IsDBNull ``ordinal_Column501`` then None else reader.GetInt32 ``ordinal_Column501`` |> Some
      let ``Column502`` = if reader.IsDBNull ``ordinal_Column502`` then None else reader.GetInt32 ``ordinal_Column502`` |> Some
      let ``Column503`` = if reader.IsDBNull ``ordinal_Column503`` then None else reader.GetInt32 ``ordinal_Column503`` |> Some
      let ``Column504`` = if reader.IsDBNull ``ordinal_Column504`` then None else reader.GetInt32 ``ordinal_Column504`` |> Some
      let ``Column505`` = if reader.IsDBNull ``ordinal_Column505`` then None else reader.GetInt32 ``ordinal_Column505`` |> Some
      let ``Column506`` = if reader.IsDBNull ``ordinal_Column506`` then None else reader.GetInt32 ``ordinal_Column506`` |> Some
      let ``Column507`` = if reader.IsDBNull ``ordinal_Column507`` then None else reader.GetInt32 ``ordinal_Column507`` |> Some
      let ``Column508`` = if reader.IsDBNull ``ordinal_Column508`` then None else reader.GetInt32 ``ordinal_Column508`` |> Some
      let ``Column509`` = if reader.IsDBNull ``ordinal_Column509`` then None else reader.GetInt32 ``ordinal_Column509`` |> Some
      let ``Column510`` = if reader.IsDBNull ``ordinal_Column510`` then None else reader.GetInt32 ``ordinal_Column510`` |> Some
      let ``Column511`` = if reader.IsDBNull ``ordinal_Column511`` then None else reader.GetInt32 ``ordinal_Column511`` |> Some
      let ``Column512`` = if reader.IsDBNull ``ordinal_Column512`` then None else reader.GetInt32 ``ordinal_Column512`` |> Some
      let ``Column513`` = if reader.IsDBNull ``ordinal_Column513`` then None else reader.GetInt32 ``ordinal_Column513`` |> Some
      let ``Column514`` = if reader.IsDBNull ``ordinal_Column514`` then None else reader.GetInt32 ``ordinal_Column514`` |> Some
      let ``Column515`` = if reader.IsDBNull ``ordinal_Column515`` then None else reader.GetInt32 ``ordinal_Column515`` |> Some
      let ``Column516`` = if reader.IsDBNull ``ordinal_Column516`` then None else reader.GetInt32 ``ordinal_Column516`` |> Some
      let ``Column517`` = if reader.IsDBNull ``ordinal_Column517`` then None else reader.GetInt32 ``ordinal_Column517`` |> Some
      let ``Column518`` = if reader.IsDBNull ``ordinal_Column518`` then None else reader.GetInt32 ``ordinal_Column518`` |> Some
      let ``Column519`` = if reader.IsDBNull ``ordinal_Column519`` then None else reader.GetInt32 ``ordinal_Column519`` |> Some
      let ``Column520`` = if reader.IsDBNull ``ordinal_Column520`` then None else reader.GetInt32 ``ordinal_Column520`` |> Some
      let ``Column521`` = if reader.IsDBNull ``ordinal_Column521`` then None else reader.GetInt32 ``ordinal_Column521`` |> Some
      let ``Column522`` = if reader.IsDBNull ``ordinal_Column522`` then None else reader.GetInt32 ``ordinal_Column522`` |> Some
      let ``Column523`` = if reader.IsDBNull ``ordinal_Column523`` then None else reader.GetInt32 ``ordinal_Column523`` |> Some
      let ``Column524`` = if reader.IsDBNull ``ordinal_Column524`` then None else reader.GetInt32 ``ordinal_Column524`` |> Some
      let ``Column525`` = if reader.IsDBNull ``ordinal_Column525`` then None else reader.GetInt32 ``ordinal_Column525`` |> Some
      let ``Column526`` = if reader.IsDBNull ``ordinal_Column526`` then None else reader.GetInt32 ``ordinal_Column526`` |> Some
      let ``Column527`` = if reader.IsDBNull ``ordinal_Column527`` then None else reader.GetInt32 ``ordinal_Column527`` |> Some
      let ``Column528`` = if reader.IsDBNull ``ordinal_Column528`` then None else reader.GetInt32 ``ordinal_Column528`` |> Some
      let ``Column529`` = if reader.IsDBNull ``ordinal_Column529`` then None else reader.GetInt32 ``ordinal_Column529`` |> Some
      let ``Column530`` = if reader.IsDBNull ``ordinal_Column530`` then None else reader.GetInt32 ``ordinal_Column530`` |> Some
      let ``Column531`` = if reader.IsDBNull ``ordinal_Column531`` then None else reader.GetInt32 ``ordinal_Column531`` |> Some
      let ``Column532`` = if reader.IsDBNull ``ordinal_Column532`` then None else reader.GetInt32 ``ordinal_Column532`` |> Some
      let ``Column533`` = if reader.IsDBNull ``ordinal_Column533`` then None else reader.GetInt32 ``ordinal_Column533`` |> Some
      let ``Column534`` = if reader.IsDBNull ``ordinal_Column534`` then None else reader.GetInt32 ``ordinal_Column534`` |> Some
      let ``Column535`` = if reader.IsDBNull ``ordinal_Column535`` then None else reader.GetInt32 ``ordinal_Column535`` |> Some
      let ``Column536`` = if reader.IsDBNull ``ordinal_Column536`` then None else reader.GetInt32 ``ordinal_Column536`` |> Some
      let ``Column537`` = if reader.IsDBNull ``ordinal_Column537`` then None else reader.GetInt32 ``ordinal_Column537`` |> Some
      let ``Column538`` = if reader.IsDBNull ``ordinal_Column538`` then None else reader.GetInt32 ``ordinal_Column538`` |> Some
      let ``Column539`` = if reader.IsDBNull ``ordinal_Column539`` then None else reader.GetInt32 ``ordinal_Column539`` |> Some
      let ``Column540`` = if reader.IsDBNull ``ordinal_Column540`` then None else reader.GetInt32 ``ordinal_Column540`` |> Some
      let ``Column541`` = if reader.IsDBNull ``ordinal_Column541`` then None else reader.GetInt32 ``ordinal_Column541`` |> Some
      let ``Column542`` = if reader.IsDBNull ``ordinal_Column542`` then None else reader.GetInt32 ``ordinal_Column542`` |> Some
      let ``Column543`` = if reader.IsDBNull ``ordinal_Column543`` then None else reader.GetInt32 ``ordinal_Column543`` |> Some
      let ``Column544`` = if reader.IsDBNull ``ordinal_Column544`` then None else reader.GetInt32 ``ordinal_Column544`` |> Some
      let ``Column545`` = if reader.IsDBNull ``ordinal_Column545`` then None else reader.GetInt32 ``ordinal_Column545`` |> Some
      let ``Column546`` = if reader.IsDBNull ``ordinal_Column546`` then None else reader.GetInt32 ``ordinal_Column546`` |> Some
      let ``Column547`` = if reader.IsDBNull ``ordinal_Column547`` then None else reader.GetInt32 ``ordinal_Column547`` |> Some
      let ``Column548`` = if reader.IsDBNull ``ordinal_Column548`` then None else reader.GetInt32 ``ordinal_Column548`` |> Some
      let ``Column549`` = if reader.IsDBNull ``ordinal_Column549`` then None else reader.GetInt32 ``ordinal_Column549`` |> Some
      let ``Column550`` = if reader.IsDBNull ``ordinal_Column550`` then None else reader.GetInt32 ``ordinal_Column550`` |> Some
      let ``Column551`` = if reader.IsDBNull ``ordinal_Column551`` then None else reader.GetInt32 ``ordinal_Column551`` |> Some
      let ``Column552`` = if reader.IsDBNull ``ordinal_Column552`` then None else reader.GetInt32 ``ordinal_Column552`` |> Some
      let ``Column553`` = if reader.IsDBNull ``ordinal_Column553`` then None else reader.GetInt32 ``ordinal_Column553`` |> Some
      let ``Column554`` = if reader.IsDBNull ``ordinal_Column554`` then None else reader.GetInt32 ``ordinal_Column554`` |> Some
      let ``Column555`` = if reader.IsDBNull ``ordinal_Column555`` then None else reader.GetInt32 ``ordinal_Column555`` |> Some
      let ``Column556`` = if reader.IsDBNull ``ordinal_Column556`` then None else reader.GetInt32 ``ordinal_Column556`` |> Some
      let ``Column557`` = if reader.IsDBNull ``ordinal_Column557`` then None else reader.GetInt32 ``ordinal_Column557`` |> Some
      let ``Column558`` = if reader.IsDBNull ``ordinal_Column558`` then None else reader.GetInt32 ``ordinal_Column558`` |> Some
      let ``Column559`` = if reader.IsDBNull ``ordinal_Column559`` then None else reader.GetInt32 ``ordinal_Column559`` |> Some
      let ``Column560`` = if reader.IsDBNull ``ordinal_Column560`` then None else reader.GetInt32 ``ordinal_Column560`` |> Some
      let ``Column561`` = if reader.IsDBNull ``ordinal_Column561`` then None else reader.GetInt32 ``ordinal_Column561`` |> Some
      let ``Column562`` = if reader.IsDBNull ``ordinal_Column562`` then None else reader.GetInt32 ``ordinal_Column562`` |> Some
      let ``Column563`` = if reader.IsDBNull ``ordinal_Column563`` then None else reader.GetInt32 ``ordinal_Column563`` |> Some
      let ``Column564`` = if reader.IsDBNull ``ordinal_Column564`` then None else reader.GetInt32 ``ordinal_Column564`` |> Some
      let ``Column565`` = if reader.IsDBNull ``ordinal_Column565`` then None else reader.GetInt32 ``ordinal_Column565`` |> Some
      let ``Column566`` = if reader.IsDBNull ``ordinal_Column566`` then None else reader.GetInt32 ``ordinal_Column566`` |> Some
      let ``Column567`` = if reader.IsDBNull ``ordinal_Column567`` then None else reader.GetInt32 ``ordinal_Column567`` |> Some
      let ``Column568`` = if reader.IsDBNull ``ordinal_Column568`` then None else reader.GetInt32 ``ordinal_Column568`` |> Some
      let ``Column569`` = if reader.IsDBNull ``ordinal_Column569`` then None else reader.GetInt32 ``ordinal_Column569`` |> Some
      let ``Column570`` = if reader.IsDBNull ``ordinal_Column570`` then None else reader.GetInt32 ``ordinal_Column570`` |> Some
      let ``Column571`` = if reader.IsDBNull ``ordinal_Column571`` then None else reader.GetInt32 ``ordinal_Column571`` |> Some
      let ``Column572`` = if reader.IsDBNull ``ordinal_Column572`` then None else reader.GetInt32 ``ordinal_Column572`` |> Some
      let ``Column573`` = if reader.IsDBNull ``ordinal_Column573`` then None else reader.GetInt32 ``ordinal_Column573`` |> Some
      let ``Column574`` = if reader.IsDBNull ``ordinal_Column574`` then None else reader.GetInt32 ``ordinal_Column574`` |> Some
      let ``Column575`` = if reader.IsDBNull ``ordinal_Column575`` then None else reader.GetInt32 ``ordinal_Column575`` |> Some
      let ``Column576`` = if reader.IsDBNull ``ordinal_Column576`` then None else reader.GetInt32 ``ordinal_Column576`` |> Some
      let ``Column577`` = if reader.IsDBNull ``ordinal_Column577`` then None else reader.GetInt32 ``ordinal_Column577`` |> Some
      let ``Column578`` = if reader.IsDBNull ``ordinal_Column578`` then None else reader.GetInt32 ``ordinal_Column578`` |> Some
      let ``Column579`` = if reader.IsDBNull ``ordinal_Column579`` then None else reader.GetInt32 ``ordinal_Column579`` |> Some
      let ``Column580`` = if reader.IsDBNull ``ordinal_Column580`` then None else reader.GetInt32 ``ordinal_Column580`` |> Some
      let ``Column581`` = if reader.IsDBNull ``ordinal_Column581`` then None else reader.GetInt32 ``ordinal_Column581`` |> Some
      let ``Column582`` = if reader.IsDBNull ``ordinal_Column582`` then None else reader.GetInt32 ``ordinal_Column582`` |> Some
      let ``Column583`` = if reader.IsDBNull ``ordinal_Column583`` then None else reader.GetInt32 ``ordinal_Column583`` |> Some
      let ``Column584`` = if reader.IsDBNull ``ordinal_Column584`` then None else reader.GetInt32 ``ordinal_Column584`` |> Some
      let ``Column585`` = if reader.IsDBNull ``ordinal_Column585`` then None else reader.GetInt32 ``ordinal_Column585`` |> Some
      let ``Column586`` = if reader.IsDBNull ``ordinal_Column586`` then None else reader.GetInt32 ``ordinal_Column586`` |> Some
      let ``Column587`` = if reader.IsDBNull ``ordinal_Column587`` then None else reader.GetInt32 ``ordinal_Column587`` |> Some
      let ``Column588`` = if reader.IsDBNull ``ordinal_Column588`` then None else reader.GetInt32 ``ordinal_Column588`` |> Some
      let ``Column589`` = if reader.IsDBNull ``ordinal_Column589`` then None else reader.GetInt32 ``ordinal_Column589`` |> Some
      let ``Column590`` = if reader.IsDBNull ``ordinal_Column590`` then None else reader.GetInt32 ``ordinal_Column590`` |> Some
      let ``Column591`` = if reader.IsDBNull ``ordinal_Column591`` then None else reader.GetInt32 ``ordinal_Column591`` |> Some
      let ``Column592`` = if reader.IsDBNull ``ordinal_Column592`` then None else reader.GetInt32 ``ordinal_Column592`` |> Some
      let ``Column593`` = if reader.IsDBNull ``ordinal_Column593`` then None else reader.GetInt32 ``ordinal_Column593`` |> Some
      let ``Column594`` = if reader.IsDBNull ``ordinal_Column594`` then None else reader.GetInt32 ``ordinal_Column594`` |> Some
      let ``Column595`` = if reader.IsDBNull ``ordinal_Column595`` then None else reader.GetInt32 ``ordinal_Column595`` |> Some
      let ``Column596`` = if reader.IsDBNull ``ordinal_Column596`` then None else reader.GetInt32 ``ordinal_Column596`` |> Some
      let ``Column597`` = if reader.IsDBNull ``ordinal_Column597`` then None else reader.GetInt32 ``ordinal_Column597`` |> Some
      let ``Column598`` = if reader.IsDBNull ``ordinal_Column598`` then None else reader.GetInt32 ``ordinal_Column598`` |> Some
      let ``Column599`` = if reader.IsDBNull ``ordinal_Column599`` then None else reader.GetInt32 ``ordinal_Column599`` |> Some
      let ``Column600`` = if reader.IsDBNull ``ordinal_Column600`` then None else reader.GetInt32 ``ordinal_Column600`` |> Some
      reader.IsClosed |> ignore  // Disable compiler optimization that causes stack overflow at runtime for large records
      {|
        ``Column1`` = ``Column1``
        ``Column2`` = ``Column2``
        ``Column3`` = ``Column3``
        ``Column4`` = ``Column4``
        ``Column5`` = ``Column5``
        ``Column6`` = ``Column6``
        ``Column7`` = ``Column7``
        ``Column8`` = ``Column8``
        ``Column9`` = ``Column9``
        ``Column10`` = ``Column10``
        ``Column11`` = ``Column11``
        ``Column12`` = ``Column12``
        ``Column13`` = ``Column13``
        ``Column14`` = ``Column14``
        ``Column15`` = ``Column15``
        ``Column16`` = ``Column16``
        ``Column17`` = ``Column17``
        ``Column18`` = ``Column18``
        ``Column19`` = ``Column19``
        ``Column20`` = ``Column20``
        ``Column21`` = ``Column21``
        ``Column22`` = ``Column22``
        ``Column23`` = ``Column23``
        ``Column24`` = ``Column24``
        ``Column25`` = ``Column25``
        ``Column26`` = ``Column26``
        ``Column27`` = ``Column27``
        ``Column28`` = ``Column28``
        ``Column29`` = ``Column29``
        ``Column30`` = ``Column30``
        ``Column31`` = ``Column31``
        ``Column32`` = ``Column32``
        ``Column33`` = ``Column33``
        ``Column34`` = ``Column34``
        ``Column35`` = ``Column35``
        ``Column36`` = ``Column36``
        ``Column37`` = ``Column37``
        ``Column38`` = ``Column38``
        ``Column39`` = ``Column39``
        ``Column40`` = ``Column40``
        ``Column41`` = ``Column41``
        ``Column42`` = ``Column42``
        ``Column43`` = ``Column43``
        ``Column44`` = ``Column44``
        ``Column45`` = ``Column45``
        ``Column46`` = ``Column46``
        ``Column47`` = ``Column47``
        ``Column48`` = ``Column48``
        ``Column49`` = ``Column49``
        ``Column50`` = ``Column50``
        ``Column51`` = ``Column51``
        ``Column52`` = ``Column52``
        ``Column53`` = ``Column53``
        ``Column54`` = ``Column54``
        ``Column55`` = ``Column55``
        ``Column56`` = ``Column56``
        ``Column57`` = ``Column57``
        ``Column58`` = ``Column58``
        ``Column59`` = ``Column59``
        ``Column60`` = ``Column60``
        ``Column61`` = ``Column61``
        ``Column62`` = ``Column62``
        ``Column63`` = ``Column63``
        ``Column64`` = ``Column64``
        ``Column65`` = ``Column65``
        ``Column66`` = ``Column66``
        ``Column67`` = ``Column67``
        ``Column68`` = ``Column68``
        ``Column69`` = ``Column69``
        ``Column70`` = ``Column70``
        ``Column71`` = ``Column71``
        ``Column72`` = ``Column72``
        ``Column73`` = ``Column73``
        ``Column74`` = ``Column74``
        ``Column75`` = ``Column75``
        ``Column76`` = ``Column76``
        ``Column77`` = ``Column77``
        ``Column78`` = ``Column78``
        ``Column79`` = ``Column79``
        ``Column80`` = ``Column80``
        ``Column81`` = ``Column81``
        ``Column82`` = ``Column82``
        ``Column83`` = ``Column83``
        ``Column84`` = ``Column84``
        ``Column85`` = ``Column85``
        ``Column86`` = ``Column86``
        ``Column87`` = ``Column87``
        ``Column88`` = ``Column88``
        ``Column89`` = ``Column89``
        ``Column90`` = ``Column90``
        ``Column91`` = ``Column91``
        ``Column92`` = ``Column92``
        ``Column93`` = ``Column93``
        ``Column94`` = ``Column94``
        ``Column95`` = ``Column95``
        ``Column96`` = ``Column96``
        ``Column97`` = ``Column97``
        ``Column98`` = ``Column98``
        ``Column99`` = ``Column99``
        ``Column100`` = ``Column100``
        ``Column101`` = ``Column101``
        ``Column102`` = ``Column102``
        ``Column103`` = ``Column103``
        ``Column104`` = ``Column104``
        ``Column105`` = ``Column105``
        ``Column106`` = ``Column106``
        ``Column107`` = ``Column107``
        ``Column108`` = ``Column108``
        ``Column109`` = ``Column109``
        ``Column110`` = ``Column110``
        ``Column111`` = ``Column111``
        ``Column112`` = ``Column112``
        ``Column113`` = ``Column113``
        ``Column114`` = ``Column114``
        ``Column115`` = ``Column115``
        ``Column116`` = ``Column116``
        ``Column117`` = ``Column117``
        ``Column118`` = ``Column118``
        ``Column119`` = ``Column119``
        ``Column120`` = ``Column120``
        ``Column121`` = ``Column121``
        ``Column122`` = ``Column122``
        ``Column123`` = ``Column123``
        ``Column124`` = ``Column124``
        ``Column125`` = ``Column125``
        ``Column126`` = ``Column126``
        ``Column127`` = ``Column127``
        ``Column128`` = ``Column128``
        ``Column129`` = ``Column129``
        ``Column130`` = ``Column130``
        ``Column131`` = ``Column131``
        ``Column132`` = ``Column132``
        ``Column133`` = ``Column133``
        ``Column134`` = ``Column134``
        ``Column135`` = ``Column135``
        ``Column136`` = ``Column136``
        ``Column137`` = ``Column137``
        ``Column138`` = ``Column138``
        ``Column139`` = ``Column139``
        ``Column140`` = ``Column140``
        ``Column141`` = ``Column141``
        ``Column142`` = ``Column142``
        ``Column143`` = ``Column143``
        ``Column144`` = ``Column144``
        ``Column145`` = ``Column145``
        ``Column146`` = ``Column146``
        ``Column147`` = ``Column147``
        ``Column148`` = ``Column148``
        ``Column149`` = ``Column149``
        ``Column150`` = ``Column150``
        ``Column151`` = ``Column151``
        ``Column152`` = ``Column152``
        ``Column153`` = ``Column153``
        ``Column154`` = ``Column154``
        ``Column155`` = ``Column155``
        ``Column156`` = ``Column156``
        ``Column157`` = ``Column157``
        ``Column158`` = ``Column158``
        ``Column159`` = ``Column159``
        ``Column160`` = ``Column160``
        ``Column161`` = ``Column161``
        ``Column162`` = ``Column162``
        ``Column163`` = ``Column163``
        ``Column164`` = ``Column164``
        ``Column165`` = ``Column165``
        ``Column166`` = ``Column166``
        ``Column167`` = ``Column167``
        ``Column168`` = ``Column168``
        ``Column169`` = ``Column169``
        ``Column170`` = ``Column170``
        ``Column171`` = ``Column171``
        ``Column172`` = ``Column172``
        ``Column173`` = ``Column173``
        ``Column174`` = ``Column174``
        ``Column175`` = ``Column175``
        ``Column176`` = ``Column176``
        ``Column177`` = ``Column177``
        ``Column178`` = ``Column178``
        ``Column179`` = ``Column179``
        ``Column180`` = ``Column180``
        ``Column181`` = ``Column181``
        ``Column182`` = ``Column182``
        ``Column183`` = ``Column183``
        ``Column184`` = ``Column184``
        ``Column185`` = ``Column185``
        ``Column186`` = ``Column186``
        ``Column187`` = ``Column187``
        ``Column188`` = ``Column188``
        ``Column189`` = ``Column189``
        ``Column190`` = ``Column190``
        ``Column191`` = ``Column191``
        ``Column192`` = ``Column192``
        ``Column193`` = ``Column193``
        ``Column194`` = ``Column194``
        ``Column195`` = ``Column195``
        ``Column196`` = ``Column196``
        ``Column197`` = ``Column197``
        ``Column198`` = ``Column198``
        ``Column199`` = ``Column199``
        ``Column200`` = ``Column200``
        ``Column201`` = ``Column201``
        ``Column202`` = ``Column202``
        ``Column203`` = ``Column203``
        ``Column204`` = ``Column204``
        ``Column205`` = ``Column205``
        ``Column206`` = ``Column206``
        ``Column207`` = ``Column207``
        ``Column208`` = ``Column208``
        ``Column209`` = ``Column209``
        ``Column210`` = ``Column210``
        ``Column211`` = ``Column211``
        ``Column212`` = ``Column212``
        ``Column213`` = ``Column213``
        ``Column214`` = ``Column214``
        ``Column215`` = ``Column215``
        ``Column216`` = ``Column216``
        ``Column217`` = ``Column217``
        ``Column218`` = ``Column218``
        ``Column219`` = ``Column219``
        ``Column220`` = ``Column220``
        ``Column221`` = ``Column221``
        ``Column222`` = ``Column222``
        ``Column223`` = ``Column223``
        ``Column224`` = ``Column224``
        ``Column225`` = ``Column225``
        ``Column226`` = ``Column226``
        ``Column227`` = ``Column227``
        ``Column228`` = ``Column228``
        ``Column229`` = ``Column229``
        ``Column230`` = ``Column230``
        ``Column231`` = ``Column231``
        ``Column232`` = ``Column232``
        ``Column233`` = ``Column233``
        ``Column234`` = ``Column234``
        ``Column235`` = ``Column235``
        ``Column236`` = ``Column236``
        ``Column237`` = ``Column237``
        ``Column238`` = ``Column238``
        ``Column239`` = ``Column239``
        ``Column240`` = ``Column240``
        ``Column241`` = ``Column241``
        ``Column242`` = ``Column242``
        ``Column243`` = ``Column243``
        ``Column244`` = ``Column244``
        ``Column245`` = ``Column245``
        ``Column246`` = ``Column246``
        ``Column247`` = ``Column247``
        ``Column248`` = ``Column248``
        ``Column249`` = ``Column249``
        ``Column250`` = ``Column250``
        ``Column251`` = ``Column251``
        ``Column252`` = ``Column252``
        ``Column253`` = ``Column253``
        ``Column254`` = ``Column254``
        ``Column255`` = ``Column255``
        ``Column256`` = ``Column256``
        ``Column257`` = ``Column257``
        ``Column258`` = ``Column258``
        ``Column259`` = ``Column259``
        ``Column260`` = ``Column260``
        ``Column261`` = ``Column261``
        ``Column262`` = ``Column262``
        ``Column263`` = ``Column263``
        ``Column264`` = ``Column264``
        ``Column265`` = ``Column265``
        ``Column266`` = ``Column266``
        ``Column267`` = ``Column267``
        ``Column268`` = ``Column268``
        ``Column269`` = ``Column269``
        ``Column270`` = ``Column270``
        ``Column271`` = ``Column271``
        ``Column272`` = ``Column272``
        ``Column273`` = ``Column273``
        ``Column274`` = ``Column274``
        ``Column275`` = ``Column275``
        ``Column276`` = ``Column276``
        ``Column277`` = ``Column277``
        ``Column278`` = ``Column278``
        ``Column279`` = ``Column279``
        ``Column280`` = ``Column280``
        ``Column281`` = ``Column281``
        ``Column282`` = ``Column282``
        ``Column283`` = ``Column283``
        ``Column284`` = ``Column284``
        ``Column285`` = ``Column285``
        ``Column286`` = ``Column286``
        ``Column287`` = ``Column287``
        ``Column288`` = ``Column288``
        ``Column289`` = ``Column289``
        ``Column290`` = ``Column290``
        ``Column291`` = ``Column291``
        ``Column292`` = ``Column292``
        ``Column293`` = ``Column293``
        ``Column294`` = ``Column294``
        ``Column295`` = ``Column295``
        ``Column296`` = ``Column296``
        ``Column297`` = ``Column297``
        ``Column298`` = ``Column298``
        ``Column299`` = ``Column299``
        ``Column300`` = ``Column300``
        ``Column301`` = ``Column301``
        ``Column302`` = ``Column302``
        ``Column303`` = ``Column303``
        ``Column304`` = ``Column304``
        ``Column305`` = ``Column305``
        ``Column306`` = ``Column306``
        ``Column307`` = ``Column307``
        ``Column308`` = ``Column308``
        ``Column309`` = ``Column309``
        ``Column310`` = ``Column310``
        ``Column311`` = ``Column311``
        ``Column312`` = ``Column312``
        ``Column313`` = ``Column313``
        ``Column314`` = ``Column314``
        ``Column315`` = ``Column315``
        ``Column316`` = ``Column316``
        ``Column317`` = ``Column317``
        ``Column318`` = ``Column318``
        ``Column319`` = ``Column319``
        ``Column320`` = ``Column320``
        ``Column321`` = ``Column321``
        ``Column322`` = ``Column322``
        ``Column323`` = ``Column323``
        ``Column324`` = ``Column324``
        ``Column325`` = ``Column325``
        ``Column326`` = ``Column326``
        ``Column327`` = ``Column327``
        ``Column328`` = ``Column328``
        ``Column329`` = ``Column329``
        ``Column330`` = ``Column330``
        ``Column331`` = ``Column331``
        ``Column332`` = ``Column332``
        ``Column333`` = ``Column333``
        ``Column334`` = ``Column334``
        ``Column335`` = ``Column335``
        ``Column336`` = ``Column336``
        ``Column337`` = ``Column337``
        ``Column338`` = ``Column338``
        ``Column339`` = ``Column339``
        ``Column340`` = ``Column340``
        ``Column341`` = ``Column341``
        ``Column342`` = ``Column342``
        ``Column343`` = ``Column343``
        ``Column344`` = ``Column344``
        ``Column345`` = ``Column345``
        ``Column346`` = ``Column346``
        ``Column347`` = ``Column347``
        ``Column348`` = ``Column348``
        ``Column349`` = ``Column349``
        ``Column350`` = ``Column350``
        ``Column351`` = ``Column351``
        ``Column352`` = ``Column352``
        ``Column353`` = ``Column353``
        ``Column354`` = ``Column354``
        ``Column355`` = ``Column355``
        ``Column356`` = ``Column356``
        ``Column357`` = ``Column357``
        ``Column358`` = ``Column358``
        ``Column359`` = ``Column359``
        ``Column360`` = ``Column360``
        ``Column361`` = ``Column361``
        ``Column362`` = ``Column362``
        ``Column363`` = ``Column363``
        ``Column364`` = ``Column364``
        ``Column365`` = ``Column365``
        ``Column366`` = ``Column366``
        ``Column367`` = ``Column367``
        ``Column368`` = ``Column368``
        ``Column369`` = ``Column369``
        ``Column370`` = ``Column370``
        ``Column371`` = ``Column371``
        ``Column372`` = ``Column372``
        ``Column373`` = ``Column373``
        ``Column374`` = ``Column374``
        ``Column375`` = ``Column375``
        ``Column376`` = ``Column376``
        ``Column377`` = ``Column377``
        ``Column378`` = ``Column378``
        ``Column379`` = ``Column379``
        ``Column380`` = ``Column380``
        ``Column381`` = ``Column381``
        ``Column382`` = ``Column382``
        ``Column383`` = ``Column383``
        ``Column384`` = ``Column384``
        ``Column385`` = ``Column385``
        ``Column386`` = ``Column386``
        ``Column387`` = ``Column387``
        ``Column388`` = ``Column388``
        ``Column389`` = ``Column389``
        ``Column390`` = ``Column390``
        ``Column391`` = ``Column391``
        ``Column392`` = ``Column392``
        ``Column393`` = ``Column393``
        ``Column394`` = ``Column394``
        ``Column395`` = ``Column395``
        ``Column396`` = ``Column396``
        ``Column397`` = ``Column397``
        ``Column398`` = ``Column398``
        ``Column399`` = ``Column399``
        ``Column400`` = ``Column400``
        ``Column401`` = ``Column401``
        ``Column402`` = ``Column402``
        ``Column403`` = ``Column403``
        ``Column404`` = ``Column404``
        ``Column405`` = ``Column405``
        ``Column406`` = ``Column406``
        ``Column407`` = ``Column407``
        ``Column408`` = ``Column408``
        ``Column409`` = ``Column409``
        ``Column410`` = ``Column410``
        ``Column411`` = ``Column411``
        ``Column412`` = ``Column412``
        ``Column413`` = ``Column413``
        ``Column414`` = ``Column414``
        ``Column415`` = ``Column415``
        ``Column416`` = ``Column416``
        ``Column417`` = ``Column417``
        ``Column418`` = ``Column418``
        ``Column419`` = ``Column419``
        ``Column420`` = ``Column420``
        ``Column421`` = ``Column421``
        ``Column422`` = ``Column422``
        ``Column423`` = ``Column423``
        ``Column424`` = ``Column424``
        ``Column425`` = ``Column425``
        ``Column426`` = ``Column426``
        ``Column427`` = ``Column427``
        ``Column428`` = ``Column428``
        ``Column429`` = ``Column429``
        ``Column430`` = ``Column430``
        ``Column431`` = ``Column431``
        ``Column432`` = ``Column432``
        ``Column433`` = ``Column433``
        ``Column434`` = ``Column434``
        ``Column435`` = ``Column435``
        ``Column436`` = ``Column436``
        ``Column437`` = ``Column437``
        ``Column438`` = ``Column438``
        ``Column439`` = ``Column439``
        ``Column440`` = ``Column440``
        ``Column441`` = ``Column441``
        ``Column442`` = ``Column442``
        ``Column443`` = ``Column443``
        ``Column444`` = ``Column444``
        ``Column445`` = ``Column445``
        ``Column446`` = ``Column446``
        ``Column447`` = ``Column447``
        ``Column448`` = ``Column448``
        ``Column449`` = ``Column449``
        ``Column450`` = ``Column450``
        ``Column451`` = ``Column451``
        ``Column452`` = ``Column452``
        ``Column453`` = ``Column453``
        ``Column454`` = ``Column454``
        ``Column455`` = ``Column455``
        ``Column456`` = ``Column456``
        ``Column457`` = ``Column457``
        ``Column458`` = ``Column458``
        ``Column459`` = ``Column459``
        ``Column460`` = ``Column460``
        ``Column461`` = ``Column461``
        ``Column462`` = ``Column462``
        ``Column463`` = ``Column463``
        ``Column464`` = ``Column464``
        ``Column465`` = ``Column465``
        ``Column466`` = ``Column466``
        ``Column467`` = ``Column467``
        ``Column468`` = ``Column468``
        ``Column469`` = ``Column469``
        ``Column470`` = ``Column470``
        ``Column471`` = ``Column471``
        ``Column472`` = ``Column472``
        ``Column473`` = ``Column473``
        ``Column474`` = ``Column474``
        ``Column475`` = ``Column475``
        ``Column476`` = ``Column476``
        ``Column477`` = ``Column477``
        ``Column478`` = ``Column478``
        ``Column479`` = ``Column479``
        ``Column480`` = ``Column480``
        ``Column481`` = ``Column481``
        ``Column482`` = ``Column482``
        ``Column483`` = ``Column483``
        ``Column484`` = ``Column484``
        ``Column485`` = ``Column485``
        ``Column486`` = ``Column486``
        ``Column487`` = ``Column487``
        ``Column488`` = ``Column488``
        ``Column489`` = ``Column489``
        ``Column490`` = ``Column490``
        ``Column491`` = ``Column491``
        ``Column492`` = ``Column492``
        ``Column493`` = ``Column493``
        ``Column494`` = ``Column494``
        ``Column495`` = ``Column495``
        ``Column496`` = ``Column496``
        ``Column497`` = ``Column497``
        ``Column498`` = ``Column498``
        ``Column499`` = ``Column499``
        ``Column500`` = ``Column500``
        ``Column501`` = ``Column501``
        ``Column502`` = ``Column502``
        ``Column503`` = ``Column503``
        ``Column504`` = ``Column504``
        ``Column505`` = ``Column505``
        ``Column506`` = ``Column506``
        ``Column507`` = ``Column507``
        ``Column508`` = ``Column508``
        ``Column509`` = ``Column509``
        ``Column510`` = ``Column510``
        ``Column511`` = ``Column511``
        ``Column512`` = ``Column512``
        ``Column513`` = ``Column513``
        ``Column514`` = ``Column514``
        ``Column515`` = ``Column515``
        ``Column516`` = ``Column516``
        ``Column517`` = ``Column517``
        ``Column518`` = ``Column518``
        ``Column519`` = ``Column519``
        ``Column520`` = ``Column520``
        ``Column521`` = ``Column521``
        ``Column522`` = ``Column522``
        ``Column523`` = ``Column523``
        ``Column524`` = ``Column524``
        ``Column525`` = ``Column525``
        ``Column526`` = ``Column526``
        ``Column527`` = ``Column527``
        ``Column528`` = ``Column528``
        ``Column529`` = ``Column529``
        ``Column530`` = ``Column530``
        ``Column531`` = ``Column531``
        ``Column532`` = ``Column532``
        ``Column533`` = ``Column533``
        ``Column534`` = ``Column534``
        ``Column535`` = ``Column535``
        ``Column536`` = ``Column536``
        ``Column537`` = ``Column537``
        ``Column538`` = ``Column538``
        ``Column539`` = ``Column539``
        ``Column540`` = ``Column540``
        ``Column541`` = ``Column541``
        ``Column542`` = ``Column542``
        ``Column543`` = ``Column543``
        ``Column544`` = ``Column544``
        ``Column545`` = ``Column545``
        ``Column546`` = ``Column546``
        ``Column547`` = ``Column547``
        ``Column548`` = ``Column548``
        ``Column549`` = ``Column549``
        ``Column550`` = ``Column550``
        ``Column551`` = ``Column551``
        ``Column552`` = ``Column552``
        ``Column553`` = ``Column553``
        ``Column554`` = ``Column554``
        ``Column555`` = ``Column555``
        ``Column556`` = ``Column556``
        ``Column557`` = ``Column557``
        ``Column558`` = ``Column558``
        ``Column559`` = ``Column559``
        ``Column560`` = ``Column560``
        ``Column561`` = ``Column561``
        ``Column562`` = ``Column562``
        ``Column563`` = ``Column563``
        ``Column564`` = ``Column564``
        ``Column565`` = ``Column565``
        ``Column566`` = ``Column566``
        ``Column567`` = ``Column567``
        ``Column568`` = ``Column568``
        ``Column569`` = ``Column569``
        ``Column570`` = ``Column570``
        ``Column571`` = ``Column571``
        ``Column572`` = ``Column572``
        ``Column573`` = ``Column573``
        ``Column574`` = ``Column574``
        ``Column575`` = ``Column575``
        ``Column576`` = ``Column576``
        ``Column577`` = ``Column577``
        ``Column578`` = ``Column578``
        ``Column579`` = ``Column579``
        ``Column580`` = ``Column580``
        ``Column581`` = ``Column581``
        ``Column582`` = ``Column582``
        ``Column583`` = ``Column583``
        ``Column584`` = ``Column584``
        ``Column585`` = ``Column585``
        ``Column586`` = ``Column586``
        ``Column587`` = ``Column587``
        ``Column588`` = ``Column588``
        ``Column589`` = ``Column589``
        ``Column590`` = ``Column590``
        ``Column591`` = ``Column591``
        ``Column592`` = ``Column592``
        ``Column593`` = ``Column593``
        ``Column594`` = ``Column594``
        ``Column595`` = ``Column595``
        ``Column596`` = ``Column596``
        ``Column597`` = ``Column597``
        ``Column598`` = ``Column598``
        ``Column599`` = ``Column599``
        ``Column600`` = ``Column600``
      |}

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``ManyColumns``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``ManyColumns``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``ManyColumns``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``MaxLengthTypes_All`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- MaxLengthTypes_All
SELECT
  [key],
  [nvarchar],
  [varbinary],
  [varchar]
FROM
  [dbo].[MaxLengthTypes]"""
      userConfigureCmd cmd

    let mutable ``ordinal_key`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_key`` <- reader.GetOrdinal "key"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``MaxLengthTypes`` =
      let ``key`` = reader.GetInt32 ``ordinal_key``
      let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
      let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
      let ``varchar`` = reader.GetString ``ordinal_varchar``
      {
        ``Key`` = ``key``
        ``Nvarchar`` = ``nvarchar``
        ``Varbinary`` = ``varbinary``
        ``Varchar`` = ``varchar``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MaxLengthTypes_All``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MaxLengthTypes_All``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MaxLengthTypes_All``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MaxLengthTypes_ById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- MaxLengthTypes_ById
SELECT
  [key],
  [nvarchar],
  [varbinary],
  [varchar]
FROM
  [dbo].[MaxLengthTypes]
WHERE
  [key] = @key"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_key`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_key`` <- reader.GetOrdinal "key"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``MaxLengthTypes`` =
      let ``key`` = reader.GetInt32 ``ordinal_key``
      let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
      let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
      let ``varchar`` = reader.GetString ``ordinal_varchar``
      {
        ``Key`` = ``key``
        ``Nvarchar`` = ``nvarchar``
        ``Varbinary`` = ``varbinary``
        ``Varchar`` = ``varchar``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``MaxLengthTypes_ById`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MaxLengthTypes_ById``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MaxLengthTypes_ById``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MaxLengthTypes_ById``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
        |]
      ``MaxLengthTypes_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
        |]
      ``MaxLengthTypes_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MaxLengthTypes_Delete_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- MaxLengthTypes_Delete
DELETE FROM [dbo].[MaxLengthTypes]
WHERE
  [key] = @key"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``MaxLengthTypes_Delete`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MaxLengthTypes_Delete``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MaxLengthTypes_Delete``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MaxLengthTypes_Delete``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
        |]
      ``MaxLengthTypes_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
        |]
      ``MaxLengthTypes_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MaxLengthTypes_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- MaxLengthTypes_Insert
INSERT INTO [dbo].[MaxLengthTypes]
(
  [key],
  [nvarchar],
  [varbinary],
  [varchar]
)
VALUES
(
  @key,
  @nvarchar,
  @varbinary,
  @varchar
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``MaxLengthTypes_Insert`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MaxLengthTypes_Insert``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MaxLengthTypes_Insert``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MaxLengthTypes_Insert``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int,
        ``nvarchar``: string,
        ``varbinary``: byte [],
        ``varchar``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 0, Value = ``nvarchar``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = -1, Value = ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = -1, Value = ``varchar``)
        |]
      ``MaxLengthTypes_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 0, Value = (^a: (member ``Nvarchar``: string) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = -1, Value = (^a: (member ``Varbinary``: byte []) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = -1, Value = (^a: (member ``Varchar``: string) dto))
        |]
      ``MaxLengthTypes_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``MaxLengthTypes_InsertBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key``: int,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) : ``args`` =
        [|
          ``key`` |> box
          ``nvarchar`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key``: int) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MaxLengthTypes_InsertBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- MaxLengthTypes_InsertBatch
INSERT INTO [dbo].[MaxLengthTypes]
(
  [key],
  [nvarchar],
  [varbinary],
  [varchar]
)
SELECT
  [key],
  [nvarchar],
  [varbinary],
  [varchar]
FROM #args"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``MaxLengthTypes_InsertBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MaxLengthTypes_InsertBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MaxLengthTypes_InsertBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MaxLengthTypes_InsertBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``MaxLengthTypes_InsertBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key] INT NOT NULL,
              [nvarchar] NVARCHAR(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [varbinary] VARBINARY(MAX) NOT NULL,
              [varchar] VARCHAR(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            4,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``MaxLengthTypes_InsertBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``MaxLengthTypes_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``MaxLengthTypes_InsertBatch``.``args``>) dto)
        )
      ``MaxLengthTypes_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MaxLengthTypes_Merge_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- MaxLengthTypes_Merge
MERGE [dbo].[MaxLengthTypes]
USING
(
  SELECT
    [key] = @key,
    [nvarchar] = @nvarchar,
    [varbinary] = @varbinary,
    [varchar] = @varchar
)
AS x
ON
  [MaxLengthTypes].[key] = x.[key]

WHEN MATCHED THEN
  UPDATE
  SET
    [nvarchar] = x.[nvarchar],
    [varbinary] = x.[varbinary],
    [varchar] = x.[varchar]

WHEN NOT MATCHED THEN
  INSERT
  (
    [key],
    [nvarchar],
    [varbinary],
    [varchar]
  )
  VALUES
  (
    x.[key],
    x.[nvarchar],
    x.[varbinary],
    x.[varchar]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``MaxLengthTypes_Merge`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MaxLengthTypes_Merge``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MaxLengthTypes_Merge``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MaxLengthTypes_Merge``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int,
        ``nvarchar``: string,
        ``varbinary``: byte [],
        ``varchar``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 0, Value = ``nvarchar``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = -1, Value = ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = -1, Value = ``varchar``)
        |]
      ``MaxLengthTypes_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 0, Value = (^a: (member ``Nvarchar``: string) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = -1, Value = (^a: (member ``Varbinary``: byte []) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = -1, Value = (^a: (member ``Varchar``: string) dto))
        |]
      ``MaxLengthTypes_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``MaxLengthTypes_MergeBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key``: int,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) : ``args`` =
        [|
          ``key`` |> box
          ``nvarchar`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key``: int) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MaxLengthTypes_MergeBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- MaxLengthTypes_MergeBatch
MERGE [dbo].[MaxLengthTypes]
USING
  #args
AS x
ON
  [MaxLengthTypes].[key] = x.[key]

WHEN MATCHED THEN
  UPDATE
  SET
    [nvarchar] = x.[nvarchar],
    [varbinary] = x.[varbinary],
    [varchar] = x.[varchar]

WHEN NOT MATCHED THEN
  INSERT
  (
    [key],
    [nvarchar],
    [varbinary],
    [varchar]
  )
  VALUES
  (
    x.[key],
    x.[nvarchar],
    x.[varbinary],
    x.[varchar]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``MaxLengthTypes_MergeBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MaxLengthTypes_MergeBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MaxLengthTypes_MergeBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MaxLengthTypes_MergeBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``MaxLengthTypes_MergeBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key] INT NOT NULL,
              [nvarchar] NVARCHAR(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [varbinary] VARBINARY(MAX) NOT NULL,
              [varchar] VARCHAR(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              PRIMARY KEY ([key])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            4,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``MaxLengthTypes_MergeBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``MaxLengthTypes_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``MaxLengthTypes_MergeBatch``.``args``>) dto)
        )
      ``MaxLengthTypes_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MaxLengthTypes_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- MaxLengthTypes_Update
UPDATE
  [dbo].[MaxLengthTypes]
SET
  [nvarchar] = @nvarchar,
  [varbinary] = @varbinary,
  [varchar] = @varchar
WHERE
  [key] = @key"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``MaxLengthTypes_Update`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MaxLengthTypes_Update``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MaxLengthTypes_Update``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MaxLengthTypes_Update``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key``: int,
        ``nvarchar``: string,
        ``varbinary``: byte [],
        ``varchar``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = ``key``)
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 0, Value = ``nvarchar``)
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = -1, Value = ``varbinary``)
          SqlParameter("varchar", SqlDbType.VarChar, Size = -1, Value = ``varchar``)
        |]
      ``MaxLengthTypes_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key", SqlDbType.Int, Value = (^a: (member ``Key``: int) dto))
          SqlParameter("nvarchar", SqlDbType.NVarChar, Size = 0, Value = (^a: (member ``Nvarchar``: string) dto))
          SqlParameter("varbinary", SqlDbType.VarBinary, Size = -1, Value = (^a: (member ``Varbinary``: byte []) dto))
          SqlParameter("varchar", SqlDbType.VarChar, Size = -1, Value = (^a: (member ``Varchar``: string) dto))
        |]
      ``MaxLengthTypes_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``MaxLengthTypes_UpdateBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``key``: int,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) : ``args`` =
        [|
          ``key`` |> box
          ``nvarchar`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``key``: int) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MaxLengthTypes_UpdateBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- MaxLengthTypes_UpdateBatch
UPDATE
  [dbo].[MaxLengthTypes]
SET
  [nvarchar] = x.[nvarchar],
  [varbinary] = x.[varbinary],
  [varchar] = x.[varchar]
FROM
  [dbo].[MaxLengthTypes]
INNER JOIN
  #args AS x
    ON
      [MaxLengthTypes].[key] = x.[key]"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``MaxLengthTypes_UpdateBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MaxLengthTypes_UpdateBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MaxLengthTypes_UpdateBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MaxLengthTypes_UpdateBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``MaxLengthTypes_UpdateBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [key] INT NOT NULL,
              [nvarchar] NVARCHAR(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              [varbinary] VARBINARY(MAX) NOT NULL,
              [varchar] VARCHAR(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
              PRIMARY KEY ([key])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            4,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``MaxLengthTypes_UpdateBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``MaxLengthTypes_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``MaxLengthTypes_UpdateBatch``.``args``>) dto)
        )
      ``MaxLengthTypes_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``MultipleTempTables`` =


    type ``tempTable1`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col2``: string option
        ) : ``tempTable1`` =
        [|
          ``Col1`` |> box
          Option.toDbNull ``Col2`` |> box
        |]
        |> fun fields -> ``tempTable1``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTable1`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
        |]
        |> fun fields -> ``tempTable1``(internalUseOnlyValue, fields)


    type ``tempTable2`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col3``: string
        ) : ``tempTable2`` =
        [|
          ``Col1`` |> box
          ``Col3`` |> box
        |]
        |> fun fields -> ``tempTable2``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTable2`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          (^a: (member ``Col3``: string) dto) |> box
        |]
        |> fun fields -> ``tempTable2``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MultipleTempTables_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- MultipleTempTables.sql
SELECT
  t1.Col1,
  t1.Col2,
  t2.Col3
FROM
  #tempTable1 t1
INNER JOIN
  #tempTable2 t2
    ON t2.Col1 = t1.Col1"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0
    let mutable ``ordinal_Col3`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"
      ``ordinal_Col3`` <- reader.GetOrdinal "Col3"

    let getItem (reader: SqlDataReader) =
      let ``Col1`` = reader.GetInt32 ``ordinal_Col1``
      let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetString ``ordinal_Col2`` |> Some
      let ``Col3`` = reader.GetString ``ordinal_Col3``
      {|
        ``Col1`` = ``Col1``
        ``Col2`` = ``Col2``
        ``Col3`` = ``Col3``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``MultipleTempTables`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``MultipleTempTables``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MultipleTempTables``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``MultipleTempTables``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTable1``: seq<``MultipleTempTables``.``tempTable1``>,
        ``tempTable2``: seq<``MultipleTempTables``.``tempTable2``>
      ) =
      [
        TempTableData
          (
            "#tempTable1",
            """
            CREATE TABLE #tempTable1 (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
            """,
            (``tempTable1`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
        TempTableData
          (
            "#tempTable2",
            """
            CREATE TABLE #tempTable2 (Col1 INT NOT NULL, Col3 NVARCHAR(42) NOT NULL)
            """,
            (``tempTable2`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTable1``: seq<``MultipleTempTables``.``tempTable1``>,
        ``tempTable2``: seq<``MultipleTempTables``.``tempTable2``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTable1``,
          ``tempTable2``
        )
      ``MultipleTempTables_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTable1``: #seq<``MultipleTempTables``.``tempTable1``>) dto),
          (^a: (member ``TempTable2``: #seq<``MultipleTempTables``.``tempTable2``>) dto)
        )
      ``MultipleTempTables_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  type ``NominalResult_Result`` =
    {
      ``TableCol1``: string
      ``TableCol2``: int option
    }


  type ``NominalResult`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- NominalResult.sql
SELECT * FROM Table1"""
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``NominalResult``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``NominalResult``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``NominalResult``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``NormalParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- NormalParams.sql
SELECT * FROM Table1 WHERE TableCol1 = @col1"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``NormalParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``NormalParams``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``NormalParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``NormalParams``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``col1``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@col1", SqlDbType.NVarChar, Size = 42, Value = ``col1``)
        |]
      ``NormalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@col1", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Col1``: string) dto))
        |]
      ``NormalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``OptionRecompileAndFetch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- OptionRecompileAndFetch.sql
-- Use an extended sproc to force sp_describe_first_result_set to fail
-- and parser to fallback to SET FMTONLY ON
EXEC sp_getapplock 'TestLock', 'Update'

SELECT
  *
FROM
  Table1
ORDER BY
  TableCol1
OFFSET @offset ROWS
FETCH NEXT @limit ROWS ONLY

-- Together with FETCH above, this will for some reason cause SET FMTONLY ON to fail if --
-- @limit is NULL, meaning that the parameter will have to be added with an actual value even
-- for SET FMTONLY ON
OPTION (RECOMPILE)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``OptionRecompileAndFetch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``OptionRecompileAndFetch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``OptionRecompileAndFetch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``OptionRecompileAndFetch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``offset``: int64,
        ``limit``: int64
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@offset", SqlDbType.BigInt, Value = ``offset``)
          SqlParameter("@limit", SqlDbType.BigInt, Value = ``limit``)
        |]
      ``OptionRecompileAndFetch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@offset", SqlDbType.BigInt, Value = (^a: (member ``Offset``: int64) dto))
          SqlParameter("@limit", SqlDbType.BigInt, Value = (^a: (member ``Limit``: int64) dto))
        |]
      ``OptionRecompileAndFetch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  type ``OptionTableWithoutDto_All`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- OptionTableWithoutDto_All
SELECT
  [Col1],
  [Col2]
FROM
  [dbo].[OptionTableWithoutDto]"""
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``OptionTableWithDto`` =
      let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
      let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
      {
        ``Col1`` = ``Col1``
        ``Col2`` = ``Col2``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``OptionTableWithoutDto_All``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``OptionTableWithoutDto_All``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``OptionTableWithoutDto_All``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``OverriddenDtoParamName_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- OverriddenDtoParamName.sql
SELECT @nameToBeOverridden"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let initOrdinals = ignore<SqlDataReader>

    let getItem (reader: SqlDataReader) =
      if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``OverriddenDtoParamName`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``OverriddenDtoParamName``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``OverriddenDtoParamName``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``OverriddenDtoParamName``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``nameToBeOverridden``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = ``nameToBeOverridden``)
        |]
      ``OverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = (^a: (member ``newDtoParamName``: int) dto))
        |]
      ``OverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``ParamInheritance_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- ParamInheritance.sql
SELECT
  Col1 = @col1,
  Col2 = @col2,
  Col3 = @col3"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0
    let mutable ``ordinal_Col3`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"
      ``ordinal_Col3`` <- reader.GetOrdinal "Col3"

    let getItem (reader: SqlDataReader) =
      let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetInt32 ``ordinal_Col1`` |> Some
      let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt64 ``ordinal_Col2`` |> Some
      let ``Col3`` = if reader.IsDBNull ``ordinal_Col3`` then None else reader.GetBoolean ``ordinal_Col3`` |> Some
      {|
        ``Col1`` = ``Col1``
        ``Col2`` = ``Col2``
        ``Col3`` = ``Col3``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``ParamInheritance`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``ParamInheritance``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``ParamInheritance``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``ParamInheritance``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``col1``: int option,
        ``col2``: int64,
        ``col3``: bool option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@col1", SqlDbType.Int, Value = Option.toDbNull ``col1``)
          SqlParameter("@col2", SqlDbType.BigInt, Value = ``col2``)
          SqlParameter("@col3", SqlDbType.Bit, Value = Option.toDbNull ``col3``)
        |]
      ``ParamInheritance_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@col1", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Col1``: int option) dto))
          SqlParameter("@col2", SqlDbType.BigInt, Value = (^a: (member ``Col2``: int64) dto))
          SqlParameter("@col3", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Col3``: bool option) dto))
        |]
      ``ParamInheritance_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``ParamsUsedTwice_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- ParamsUsedTwice.sql
SELECT * FROM Table1 WHERE TableCol1 = @col1 AND TableCol1 = @col1"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``ParamsUsedTwice`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``ParamsUsedTwice``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``ParamsUsedTwice``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``ParamsUsedTwice``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``col1``: string option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@col1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``col1``)
        |]
      ``ParamsUsedTwice_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@col1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Col1``: string option) dto))
        |]
      ``ParamsUsedTwice_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  type ``SelectAllFromTable`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- SelectAllFromTable.sql
SELECT * FROM Table1"""
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``SelectAllFromTable``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``SelectAllFromTable``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``SelectAllFromTable``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``SingleRecordCol`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- SingleRecordCol.sql
SELECT Test = 1"""
      userConfigureCmd cmd

    let mutable ``ordinal_Test`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Test`` <- reader.GetOrdinal "Test"

    let getItem (reader: SqlDataReader) =
      let ``Test`` = reader.GetInt32 ``ordinal_Test``
      {|
        ``Test`` = ``Test``
      |}

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``SingleRecordCol``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``SingleRecordCol``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``SingleRecordCol``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  type ``SkippedUnsupportedColumn`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- SkippedUnsupportedColumn.sql
DECLARE @hid HIERARCHYID

SELECT
  SupportedCol1 = 1,
  SupportedCol2 = 'test',
  UnsupportedCol = @hid"""
      userConfigureCmd cmd

    let mutable ``ordinal_SupportedCol1`` = 0
    let mutable ``ordinal_SupportedCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_SupportedCol1`` <- reader.GetOrdinal "SupportedCol1"
      ``ordinal_SupportedCol2`` <- reader.GetOrdinal "SupportedCol2"

    let getItem (reader: SqlDataReader) =
      let ``SupportedCol1`` = reader.GetInt32 ``ordinal_SupportedCol1``
      let ``SupportedCol2`` = reader.GetString ``ordinal_SupportedCol2``
      {|
        ``SupportedCol1`` = ``SupportedCol1``
        ``SupportedCol2`` = ``SupportedCol2``
      |}

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``SkippedUnsupportedColumn``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``SkippedUnsupportedColumn``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``SkippedUnsupportedColumn``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``StartsWithCTE_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- StartsWithCTE.sql
WITH cte AS (SELECT * FROM @tvp)

SELECT * FROM CTE"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let initOrdinals = ignore<SqlDataReader>

    let getItem (reader: SqlDataReader) =
      if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``StartsWithCTE`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``StartsWithCTE``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``StartsWithCTE``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``StartsWithCTE``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``tvp``: seq<TableTypes.``dbo``.``SingleColNull``>
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = boxNullIfEmpty ``tvp``)
        |]
      ``StartsWithCTE_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = boxNullIfEmpty (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``SingleColNull``>) dto))
        |]
      ``StartsWithCTE_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Table1_ByTableCol1_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Table1_ByTableCol1
SELECT
  [TableCol1],
  [TableCol2]
FROM
  [dbo].[Table1]
WHERE
  [TableCol1] = @tableCol1"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``Table1_ByTableCol1`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Table1_ByTableCol1``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Table1_ByTableCol1``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Table1_ByTableCol1``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``tableCol1``: string
      ) =
      let getSqlParams () =
        [|
          SqlParameter("tableCol1", SqlDbType.NVarChar, Size = 42, Value = ``tableCol1``)
        |]
      ``Table1_ByTableCol1_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("tableCol1", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``TableCol1``: string) dto))
        |]
      ``Table1_ByTableCol1_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Table1_ByTableCol2_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Table1_ByTableCol2
SELECT
  [TableCol1],
  [TableCol2]
FROM
  [dbo].[Table1]
WHERE
  [TableCol2] = @tableCol2"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``Table1_ByTableCol2`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Table1_ByTableCol2``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Table1_ByTableCol2``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Table1_ByTableCol2``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``tableCol2``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("tableCol2", SqlDbType.Int, Value = ``tableCol2``)
        |]
      ``Table1_ByTableCol2_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("tableCol2", SqlDbType.Int, Value = (^a: (member ``TableCol2``: int) dto))
        |]
      ``Table1_ByTableCol2_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Table1_ByTableCol2s_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Table1_ByTableCol2s
SELECT
  [TableCol1],
  [TableCol2]
FROM
  [dbo].[Table1]
WHERE
  EXISTS (
    SELECT * FROM @ids ids
    WHERE
      ids.[Foo] = [Table1].TableCol2
  )"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      {
        ``TableCol1`` = ``TableCol1``
        ``TableCol2`` = ``TableCol2``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``Table1_ByTableCol2s`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Table1_ByTableCol2s``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Table1_ByTableCol2s``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Table1_ByTableCol2s``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``ids``: seq<TableTypes.``dbo``.``SingleColNonNull``>
      ) =
      let getSqlParams () =
        [|
          SqlParameter("ids", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty ``ids``)
        |]
      ``Table1_ByTableCol2s_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("ids", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty (^a: (member ``Ids``: #seq<TableTypes.``dbo``.``SingleColNonNull``>) dto))
        |]
      ``Table1_ByTableCol2s_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  type ``TableDtoWithDifferentColumnOrder`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableDtoWithDifferentColumnOrder.sql
SELECT TableCol2, TableCol1 FROM dbo.Table1"""
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol2`` = 0
    let mutable ``ordinal_TableCol1`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
      let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
      {
        ``TableCol2`` = ``TableCol2``
        ``TableCol1`` = ``TableCol1``
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableDtoWithDifferentColumnOrder``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableDtoWithDifferentColumnOrder``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableDtoWithDifferentColumnOrder``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecute() =
      executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_Insert
INSERT INTO [dbo].[TableWithComputedCol]
(
  [Id],
  [Foo]
)
VALUES
(
  @id,
  @foo
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_Insert`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_Insert``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_Insert``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_Insert``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``foo``: int64
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
        |]
      ``TableWithComputedCol_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
        |]
      ``TableWithComputedCol_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_Insert_WithSkipFalse_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_Insert_WithSkipFalse
INSERT INTO [dbo].[TableWithComputedCol]
(
  [Id],
  [Foo]
)
VALUES
(
  @id,
  @foo
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_Insert_WithSkipFalse`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_Insert_WithSkipFalse``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_Insert_WithSkipFalse``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_Insert_WithSkipFalse``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``foo``: int64
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
        |]
      ``TableWithComputedCol_Insert_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
        |]
      ``TableWithComputedCol_Insert_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``TableWithComputedCol_InsertBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Foo``: int64
        ) : ``args`` =
        [|
          ``Id`` |> box
          ``Foo`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          (^a: (member ``Foo``: int64) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_InsertBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_InsertBatch
INSERT INTO [dbo].[TableWithComputedCol]
(
  [Id],
  [Foo]
)
SELECT
  [Id],
  [Foo]
FROM #args"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_InsertBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_InsertBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_InsertBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_InsertBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithComputedCol_InsertBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Foo] BIGINT NOT NULL
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithComputedCol_InsertBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithComputedCol_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithComputedCol_InsertBatch``.``args``>) dto)
        )
      ``TableWithComputedCol_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TableWithComputedCol_InsertBatch_WithSkipFalse`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Foo``: int64
        ) : ``args`` =
        [|
          ``Id`` |> box
          ``Foo`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          (^a: (member ``Foo``: int64) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_InsertBatch_WithSkipFalse_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_InsertBatch_WithSkipFalse
INSERT INTO [dbo].[TableWithComputedCol]
(
  [Id],
  [Foo]
)
SELECT
  [Id],
  [Foo]
FROM #args"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_InsertBatch_WithSkipFalse`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_InsertBatch_WithSkipFalse``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_InsertBatch_WithSkipFalse``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_InsertBatch_WithSkipFalse``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithComputedCol_InsertBatch_WithSkipFalse``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Foo] BIGINT NOT NULL
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithComputedCol_InsertBatch_WithSkipFalse``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithComputedCol_InsertBatch_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithComputedCol_InsertBatch_WithSkipFalse``.``args``>) dto)
        )
      ``TableWithComputedCol_InsertBatch_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_Merge_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_Merge
MERGE [dbo].[TableWithComputedCol]
USING
(
  SELECT
    [Id] = @id,
    [Foo] = @foo
)
AS x
ON
  [TableWithComputedCol].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Foo] = x.[Foo]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Id],
    [Foo]
  )
  VALUES
  (
    x.[Id],
    x.[Foo]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_Merge`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_Merge``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_Merge``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_Merge``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``foo``: int64
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
        |]
      ``TableWithComputedCol_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
        |]
      ``TableWithComputedCol_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_Merge_WithSkipFalse_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_Merge_WithSkipFalse
MERGE [dbo].[TableWithComputedCol]
USING
(
  SELECT
    [Id] = @id,
    [Foo] = @foo
)
AS x
ON
  [TableWithComputedCol].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Foo] = x.[Foo]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Id],
    [Foo]
  )
  VALUES
  (
    x.[Id],
    x.[Foo]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_Merge_WithSkipFalse`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_Merge_WithSkipFalse``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_Merge_WithSkipFalse``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_Merge_WithSkipFalse``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``foo``: int64
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
        |]
      ``TableWithComputedCol_Merge_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
        |]
      ``TableWithComputedCol_Merge_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``TableWithComputedCol_MergeBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Foo``: int64
        ) : ``args`` =
        [|
          ``Id`` |> box
          ``Foo`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          (^a: (member ``Foo``: int64) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_MergeBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_MergeBatch
MERGE [dbo].[TableWithComputedCol]
USING
  #args
AS x
ON
  [TableWithComputedCol].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Foo] = x.[Foo]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Id],
    [Foo]
  )
  VALUES
  (
    x.[Id],
    x.[Foo]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_MergeBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_MergeBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_MergeBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_MergeBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithComputedCol_MergeBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Foo] BIGINT NOT NULL,
              PRIMARY KEY ([Id])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithComputedCol_MergeBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithComputedCol_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithComputedCol_MergeBatch``.``args``>) dto)
        )
      ``TableWithComputedCol_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TableWithComputedCol_MergeBatch_WithSkipFalse`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Foo``: int64
        ) : ``args`` =
        [|
          ``Id`` |> box
          ``Foo`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          (^a: (member ``Foo``: int64) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_MergeBatch_WithSkipFalse_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_MergeBatch_WithSkipFalse
MERGE [dbo].[TableWithComputedCol]
USING
  #args
AS x
ON
  [TableWithComputedCol].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Foo] = x.[Foo]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Id],
    [Foo]
  )
  VALUES
  (
    x.[Id],
    x.[Foo]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_MergeBatch_WithSkipFalse`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_MergeBatch_WithSkipFalse``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_MergeBatch_WithSkipFalse``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_MergeBatch_WithSkipFalse``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithComputedCol_MergeBatch_WithSkipFalse``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Foo] BIGINT NOT NULL,
              PRIMARY KEY ([Id])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithComputedCol_MergeBatch_WithSkipFalse``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithComputedCol_MergeBatch_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithComputedCol_MergeBatch_WithSkipFalse``.``args``>) dto)
        )
      ``TableWithComputedCol_MergeBatch_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_Update
UPDATE
  [dbo].[TableWithComputedCol]
SET
  [Foo] = @foo
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_Update`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_Update``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_Update``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_Update``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``foo``: int64
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
        |]
      ``TableWithComputedCol_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
        |]
      ``TableWithComputedCol_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_Update_WithSkipFalse_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_Update_WithSkipFalse
UPDATE
  [dbo].[TableWithComputedCol]
SET
  [Foo] = @foo
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_Update_WithSkipFalse`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_Update_WithSkipFalse``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_Update_WithSkipFalse``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_Update_WithSkipFalse``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``foo``: int64
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
        |]
      ``TableWithComputedCol_Update_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
        |]
      ``TableWithComputedCol_Update_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``TableWithComputedCol_UpdateBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Foo``: int64
        ) : ``args`` =
        [|
          ``Id`` |> box
          ``Foo`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          (^a: (member ``Foo``: int64) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_UpdateBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_UpdateBatch
UPDATE
  [dbo].[TableWithComputedCol]
SET
  [Foo] = x.[Foo]
FROM
  [dbo].[TableWithComputedCol]
INNER JOIN
  #args AS x
    ON
      [TableWithComputedCol].[Id] = x.[Id]"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_UpdateBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_UpdateBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_UpdateBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_UpdateBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithComputedCol_UpdateBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Foo] BIGINT NOT NULL,
              PRIMARY KEY ([Id])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithComputedCol_UpdateBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithComputedCol_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithComputedCol_UpdateBatch``.``args``>) dto)
        )
      ``TableWithComputedCol_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TableWithComputedCol_UpdateBatch_WithSkipFalse`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Foo``: int64
        ) : ``args`` =
        [|
          ``Id`` |> box
          ``Foo`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          (^a: (member ``Foo``: int64) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithComputedCol_UpdateBatch_WithSkipFalse_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithComputedCol_UpdateBatch_WithSkipFalse
UPDATE
  [dbo].[TableWithComputedCol]
SET
  [Foo] = x.[Foo]
FROM
  [dbo].[TableWithComputedCol]
INNER JOIN
  #args AS x
    ON
      [TableWithComputedCol].[Id] = x.[Id]"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithComputedCol_UpdateBatch_WithSkipFalse`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithComputedCol_UpdateBatch_WithSkipFalse``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithComputedCol_UpdateBatch_WithSkipFalse``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithComputedCol_UpdateBatch_WithSkipFalse``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithComputedCol_UpdateBatch_WithSkipFalse``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Foo] BIGINT NOT NULL,
              PRIMARY KEY ([Id])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithComputedCol_UpdateBatch_WithSkipFalse``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithComputedCol_UpdateBatch_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithComputedCol_UpdateBatch_WithSkipFalse``.``args``>) dto)
        )
      ``TableWithComputedCol_UpdateBatch_WithSkipFalse_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_ByColumnsBatch_ReversedColumns_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_ByColumnsBatch_ReversedColumns
SELECT
  [Id],
  [Foo],
  [BAR]
FROM
  [dbo].[TableWithIdentityCol]
WHERE
  EXISTS (
    SELECT * FROM @ids ids
    WHERE
      ids.[Id] = [TableWithIdentityCol].Foo
      AND ids.[Foo] = [TableWithIdentityCol].Id
  )"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0
    let mutable ``ordinal_BAR`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
      ``ordinal_BAR`` <- reader.GetOrdinal "BAR"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``TableWithIdentityCol`` =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      let ``BAR`` = if reader.IsDBNull ``ordinal_BAR`` then None else reader.GetDateTimeOffset ``ordinal_BAR`` |> Some
      {
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
        ``BAR`` = ``BAR``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_ByColumnsBatch_ReversedColumns`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_ByColumnsBatch_ReversedColumns``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_ByColumnsBatch_ReversedColumns``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_ByColumnsBatch_ReversedColumns``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``ids``: seq<TableTypes.``dbo``.``FilterForTableWithIdentityCol``>
      ) =
      let getSqlParams () =
        [|
          SqlParameter("ids", SqlDbType.Structured, TypeName = "dbo.FilterForTableWithIdentityCol", Value = boxNullIfEmpty ``ids``)
        |]
      ``TableWithIdentityCol_ByColumnsBatch_ReversedColumns_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("ids", SqlDbType.Structured, TypeName = "dbo.FilterForTableWithIdentityCol", Value = boxNullIfEmpty (^a: (member ``Ids``: #seq<TableTypes.``dbo``.``FilterForTableWithIdentityCol``>) dto))
        |]
      ``TableWithIdentityCol_ByColumnsBatch_ReversedColumns_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_ByFoo_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_ByFoo
SELECT
  [Id],
  [Foo],
  [BAR]
FROM
  [dbo].[TableWithIdentityCol]
WHERE
  [Foo] = @foo"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0
    let mutable ``ordinal_BAR`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
      ``ordinal_BAR`` <- reader.GetOrdinal "BAR"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``TableWithIdentityCol`` =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      let ``BAR`` = if reader.IsDBNull ``ordinal_BAR`` then None else reader.GetDateTimeOffset ``ordinal_BAR`` |> Some
      {
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
        ``BAR`` = ``BAR``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_ByFoo`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_ByFoo``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_ByFoo``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_ByFoo``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``foo``: int64
      ) =
      let getSqlParams () =
        [|
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
        |]
      ``TableWithIdentityCol_ByFoo_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
        |]
      ``TableWithIdentityCol_ByFoo_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_ById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_ById
SELECT
  [Id],
  [Foo]
FROM
  [dbo].[TableWithIdentityCol]
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"

    let getItem (reader: SqlDataReader) =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      {|
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_ById`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_ById``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_ById``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_ById``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
        |]
      ``TableWithIdentityCol_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
        |]
      ``TableWithIdentityCol_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_ById_WithSelectColumns_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_ById_WithSelectColumns
SELECT
  [Id],
  [Foo]
FROM
  [dbo].[TableWithIdentityCol]
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"

    let getItem (reader: SqlDataReader) =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      {|
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_ById_WithSelectColumns`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_ById_WithSelectColumns``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_ById_WithSelectColumns``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_ById_WithSelectColumns``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
        |]
      ``TableWithIdentityCol_ById_WithSelectColumns_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
        |]
      ``TableWithIdentityCol_ById_WithSelectColumns_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_ByIdAndFoos_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_ByIdAndFoos
SELECT
  [Id],
  [Foo],
  [BAR]
FROM
  [dbo].[TableWithIdentityCol]
WHERE
  EXISTS (
    SELECT * FROM @ids ids
    WHERE
      ids.[Id] = [TableWithIdentityCol].Id
      AND ids.[Foo] = [TableWithIdentityCol].Foo
  )"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0
    let mutable ``ordinal_BAR`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
      ``ordinal_BAR`` <- reader.GetOrdinal "BAR"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``TableWithIdentityCol`` =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      let ``BAR`` = if reader.IsDBNull ``ordinal_BAR`` then None else reader.GetDateTimeOffset ``ordinal_BAR`` |> Some
      {
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
        ``BAR`` = ``BAR``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_ByIdAndFoos`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_ByIdAndFoos``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_ByIdAndFoos``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_ByIdAndFoos``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``ids``: seq<TableTypes.``dbo``.``FilterForTableWithIdentityCol``>
      ) =
      let getSqlParams () =
        [|
          SqlParameter("ids", SqlDbType.Structured, TypeName = "dbo.FilterForTableWithIdentityCol", Value = boxNullIfEmpty ``ids``)
        |]
      ``TableWithIdentityCol_ByIdAndFoos_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("ids", SqlDbType.Structured, TypeName = "dbo.FilterForTableWithIdentityCol", Value = boxNullIfEmpty (^a: (member ``Ids``: #seq<TableTypes.``dbo``.``FilterForTableWithIdentityCol``>) dto))
        |]
      ``TableWithIdentityCol_ByIdAndFoos_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_ByIds_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_ByIds
SELECT
  [Id],
  [Foo],
  [BAR]
FROM
  [dbo].[TableWithIdentityCol]
WHERE
  EXISTS (
    SELECT * FROM @ids ids
    WHERE
      ids.[Foo] = [TableWithIdentityCol].Id
  )"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0
    let mutable ``ordinal_BAR`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
      ``ordinal_BAR`` <- reader.GetOrdinal "BAR"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``TableWithIdentityCol`` =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      let ``BAR`` = if reader.IsDBNull ``ordinal_BAR`` then None else reader.GetDateTimeOffset ``ordinal_BAR`` |> Some
      {
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
        ``BAR`` = ``BAR``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_ByIds`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_ByIds``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_ByIds``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_ByIds``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``ids``: seq<TableTypes.``dbo``.``SingleColNonNull``>
      ) =
      let getSqlParams () =
        [|
          SqlParameter("ids", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty ``ids``)
        |]
      ``TableWithIdentityCol_ByIds_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("ids", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = boxNullIfEmpty (^a: (member ``Ids``: #seq<TableTypes.``dbo``.``SingleColNonNull``>) dto))
        |]
      ``TableWithIdentityCol_ByIds_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_Delete_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_Delete
DELETE FROM [dbo].[TableWithIdentityCol]
OUTPUT
  deleted.[Id],
  deleted.[Foo],
  deleted.[BAR]
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0
    let mutable ``ordinal_BAR`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
      ``ordinal_BAR`` <- reader.GetOrdinal "BAR"

    let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``TableWithIdentityCol`` =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      let ``BAR`` = if reader.IsDBNull ``ordinal_BAR`` then None else reader.GetDateTimeOffset ``ordinal_BAR`` |> Some
      {
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
        ``BAR`` = ``BAR``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_Delete`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_Delete``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_Delete``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_Delete``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
        |]
      ``TableWithIdentityCol_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
        |]
      ``TableWithIdentityCol_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_Insert
INSERT INTO [dbo].[TableWithIdentityCol]
(
  [Foo],
  [BAR]
)
OUTPUT
  inserted.[Id],
  inserted.[Foo]
VALUES
(
  @foo,
  @bar
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"

    let getItem (reader: SqlDataReader) =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      {|
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_Insert`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_Insert``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_Insert``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_Insert``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``foo``: int64,
        ``bar``: DateTimeOffset option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
          SqlParameter("bar", SqlDbType.DateTimeOffset, Size = 10, Value = Option.toDbNull ``bar``)
        |]
      ``TableWithIdentityCol_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
          SqlParameter("bar", SqlDbType.DateTimeOffset, Size = 10, Value = Option.toDbNull (^a: (member ``Bar``: DateTimeOffset option) dto))
        |]
      ``TableWithIdentityCol_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``TableWithIdentityCol_InsertBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Foo``: int64,
          ``BAR``: DateTimeOffset option
        ) : ``args`` =
        [|
          ``Foo`` |> box
          Option.toDbNull ``BAR`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Foo``: int64) dto) |> box
          Option.toDbNull (^a: (member ``BAR``: DateTimeOffset option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_InsertBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_InsertBatch
INSERT INTO [dbo].[TableWithIdentityCol]
(
  [Foo],
  [BAR]
)
OUTPUT
  inserted.[Id],
  inserted.[Foo]
SELECT
  [Foo],
  [BAR]
FROM #args"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"

    let getItem (reader: SqlDataReader) =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      {|
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_InsertBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_InsertBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_InsertBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_InsertBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithIdentityCol_InsertBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Foo] BIGINT NOT NULL,
              [BAR] DATETIMEOFFSET(7) NULL
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithIdentityCol_InsertBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithIdentityCol_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithIdentityCol_InsertBatch``.``args``>) dto)
        )
      ``TableWithIdentityCol_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_Merge_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_Merge
MERGE [dbo].[TableWithIdentityCol]
USING
(
  SELECT
    [Id] = @id,
    [Foo] = @foo,
    [BAR] = @bar
)
AS x
ON
  [TableWithIdentityCol].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Foo] = x.[Foo],
    [BAR] = x.[BAR]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Foo],
    [BAR]
  )
  VALUES
  (
    x.[Foo],
    x.[BAR]
  )
OUTPUT
  inserted.[Id],
  inserted.[Foo]
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"

    let getItem (reader: SqlDataReader) =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      {|
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_Merge`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_Merge``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_Merge``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_Merge``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``foo``: int64,
        ``bar``: DateTimeOffset option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
          SqlParameter("bar", SqlDbType.DateTimeOffset, Size = 10, Value = Option.toDbNull ``bar``)
        |]
      ``TableWithIdentityCol_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
          SqlParameter("bar", SqlDbType.DateTimeOffset, Size = 10, Value = Option.toDbNull (^a: (member ``Bar``: DateTimeOffset option) dto))
        |]
      ``TableWithIdentityCol_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``TableWithIdentityCol_MergeBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Foo``: int64,
          ``BAR``: DateTimeOffset option
        ) : ``args`` =
        [|
          ``Id`` |> box
          ``Foo`` |> box
          Option.toDbNull ``BAR`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          (^a: (member ``Foo``: int64) dto) |> box
          Option.toDbNull (^a: (member ``BAR``: DateTimeOffset option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_MergeBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_MergeBatch
MERGE [dbo].[TableWithIdentityCol]
USING
  #args
AS x
ON
  [TableWithIdentityCol].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Foo] = x.[Foo],
    [BAR] = x.[BAR]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Foo],
    [BAR]
  )
  VALUES
  (
    x.[Foo],
    x.[BAR]
  )
OUTPUT
  inserted.[Id],
  inserted.[Foo]
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"

    let getItem (reader: SqlDataReader) =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      {|
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_MergeBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_MergeBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_MergeBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_MergeBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithIdentityCol_MergeBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Foo] BIGINT NOT NULL,
              [BAR] DATETIMEOFFSET(7) NULL,
              PRIMARY KEY ([Id])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            3,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithIdentityCol_MergeBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithIdentityCol_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithIdentityCol_MergeBatch``.``args``>) dto)
        )
      ``TableWithIdentityCol_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TableWithIdentityCol_MergeBatchWithHoldlock`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Foo``: int64,
          ``BAR``: DateTimeOffset option
        ) : ``args`` =
        [|
          ``Id`` |> box
          ``Foo`` |> box
          Option.toDbNull ``BAR`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          (^a: (member ``Foo``: int64) dto) |> box
          Option.toDbNull (^a: (member ``BAR``: DateTimeOffset option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_MergeBatchWithHoldlock_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_MergeBatchWithHoldlock
MERGE [dbo].[TableWithIdentityCol] WITH (HOLDLOCK)
USING
  #args
AS x
ON
  [TableWithIdentityCol].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Foo] = x.[Foo],
    [BAR] = x.[BAR]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Foo],
    [BAR]
  )
  VALUES
  (
    x.[Foo],
    x.[BAR]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithIdentityCol_MergeBatchWithHoldlock`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_MergeBatchWithHoldlock``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_MergeBatchWithHoldlock``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_MergeBatchWithHoldlock``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithIdentityCol_MergeBatchWithHoldlock``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Foo] BIGINT NOT NULL,
              [BAR] DATETIMEOFFSET(7) NULL,
              PRIMARY KEY ([Id])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            3,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithIdentityCol_MergeBatchWithHoldlock``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithIdentityCol_MergeBatchWithHoldlock_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithIdentityCol_MergeBatchWithHoldlock``.``args``>) dto)
        )
      ``TableWithIdentityCol_MergeBatchWithHoldlock_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_MergeWithHoldlock_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_MergeWithHoldlock
MERGE [dbo].[TableWithIdentityCol] WITH (HOLDLOCK)
USING
(
  SELECT
    [Id] = @id,
    [Foo] = @foo,
    [BAR] = @bAR
)
AS x
ON
  [TableWithIdentityCol].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Foo] = x.[Foo],
    [BAR] = x.[BAR]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Foo],
    [BAR]
  )
  VALUES
  (
    x.[Foo],
    x.[BAR]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``TableWithIdentityCol_MergeWithHoldlock`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_MergeWithHoldlock``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_MergeWithHoldlock``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_MergeWithHoldlock``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``foo``: int64,
        ``bAR``: DateTimeOffset option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
          SqlParameter("bAR", SqlDbType.DateTimeOffset, Size = 10, Value = Option.toDbNull ``bAR``)
        |]
      ``TableWithIdentityCol_MergeWithHoldlock_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
          SqlParameter("bAR", SqlDbType.DateTimeOffset, Size = 10, Value = Option.toDbNull (^a: (member ``BAR``: DateTimeOffset option) dto))
        |]
      ``TableWithIdentityCol_MergeWithHoldlock_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_Update
UPDATE
  [dbo].[TableWithIdentityCol]
SET
  [Foo] = @foo,
  [BAR] = @bar
OUTPUT
  inserted.[Id],
  inserted.[Foo]
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"

    let getItem (reader: SqlDataReader) =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      {|
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_Update`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_Update``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_Update``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_Update``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``foo``: int64,
        ``bar``: DateTimeOffset option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
          SqlParameter("bar", SqlDbType.DateTimeOffset, Size = 10, Value = Option.toDbNull ``bar``)
        |]
      ``TableWithIdentityCol_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
          SqlParameter("bar", SqlDbType.DateTimeOffset, Size = 10, Value = Option.toDbNull (^a: (member ``Bar``: DateTimeOffset option) dto))
        |]
      ``TableWithIdentityCol_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``TableWithIdentityCol_UpdateBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Foo``: int64,
          ``BAR``: DateTimeOffset option
        ) : ``args`` =
        [|
          ``Id`` |> box
          ``Foo`` |> box
          Option.toDbNull ``BAR`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          (^a: (member ``Foo``: int64) dto) |> box
          Option.toDbNull (^a: (member ``BAR``: DateTimeOffset option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithIdentityCol_UpdateBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithIdentityCol_UpdateBatch
UPDATE
  [dbo].[TableWithIdentityCol]
SET
  [Foo] = x.[Foo],
  [BAR] = x.[BAR]
OUTPUT
  inserted.[Id],
  inserted.[Foo]
FROM
  [dbo].[TableWithIdentityCol]
INNER JOIN
  #args AS x
    ON
      [TableWithIdentityCol].[Id] = x.[Id]"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Foo`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"

    let getItem (reader: SqlDataReader) =
      let ``Id`` = reader.GetInt32 ``ordinal_Id``
      let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
      {|
        ``Id`` = ``Id``
        ``Foo`` = ``Foo``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithIdentityCol_UpdateBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithIdentityCol_UpdateBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithIdentityCol_UpdateBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithIdentityCol_UpdateBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``TableWithIdentityCol_UpdateBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Foo] BIGINT NOT NULL,
              [BAR] DATETIMEOFFSET(7) NULL,
              PRIMARY KEY ([Id])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            3,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``TableWithIdentityCol_UpdateBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``TableWithIdentityCol_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``TableWithIdentityCol_UpdateBatch``.``args``>) dto)
        )
      ``TableWithIdentityCol_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TableWithSkippedPkColumn_ById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TableWithSkippedPkColumn_ById
SELECT
  [Key1],
  [Key2]
FROM
  [dbo].[TableWithSkippedPkColumn]
WHERE
  [Key1] = @key1
  AND [Key2] = @key2"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Key1`` = 0
    let mutable ``ordinal_Key2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Key1`` <- reader.GetOrdinal "Key1"
      ``ordinal_Key2`` <- reader.GetOrdinal "Key2"

    let getItem (reader: SqlDataReader) =
      let ``Key1`` = reader.GetInt32 ``ordinal_Key1``
      let ``Key2`` = reader.GetInt32 ``ordinal_Key2``
      {|
        ``Key1`` = ``Key1``
        ``Key2`` = ``Key2``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TableWithSkippedPkColumn_ById`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TableWithSkippedPkColumn_ById``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TableWithSkippedPkColumn_ById``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TableWithSkippedPkColumn_ById``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``key1``: int,
        ``key2``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = ``key1``)
          SqlParameter("key2", SqlDbType.Int, Value = ``key2``)
        |]
      ``TableWithSkippedPkColumn_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("key1", SqlDbType.Int, Value = (^a: (member ``Key1``: int) dto))
          SqlParameter("key2", SqlDbType.Int, Value = (^a: (member ``Key2``: int) dto))
        |]
      ``TableWithSkippedPkColumn_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Temporal_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Temporal_Insert
INSERT INTO [dbo].[Temporal]
(
  [Id],
  [Data]
)
VALUES
(
  @id,
  @data
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Temporal_Insert`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Temporal_Insert``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Temporal_Insert``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Temporal_Insert``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``data``: string option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("data", SqlDbType.NVarChar, Size = 0, Value = Option.toDbNull ``data``)
        |]
      ``Temporal_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("data", SqlDbType.NVarChar, Size = 0, Value = Option.toDbNull (^a: (member ``Data``: string option) dto))
        |]
      ``Temporal_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``Temporal_InsertBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Data``: string option
        ) : ``args`` =
        [|
          ``Id`` |> box
          Option.toDbNull ``Data`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          Option.toDbNull (^a: (member ``Data``: string option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Temporal_InsertBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Temporal_InsertBatch
INSERT INTO [dbo].[Temporal]
(
  [Id],
  [Data]
)
SELECT
  [Id],
  [Data]
FROM #args"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Temporal_InsertBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Temporal_InsertBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Temporal_InsertBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Temporal_InsertBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``Temporal_InsertBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Data] NVARCHAR(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``Temporal_InsertBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``Temporal_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``Temporal_InsertBatch``.``args``>) dto)
        )
      ``Temporal_InsertBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Temporal_Merge_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Temporal_Merge
MERGE [dbo].[Temporal]
USING
(
  SELECT
    [Id] = @id,
    [Data] = @data
)
AS x
ON
  [Temporal].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Data] = x.[Data]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Id],
    [Data]
  )
  VALUES
  (
    x.[Id],
    x.[Data]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Temporal_Merge`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Temporal_Merge``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Temporal_Merge``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Temporal_Merge``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``data``: string option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("data", SqlDbType.NVarChar, Size = 0, Value = Option.toDbNull ``data``)
        |]
      ``Temporal_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("data", SqlDbType.NVarChar, Size = 0, Value = Option.toDbNull (^a: (member ``Data``: string option) dto))
        |]
      ``Temporal_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``Temporal_MergeBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Data``: string option
        ) : ``args`` =
        [|
          ``Id`` |> box
          Option.toDbNull ``Data`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          Option.toDbNull (^a: (member ``Data``: string option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Temporal_MergeBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Temporal_MergeBatch
MERGE [dbo].[Temporal]
USING
  #args
AS x
ON
  [Temporal].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Data] = x.[Data]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Id],
    [Data]
  )
  VALUES
  (
    x.[Id],
    x.[Data]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Temporal_MergeBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Temporal_MergeBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Temporal_MergeBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Temporal_MergeBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``Temporal_MergeBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Data] NVARCHAR(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              PRIMARY KEY ([Id])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``Temporal_MergeBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``Temporal_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``Temporal_MergeBatch``.``args``>) dto)
        )
      ``Temporal_MergeBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Temporal_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Temporal_Update
UPDATE
  [dbo].[Temporal]
SET
  [Data] = @data
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Temporal_Update`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Temporal_Update``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Temporal_Update``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Temporal_Update``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: int,
        ``data``: string option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = ``id``)
          SqlParameter("data", SqlDbType.NVarChar, Size = 0, Value = Option.toDbNull ``data``)
        |]
      ``Temporal_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
          SqlParameter("data", SqlDbType.NVarChar, Size = 0, Value = Option.toDbNull (^a: (member ``Data``: string option) dto))
        |]
      ``Temporal_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``Temporal_UpdateBatch`` =


    type ``args`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Id``: int,
          ``Data``: string option
        ) : ``args`` =
        [|
          ``Id`` |> box
          Option.toDbNull ``Data`` |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``args`` =
        [|
          (^a: (member ``Id``: int) dto) |> box
          Option.toDbNull (^a: (member ``Data``: string option) dto) |> box
        |]
        |> fun fields -> ``args``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Temporal_UpdateBatch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Temporal_UpdateBatch
UPDATE
  [dbo].[Temporal]
SET
  [Data] = x.[Data]
FROM
  [dbo].[Temporal]
INNER JOIN
  #args AS x
    ON
      [Temporal].[Id] = x.[Id]"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Temporal_UpdateBatch`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Temporal_UpdateBatch``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Temporal_UpdateBatch``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Temporal_UpdateBatch``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``args``: seq<``Temporal_UpdateBatch``.``args``>
      ) =
      [
        TempTableData
          (
            "#args",
            """
            DROP TABLE IF EXISTS #args
            CREATE TABLE #args (
              [Id] INT NOT NULL,
              [Data] NVARCHAR(MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
              PRIMARY KEY ([Id])
            )
            """,
            (``args`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``args``: seq<``Temporal_UpdateBatch``.``args``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``args``
        )
      ``Temporal_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``Args``: #seq<``Temporal_UpdateBatch``.``args``>) dto)
        )
      ``Temporal_UpdateBatch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableAllTypesNonNull`` =


    type ``AllTypesNonNull`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Bigint``: int64,
          ``Binary``: byte [],
          ``Bit``: bool,
          ``Char``: string,
          ``Date``: DateTime,
          ``Datetime``: DateTime,
          ``Datetime2``: DateTime,
          ``Datetimeoffset``: DateTimeOffset,
          ``Decimal``: decimal,
          ``Float``: float,
          ``Image``: byte [],
          ``Int``: int,
          ``Money``: decimal,
          ``Nchar``: string,
          ``Ntext``: string,
          ``Numeric``: decimal,
          ``Nvarchar``: string,
          ``Real``: float32,
          ``Smalldatetime``: DateTime,
          ``Smallint``: int16,
          ``Smallmoney``: decimal,
          ``Text``: string,
          ``Time``: TimeSpan,
          ``Tinyint``: byte,
          ``Uniqueidentifier``: Guid,
          ``Varbinary``: byte [],
          ``Varchar``: string,
          ``Xml``: string
        ) : ``AllTypesNonNull`` =
        [|
          ``Bigint`` |> box
          ``Binary`` |> box
          ``Bit`` |> box
          ``Char`` |> box
          ``Date`` |> box
          ``Datetime`` |> box
          ``Datetime2`` |> box
          ``Datetimeoffset`` |> box
          ``Decimal`` |> box
          ``Float`` |> box
          ``Image`` |> box
          ``Int`` |> box
          ``Money`` |> box
          ``Nchar`` |> box
          ``Ntext`` |> box
          ``Numeric`` |> box
          ``Nvarchar`` |> box
          ``Real`` |> box
          ``Smalldatetime`` |> box
          ``Smallint`` |> box
          ``Smallmoney`` |> box
          ``Text`` |> box
          ``Time`` |> box
          ``Tinyint`` |> box
          ``Uniqueidentifier`` |> box
          ``Varbinary`` |> box
          ``Varchar`` |> box
          ``Xml`` |> box
        |]
        |> fun fields -> ``AllTypesNonNull``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``AllTypesNonNull`` =
        [|
          (^a: (member ``Bigint``: int64) dto) |> box
          (^a: (member ``Binary``: byte []) dto) |> box
          (^a: (member ``Bit``: bool) dto) |> box
          (^a: (member ``Char``: string) dto) |> box
          (^a: (member ``Date``: DateTime) dto) |> box
          (^a: (member ``Datetime``: DateTime) dto) |> box
          (^a: (member ``Datetime2``: DateTime) dto) |> box
          (^a: (member ``Datetimeoffset``: DateTimeOffset) dto) |> box
          (^a: (member ``Decimal``: decimal) dto) |> box
          (^a: (member ``Float``: float) dto) |> box
          (^a: (member ``Image``: byte []) dto) |> box
          (^a: (member ``Int``: int) dto) |> box
          (^a: (member ``Money``: decimal) dto) |> box
          (^a: (member ``Nchar``: string) dto) |> box
          (^a: (member ``Ntext``: string) dto) |> box
          (^a: (member ``Numeric``: decimal) dto) |> box
          (^a: (member ``Nvarchar``: string) dto) |> box
          (^a: (member ``Real``: float32) dto) |> box
          (^a: (member ``Smalldatetime``: DateTime) dto) |> box
          (^a: (member ``Smallint``: int16) dto) |> box
          (^a: (member ``Smallmoney``: decimal) dto) |> box
          (^a: (member ``Text``: string) dto) |> box
          (^a: (member ``Time``: TimeSpan) dto) |> box
          (^a: (member ``Tinyint``: byte) dto) |> box
          (^a: (member ``Uniqueidentifier``: Guid) dto) |> box
          (^a: (member ``Varbinary``: byte []) dto) |> box
          (^a: (member ``Varchar``: string) dto) |> box
          (^a: (member ``Xml``: string) dto) |> box
        |]
        |> fun fields -> ``AllTypesNonNull``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableAllTypesNonNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableAllTypesNonNull.sql
SELECT * FROM #AllTypesNonNull"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Bigint`` = 0
    let mutable ``ordinal_Binary`` = 0
    let mutable ``ordinal_Bit`` = 0
    let mutable ``ordinal_Char`` = 0
    let mutable ``ordinal_Date`` = 0
    let mutable ``ordinal_Datetime`` = 0
    let mutable ``ordinal_Datetime2`` = 0
    let mutable ``ordinal_Datetimeoffset`` = 0
    let mutable ``ordinal_Decimal`` = 0
    let mutable ``ordinal_Float`` = 0
    let mutable ``ordinal_Image`` = 0
    let mutable ``ordinal_Int`` = 0
    let mutable ``ordinal_Money`` = 0
    let mutable ``ordinal_Nchar`` = 0
    let mutable ``ordinal_Ntext`` = 0
    let mutable ``ordinal_Numeric`` = 0
    let mutable ``ordinal_Nvarchar`` = 0
    let mutable ``ordinal_Real`` = 0
    let mutable ``ordinal_Smalldatetime`` = 0
    let mutable ``ordinal_Smallint`` = 0
    let mutable ``ordinal_Smallmoney`` = 0
    let mutable ``ordinal_Text`` = 0
    let mutable ``ordinal_Time`` = 0
    let mutable ``ordinal_Tinyint`` = 0
    let mutable ``ordinal_Uniqueidentifier`` = 0
    let mutable ``ordinal_Varbinary`` = 0
    let mutable ``ordinal_Varchar`` = 0
    let mutable ``ordinal_Xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Bigint`` <- reader.GetOrdinal "Bigint"
      ``ordinal_Binary`` <- reader.GetOrdinal "Binary"
      ``ordinal_Bit`` <- reader.GetOrdinal "Bit"
      ``ordinal_Char`` <- reader.GetOrdinal "Char"
      ``ordinal_Date`` <- reader.GetOrdinal "Date"
      ``ordinal_Datetime`` <- reader.GetOrdinal "Datetime"
      ``ordinal_Datetime2`` <- reader.GetOrdinal "Datetime2"
      ``ordinal_Datetimeoffset`` <- reader.GetOrdinal "Datetimeoffset"
      ``ordinal_Decimal`` <- reader.GetOrdinal "Decimal"
      ``ordinal_Float`` <- reader.GetOrdinal "Float"
      ``ordinal_Image`` <- reader.GetOrdinal "Image"
      ``ordinal_Int`` <- reader.GetOrdinal "Int"
      ``ordinal_Money`` <- reader.GetOrdinal "Money"
      ``ordinal_Nchar`` <- reader.GetOrdinal "Nchar"
      ``ordinal_Ntext`` <- reader.GetOrdinal "Ntext"
      ``ordinal_Numeric`` <- reader.GetOrdinal "Numeric"
      ``ordinal_Nvarchar`` <- reader.GetOrdinal "Nvarchar"
      ``ordinal_Real`` <- reader.GetOrdinal "Real"
      ``ordinal_Smalldatetime`` <- reader.GetOrdinal "Smalldatetime"
      ``ordinal_Smallint`` <- reader.GetOrdinal "Smallint"
      ``ordinal_Smallmoney`` <- reader.GetOrdinal "Smallmoney"
      ``ordinal_Text`` <- reader.GetOrdinal "Text"
      ``ordinal_Time`` <- reader.GetOrdinal "Time"
      ``ordinal_Tinyint`` <- reader.GetOrdinal "Tinyint"
      ``ordinal_Uniqueidentifier`` <- reader.GetOrdinal "Uniqueidentifier"
      ``ordinal_Varbinary`` <- reader.GetOrdinal "Varbinary"
      ``ordinal_Varchar`` <- reader.GetOrdinal "Varchar"
      ``ordinal_Xml`` <- reader.GetOrdinal "Xml"

    let getItem (reader: SqlDataReader) =
      let ``Bigint`` = reader.GetInt64 ``ordinal_Bigint``
      let ``Binary`` = reader.GetBytes ``ordinal_Binary``
      let ``Bit`` = reader.GetBoolean ``ordinal_Bit``
      let ``Char`` = reader.GetString ``ordinal_Char``
      let ``Date`` = reader.GetDateTime ``ordinal_Date``
      let ``Datetime`` = reader.GetDateTime ``ordinal_Datetime``
      let ``Datetime2`` = reader.GetDateTime ``ordinal_Datetime2``
      let ``Datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_Datetimeoffset``
      let ``Decimal`` = reader.GetDecimal ``ordinal_Decimal``
      let ``Float`` = reader.GetDouble ``ordinal_Float``
      let ``Image`` = reader.GetBytes ``ordinal_Image``
      let ``Int`` = reader.GetInt32 ``ordinal_Int``
      let ``Money`` = reader.GetDecimal ``ordinal_Money``
      let ``Nchar`` = reader.GetString ``ordinal_Nchar``
      let ``Ntext`` = reader.GetString ``ordinal_Ntext``
      let ``Numeric`` = reader.GetDecimal ``ordinal_Numeric``
      let ``Nvarchar`` = reader.GetString ``ordinal_Nvarchar``
      let ``Real`` = reader.GetFloat ``ordinal_Real``
      let ``Smalldatetime`` = reader.GetDateTime ``ordinal_Smalldatetime``
      let ``Smallint`` = reader.GetInt16 ``ordinal_Smallint``
      let ``Smallmoney`` = reader.GetDecimal ``ordinal_Smallmoney``
      let ``Text`` = reader.GetString ``ordinal_Text``
      let ``Time`` = reader.GetTimeSpan ``ordinal_Time``
      let ``Tinyint`` = reader.GetByte ``ordinal_Tinyint``
      let ``Uniqueidentifier`` = reader.GetGuid ``ordinal_Uniqueidentifier``
      let ``Varbinary`` = reader.GetBytes ``ordinal_Varbinary``
      let ``Varchar`` = reader.GetString ``ordinal_Varchar``
      let ``Xml`` = reader.GetString ``ordinal_Xml``
      {|
        ``Bigint`` = ``Bigint``
        ``Binary`` = ``Binary``
        ``Bit`` = ``Bit``
        ``Char`` = ``Char``
        ``Date`` = ``Date``
        ``Datetime`` = ``Datetime``
        ``Datetime2`` = ``Datetime2``
        ``Datetimeoffset`` = ``Datetimeoffset``
        ``Decimal`` = ``Decimal``
        ``Float`` = ``Float``
        ``Image`` = ``Image``
        ``Int`` = ``Int``
        ``Money`` = ``Money``
        ``Nchar`` = ``Nchar``
        ``Ntext`` = ``Ntext``
        ``Numeric`` = ``Numeric``
        ``Nvarchar`` = ``Nvarchar``
        ``Real`` = ``Real``
        ``Smalldatetime`` = ``Smalldatetime``
        ``Smallint`` = ``Smallint``
        ``Smallmoney`` = ``Smallmoney``
        ``Text`` = ``Text``
        ``Time`` = ``Time``
        ``Tinyint`` = ``Tinyint``
        ``Uniqueidentifier`` = ``Uniqueidentifier``
        ``Varbinary`` = ``Varbinary``
        ``Varchar`` = ``Varchar``
        ``Xml`` = ``Xml``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableAllTypesNonNull`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableAllTypesNonNull``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableAllTypesNonNull``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableAllTypesNonNull``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``AllTypesNonNull``: seq<``TempTableAllTypesNonNull``.``AllTypesNonNull``>
      ) =
      [
        TempTableData
          (
            "#AllTypesNonNull",
            """
            CREATE TABLE #AllTypesNonNull (
              [Bigint] BIGINT NOT NULL,
              [Binary] BINARY(42) NOT NULL,
              [Bit] BIT NOT NULL,
              [Char] CHAR(42) NOT NULL,
              [Date] DATE NOT NULL,
              [Datetime] DATETIME NOT NULL,
              [Datetime2] DATETIME2(3) NOT NULL,
              [Datetimeoffset] DATETIMEOFFSET(1) NOT NULL,
              [Decimal] DECIMAL(10, 5) NOT NULL,
              [Float] FLOAT(42) NOT NULL,
              [Image] IMAGE NOT NULL,
              [Int] INT NOT NULL,
              [Money] MONEY NOT NULL,
              [Nchar] NCHAR(42) NOT NULL,
              [Ntext] NTEXT NOT NULL,
              [Numeric] NUMERIC(8, 3) NOT NULL,
              [Nvarchar] NVARCHAR(42) NOT NULL,
              [Real] REAL NOT NULL,
              [Smalldatetime] SMALLDATETIME NOT NULL,
              [Smallint] SMALLINT NOT NULL,
              [Smallmoney] SMALLMONEY NOT NULL,
              [Text] TEXT NOT NULL,
              [Time] TIME(1) NOT NULL,
              [Tinyint] TINYINT NOT NULL,
              [Uniqueidentifier] UNIQUEIDENTIFIER NOT NULL,
              [Varbinary] VARBINARY(42) NOT NULL,
              [Varchar] VARCHAR(42) NOT NULL,
              [Xml] XML NOT NULL
            )

            """,
            (``AllTypesNonNull`` |> Seq.map (fun x -> x.Fields)),
            28,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``allTypesNonNull``: seq<``TempTableAllTypesNonNull``.``AllTypesNonNull``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``allTypesNonNull``
        )
      ``TempTableAllTypesNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``AllTypesNonNull``: #seq<``TempTableAllTypesNonNull``.``AllTypesNonNull``>) dto)
        )
      ``TempTableAllTypesNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableAllTypesNonNullNominalParams`` =


    type ``AllTypesNonNull`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Bigint``: int64,
          ``Binary``: byte [],
          ``Bit``: bool,
          ``Char``: string,
          ``Date``: DateTime,
          ``Datetime``: DateTime,
          ``Datetime2``: DateTime,
          ``Datetimeoffset``: DateTimeOffset,
          ``Decimal``: decimal,
          ``Float``: float,
          ``Image``: byte [],
          ``Int``: int,
          ``Money``: decimal,
          ``Nchar``: string,
          ``Ntext``: string,
          ``Numeric``: decimal,
          ``Nvarchar``: string,
          ``Real``: float32,
          ``Smalldatetime``: DateTime,
          ``Smallint``: int16,
          ``Smallmoney``: decimal,
          ``Text``: string,
          ``Time``: TimeSpan,
          ``Tinyint``: byte,
          ``Uniqueidentifier``: Guid,
          ``Varbinary``: byte [],
          ``Varchar``: string,
          ``Xml``: string
        ) : ``AllTypesNonNull`` =
        [|
          ``Bigint`` |> box
          ``Binary`` |> box
          ``Bit`` |> box
          ``Char`` |> box
          ``Date`` |> box
          ``Datetime`` |> box
          ``Datetime2`` |> box
          ``Datetimeoffset`` |> box
          ``Decimal`` |> box
          ``Float`` |> box
          ``Image`` |> box
          ``Int`` |> box
          ``Money`` |> box
          ``Nchar`` |> box
          ``Ntext`` |> box
          ``Numeric`` |> box
          ``Nvarchar`` |> box
          ``Real`` |> box
          ``Smalldatetime`` |> box
          ``Smallint`` |> box
          ``Smallmoney`` |> box
          ``Text`` |> box
          ``Time`` |> box
          ``Tinyint`` |> box
          ``Uniqueidentifier`` |> box
          ``Varbinary`` |> box
          ``Varchar`` |> box
          ``Xml`` |> box
        |]
        |> fun fields -> ``AllTypesNonNull``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``AllTypesNonNull`` =
        [|
          (^a: (member ``Bigint``: int64) dto) |> box
          (^a: (member ``Binary``: byte []) dto) |> box
          (^a: (member ``Bit``: bool) dto) |> box
          (^a: (member ``Char``: string) dto) |> box
          (^a: (member ``Date``: DateTime) dto) |> box
          (^a: (member ``Datetime``: DateTime) dto) |> box
          (^a: (member ``Datetime2``: DateTime) dto) |> box
          (^a: (member ``Datetimeoffset``: DateTimeOffset) dto) |> box
          (^a: (member ``Decimal``: decimal) dto) |> box
          (^a: (member ``Float``: float) dto) |> box
          (^a: (member ``Image``: byte []) dto) |> box
          (^a: (member ``Int``: int) dto) |> box
          (^a: (member ``Money``: decimal) dto) |> box
          (^a: (member ``Nchar``: string) dto) |> box
          (^a: (member ``Ntext``: string) dto) |> box
          (^a: (member ``Numeric``: decimal) dto) |> box
          (^a: (member ``Nvarchar``: string) dto) |> box
          (^a: (member ``Real``: float32) dto) |> box
          (^a: (member ``Smalldatetime``: DateTime) dto) |> box
          (^a: (member ``Smallint``: int16) dto) |> box
          (^a: (member ``Smallmoney``: decimal) dto) |> box
          (^a: (member ``Text``: string) dto) |> box
          (^a: (member ``Time``: TimeSpan) dto) |> box
          (^a: (member ``Tinyint``: byte) dto) |> box
          (^a: (member ``Uniqueidentifier``: Guid) dto) |> box
          (^a: (member ``Varbinary``: byte []) dto) |> box
          (^a: (member ``Varchar``: string) dto) |> box
          (^a: (member ``Xml``: string) dto) |> box
        |]
        |> fun fields -> ``AllTypesNonNull``(internalUseOnlyValue, fields)


  type ``TempTableAllTypesNonNullNominalParams_Params`` =
    {
      ``AllTypesNonNull``: seq<``TempTableAllTypesNonNullNominalParams``.``AllTypesNonNull``>
    }


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableAllTypesNonNullNominalParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableAllTypesNonNullNominalParams.sql
SELECT * FROM #AllTypesNonNull"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Bigint`` = 0
    let mutable ``ordinal_Binary`` = 0
    let mutable ``ordinal_Bit`` = 0
    let mutable ``ordinal_Char`` = 0
    let mutable ``ordinal_Date`` = 0
    let mutable ``ordinal_Datetime`` = 0
    let mutable ``ordinal_Datetime2`` = 0
    let mutable ``ordinal_Datetimeoffset`` = 0
    let mutable ``ordinal_Decimal`` = 0
    let mutable ``ordinal_Float`` = 0
    let mutable ``ordinal_Image`` = 0
    let mutable ``ordinal_Int`` = 0
    let mutable ``ordinal_Money`` = 0
    let mutable ``ordinal_Nchar`` = 0
    let mutable ``ordinal_Ntext`` = 0
    let mutable ``ordinal_Numeric`` = 0
    let mutable ``ordinal_Nvarchar`` = 0
    let mutable ``ordinal_Real`` = 0
    let mutable ``ordinal_Smalldatetime`` = 0
    let mutable ``ordinal_Smallint`` = 0
    let mutable ``ordinal_Smallmoney`` = 0
    let mutable ``ordinal_Text`` = 0
    let mutable ``ordinal_Time`` = 0
    let mutable ``ordinal_Tinyint`` = 0
    let mutable ``ordinal_Uniqueidentifier`` = 0
    let mutable ``ordinal_Varbinary`` = 0
    let mutable ``ordinal_Varchar`` = 0
    let mutable ``ordinal_Xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Bigint`` <- reader.GetOrdinal "Bigint"
      ``ordinal_Binary`` <- reader.GetOrdinal "Binary"
      ``ordinal_Bit`` <- reader.GetOrdinal "Bit"
      ``ordinal_Char`` <- reader.GetOrdinal "Char"
      ``ordinal_Date`` <- reader.GetOrdinal "Date"
      ``ordinal_Datetime`` <- reader.GetOrdinal "Datetime"
      ``ordinal_Datetime2`` <- reader.GetOrdinal "Datetime2"
      ``ordinal_Datetimeoffset`` <- reader.GetOrdinal "Datetimeoffset"
      ``ordinal_Decimal`` <- reader.GetOrdinal "Decimal"
      ``ordinal_Float`` <- reader.GetOrdinal "Float"
      ``ordinal_Image`` <- reader.GetOrdinal "Image"
      ``ordinal_Int`` <- reader.GetOrdinal "Int"
      ``ordinal_Money`` <- reader.GetOrdinal "Money"
      ``ordinal_Nchar`` <- reader.GetOrdinal "Nchar"
      ``ordinal_Ntext`` <- reader.GetOrdinal "Ntext"
      ``ordinal_Numeric`` <- reader.GetOrdinal "Numeric"
      ``ordinal_Nvarchar`` <- reader.GetOrdinal "Nvarchar"
      ``ordinal_Real`` <- reader.GetOrdinal "Real"
      ``ordinal_Smalldatetime`` <- reader.GetOrdinal "Smalldatetime"
      ``ordinal_Smallint`` <- reader.GetOrdinal "Smallint"
      ``ordinal_Smallmoney`` <- reader.GetOrdinal "Smallmoney"
      ``ordinal_Text`` <- reader.GetOrdinal "Text"
      ``ordinal_Time`` <- reader.GetOrdinal "Time"
      ``ordinal_Tinyint`` <- reader.GetOrdinal "Tinyint"
      ``ordinal_Uniqueidentifier`` <- reader.GetOrdinal "Uniqueidentifier"
      ``ordinal_Varbinary`` <- reader.GetOrdinal "Varbinary"
      ``ordinal_Varchar`` <- reader.GetOrdinal "Varchar"
      ``ordinal_Xml`` <- reader.GetOrdinal "Xml"

    let getItem (reader: SqlDataReader) =
      let ``Bigint`` = reader.GetInt64 ``ordinal_Bigint``
      let ``Binary`` = reader.GetBytes ``ordinal_Binary``
      let ``Bit`` = reader.GetBoolean ``ordinal_Bit``
      let ``Char`` = reader.GetString ``ordinal_Char``
      let ``Date`` = reader.GetDateTime ``ordinal_Date``
      let ``Datetime`` = reader.GetDateTime ``ordinal_Datetime``
      let ``Datetime2`` = reader.GetDateTime ``ordinal_Datetime2``
      let ``Datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_Datetimeoffset``
      let ``Decimal`` = reader.GetDecimal ``ordinal_Decimal``
      let ``Float`` = reader.GetDouble ``ordinal_Float``
      let ``Image`` = reader.GetBytes ``ordinal_Image``
      let ``Int`` = reader.GetInt32 ``ordinal_Int``
      let ``Money`` = reader.GetDecimal ``ordinal_Money``
      let ``Nchar`` = reader.GetString ``ordinal_Nchar``
      let ``Ntext`` = reader.GetString ``ordinal_Ntext``
      let ``Numeric`` = reader.GetDecimal ``ordinal_Numeric``
      let ``Nvarchar`` = reader.GetString ``ordinal_Nvarchar``
      let ``Real`` = reader.GetFloat ``ordinal_Real``
      let ``Smalldatetime`` = reader.GetDateTime ``ordinal_Smalldatetime``
      let ``Smallint`` = reader.GetInt16 ``ordinal_Smallint``
      let ``Smallmoney`` = reader.GetDecimal ``ordinal_Smallmoney``
      let ``Text`` = reader.GetString ``ordinal_Text``
      let ``Time`` = reader.GetTimeSpan ``ordinal_Time``
      let ``Tinyint`` = reader.GetByte ``ordinal_Tinyint``
      let ``Uniqueidentifier`` = reader.GetGuid ``ordinal_Uniqueidentifier``
      let ``Varbinary`` = reader.GetBytes ``ordinal_Varbinary``
      let ``Varchar`` = reader.GetString ``ordinal_Varchar``
      let ``Xml`` = reader.GetString ``ordinal_Xml``
      {|
        ``Bigint`` = ``Bigint``
        ``Binary`` = ``Binary``
        ``Bit`` = ``Bit``
        ``Char`` = ``Char``
        ``Date`` = ``Date``
        ``Datetime`` = ``Datetime``
        ``Datetime2`` = ``Datetime2``
        ``Datetimeoffset`` = ``Datetimeoffset``
        ``Decimal`` = ``Decimal``
        ``Float`` = ``Float``
        ``Image`` = ``Image``
        ``Int`` = ``Int``
        ``Money`` = ``Money``
        ``Nchar`` = ``Nchar``
        ``Ntext`` = ``Ntext``
        ``Numeric`` = ``Numeric``
        ``Nvarchar`` = ``Nvarchar``
        ``Real`` = ``Real``
        ``Smalldatetime`` = ``Smalldatetime``
        ``Smallint`` = ``Smallint``
        ``Smallmoney`` = ``Smallmoney``
        ``Text`` = ``Text``
        ``Time`` = ``Time``
        ``Tinyint`` = ``Tinyint``
        ``Uniqueidentifier`` = ``Uniqueidentifier``
        ``Varbinary`` = ``Varbinary``
        ``Varchar`` = ``Varchar``
        ``Xml`` = ``Xml``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableAllTypesNonNullNominalParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableAllTypesNonNullNominalParams``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableAllTypesNonNullNominalParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableAllTypesNonNullNominalParams``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``AllTypesNonNull``: seq<``TempTableAllTypesNonNullNominalParams``.``AllTypesNonNull``>
      ) =
      [
        TempTableData
          (
            "#AllTypesNonNull",
            """
            CREATE TABLE #AllTypesNonNull (
              [Bigint] BIGINT NOT NULL,
              [Binary] BINARY(42) NOT NULL,
              [Bit] BIT NOT NULL,
              [Char] CHAR(42) NOT NULL,
              [Date] DATE NOT NULL,
              [Datetime] DATETIME NOT NULL,
              [Datetime2] DATETIME2(3) NOT NULL,
              [Datetimeoffset] DATETIMEOFFSET(1) NOT NULL,
              [Decimal] DECIMAL(10, 5) NOT NULL,
              [Float] FLOAT(42) NOT NULL,
              [Image] IMAGE NOT NULL,
              [Int] INT NOT NULL,
              [Money] MONEY NOT NULL,
              [Nchar] NCHAR(42) NOT NULL,
              [Ntext] NTEXT NOT NULL,
              [Numeric] NUMERIC(8, 3) NOT NULL,
              [Nvarchar] NVARCHAR(42) NOT NULL,
              [Real] REAL NOT NULL,
              [Smalldatetime] SMALLDATETIME NOT NULL,
              [Smallint] SMALLINT NOT NULL,
              [Smallmoney] SMALLMONEY NOT NULL,
              [Text] TEXT NOT NULL,
              [Time] TIME(1) NOT NULL,
              [Tinyint] TINYINT NOT NULL,
              [Uniqueidentifier] UNIQUEIDENTIFIER NOT NULL,
              [Varbinary] VARBINARY(42) NOT NULL,
              [Varchar] VARCHAR(42) NOT NULL,
              [Xml] XML NOT NULL
            )

            """,
            (``AllTypesNonNull`` |> Seq.map (fun x -> x.Fields)),
            28,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``allTypesNonNull``: seq<``TempTableAllTypesNonNullNominalParams``.``AllTypesNonNull``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``allTypesNonNull``
        )
      ``TempTableAllTypesNonNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: TempTableAllTypesNonNullNominalParams_Params) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          dto.``AllTypesNonNull``
        )
      ``TempTableAllTypesNonNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableAllTypesNull`` =


    type ``AllTypesNull`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Bigint``: int64 option,
          ``Binary``: byte [] option,
          ``Bit``: bool option,
          ``Char``: string option,
          ``Date``: DateTime option,
          ``Datetime``: DateTime option,
          ``Datetime2``: DateTime option,
          ``Datetimeoffset``: DateTimeOffset option,
          ``Decimal``: decimal option,
          ``Float``: float option,
          ``Image``: byte [] option,
          ``Int``: int option,
          ``Money``: decimal option,
          ``Nchar``: string option,
          ``Ntext``: string option,
          ``Numeric``: decimal option,
          ``Nvarchar``: string option,
          ``Real``: float32 option,
          ``Smalldatetime``: DateTime option,
          ``Smallint``: int16 option,
          ``Smallmoney``: decimal option,
          ``Text``: string option,
          ``Time``: TimeSpan option,
          ``Tinyint``: byte option,
          ``Uniqueidentifier``: Guid option,
          ``Varbinary``: byte [] option,
          ``Varchar``: string option,
          ``Xml``: string option
        ) : ``AllTypesNull`` =
        [|
          Option.toDbNull ``Bigint`` |> box
          Option.toDbNull ``Binary`` |> box
          Option.toDbNull ``Bit`` |> box
          Option.toDbNull ``Char`` |> box
          Option.toDbNull ``Date`` |> box
          Option.toDbNull ``Datetime`` |> box
          Option.toDbNull ``Datetime2`` |> box
          Option.toDbNull ``Datetimeoffset`` |> box
          Option.toDbNull ``Decimal`` |> box
          Option.toDbNull ``Float`` |> box
          Option.toDbNull ``Image`` |> box
          Option.toDbNull ``Int`` |> box
          Option.toDbNull ``Money`` |> box
          Option.toDbNull ``Nchar`` |> box
          Option.toDbNull ``Ntext`` |> box
          Option.toDbNull ``Numeric`` |> box
          Option.toDbNull ``Nvarchar`` |> box
          Option.toDbNull ``Real`` |> box
          Option.toDbNull ``Smalldatetime`` |> box
          Option.toDbNull ``Smallint`` |> box
          Option.toDbNull ``Smallmoney`` |> box
          Option.toDbNull ``Text`` |> box
          Option.toDbNull ``Time`` |> box
          Option.toDbNull ``Tinyint`` |> box
          Option.toDbNull ``Uniqueidentifier`` |> box
          Option.toDbNull ``Varbinary`` |> box
          Option.toDbNull ``Varchar`` |> box
          Option.toDbNull ``Xml`` |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``AllTypesNull`` =
        [|
          Option.toDbNull (^a: (member ``Bigint``: int64 option) dto) |> box
          Option.toDbNull (^a: (member ``Binary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``Bit``: bool option) dto) |> box
          Option.toDbNull (^a: (member ``Char``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Date``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto) |> box
          Option.toDbNull (^a: (member ``Decimal``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Float``: float option) dto) |> box
          Option.toDbNull (^a: (member ``Image``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``Int``: int option) dto) |> box
          Option.toDbNull (^a: (member ``Money``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Nchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Ntext``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Numeric``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Nvarchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Real``: float32 option) dto) |> box
          Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Smallint``: int16 option) dto) |> box
          Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Text``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto) |> box
          Option.toDbNull (^a: (member ``Tinyint``: byte option) dto) |> box
          Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto) |> box
          Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``Varchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Xml``: string option) dto) |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableAllTypesNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableAllTypesNull.sql
SELECT * FROM #AllTypesNull"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Bigint`` = 0
    let mutable ``ordinal_Binary`` = 0
    let mutable ``ordinal_Bit`` = 0
    let mutable ``ordinal_Char`` = 0
    let mutable ``ordinal_Date`` = 0
    let mutable ``ordinal_Datetime`` = 0
    let mutable ``ordinal_Datetime2`` = 0
    let mutable ``ordinal_Datetimeoffset`` = 0
    let mutable ``ordinal_Decimal`` = 0
    let mutable ``ordinal_Float`` = 0
    let mutable ``ordinal_Image`` = 0
    let mutable ``ordinal_Int`` = 0
    let mutable ``ordinal_Money`` = 0
    let mutable ``ordinal_Nchar`` = 0
    let mutable ``ordinal_Ntext`` = 0
    let mutable ``ordinal_Numeric`` = 0
    let mutable ``ordinal_Nvarchar`` = 0
    let mutable ``ordinal_Real`` = 0
    let mutable ``ordinal_Smalldatetime`` = 0
    let mutable ``ordinal_Smallint`` = 0
    let mutable ``ordinal_Smallmoney`` = 0
    let mutable ``ordinal_Text`` = 0
    let mutable ``ordinal_Time`` = 0
    let mutable ``ordinal_Tinyint`` = 0
    let mutable ``ordinal_Uniqueidentifier`` = 0
    let mutable ``ordinal_Varbinary`` = 0
    let mutable ``ordinal_Varchar`` = 0
    let mutable ``ordinal_Xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Bigint`` <- reader.GetOrdinal "Bigint"
      ``ordinal_Binary`` <- reader.GetOrdinal "Binary"
      ``ordinal_Bit`` <- reader.GetOrdinal "Bit"
      ``ordinal_Char`` <- reader.GetOrdinal "Char"
      ``ordinal_Date`` <- reader.GetOrdinal "Date"
      ``ordinal_Datetime`` <- reader.GetOrdinal "Datetime"
      ``ordinal_Datetime2`` <- reader.GetOrdinal "Datetime2"
      ``ordinal_Datetimeoffset`` <- reader.GetOrdinal "Datetimeoffset"
      ``ordinal_Decimal`` <- reader.GetOrdinal "Decimal"
      ``ordinal_Float`` <- reader.GetOrdinal "Float"
      ``ordinal_Image`` <- reader.GetOrdinal "Image"
      ``ordinal_Int`` <- reader.GetOrdinal "Int"
      ``ordinal_Money`` <- reader.GetOrdinal "Money"
      ``ordinal_Nchar`` <- reader.GetOrdinal "Nchar"
      ``ordinal_Ntext`` <- reader.GetOrdinal "Ntext"
      ``ordinal_Numeric`` <- reader.GetOrdinal "Numeric"
      ``ordinal_Nvarchar`` <- reader.GetOrdinal "Nvarchar"
      ``ordinal_Real`` <- reader.GetOrdinal "Real"
      ``ordinal_Smalldatetime`` <- reader.GetOrdinal "Smalldatetime"
      ``ordinal_Smallint`` <- reader.GetOrdinal "Smallint"
      ``ordinal_Smallmoney`` <- reader.GetOrdinal "Smallmoney"
      ``ordinal_Text`` <- reader.GetOrdinal "Text"
      ``ordinal_Time`` <- reader.GetOrdinal "Time"
      ``ordinal_Tinyint`` <- reader.GetOrdinal "Tinyint"
      ``ordinal_Uniqueidentifier`` <- reader.GetOrdinal "Uniqueidentifier"
      ``ordinal_Varbinary`` <- reader.GetOrdinal "Varbinary"
      ``ordinal_Varchar`` <- reader.GetOrdinal "Varchar"
      ``ordinal_Xml`` <- reader.GetOrdinal "Xml"

    let getItem (reader: SqlDataReader) =
      let ``Bigint`` = if reader.IsDBNull ``ordinal_Bigint`` then None else reader.GetInt64 ``ordinal_Bigint`` |> Some
      let ``Binary`` = if reader.IsDBNull ``ordinal_Binary`` then None else reader.GetBytes ``ordinal_Binary`` |> Some
      let ``Bit`` = if reader.IsDBNull ``ordinal_Bit`` then None else reader.GetBoolean ``ordinal_Bit`` |> Some
      let ``Char`` = if reader.IsDBNull ``ordinal_Char`` then None else reader.GetString ``ordinal_Char`` |> Some
      let ``Date`` = if reader.IsDBNull ``ordinal_Date`` then None else reader.GetDateTime ``ordinal_Date`` |> Some
      let ``Datetime`` = if reader.IsDBNull ``ordinal_Datetime`` then None else reader.GetDateTime ``ordinal_Datetime`` |> Some
      let ``Datetime2`` = if reader.IsDBNull ``ordinal_Datetime2`` then None else reader.GetDateTime ``ordinal_Datetime2`` |> Some
      let ``Datetimeoffset`` = if reader.IsDBNull ``ordinal_Datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_Datetimeoffset`` |> Some
      let ``Decimal`` = if reader.IsDBNull ``ordinal_Decimal`` then None else reader.GetDecimal ``ordinal_Decimal`` |> Some
      let ``Float`` = if reader.IsDBNull ``ordinal_Float`` then None else reader.GetDouble ``ordinal_Float`` |> Some
      let ``Image`` = if reader.IsDBNull ``ordinal_Image`` then None else reader.GetBytes ``ordinal_Image`` |> Some
      let ``Int`` = if reader.IsDBNull ``ordinal_Int`` then None else reader.GetInt32 ``ordinal_Int`` |> Some
      let ``Money`` = if reader.IsDBNull ``ordinal_Money`` then None else reader.GetDecimal ``ordinal_Money`` |> Some
      let ``Nchar`` = if reader.IsDBNull ``ordinal_Nchar`` then None else reader.GetString ``ordinal_Nchar`` |> Some
      let ``Ntext`` = if reader.IsDBNull ``ordinal_Ntext`` then None else reader.GetString ``ordinal_Ntext`` |> Some
      let ``Numeric`` = if reader.IsDBNull ``ordinal_Numeric`` then None else reader.GetDecimal ``ordinal_Numeric`` |> Some
      let ``Nvarchar`` = if reader.IsDBNull ``ordinal_Nvarchar`` then None else reader.GetString ``ordinal_Nvarchar`` |> Some
      let ``Real`` = if reader.IsDBNull ``ordinal_Real`` then None else reader.GetFloat ``ordinal_Real`` |> Some
      let ``Smalldatetime`` = if reader.IsDBNull ``ordinal_Smalldatetime`` then None else reader.GetDateTime ``ordinal_Smalldatetime`` |> Some
      let ``Smallint`` = if reader.IsDBNull ``ordinal_Smallint`` then None else reader.GetInt16 ``ordinal_Smallint`` |> Some
      let ``Smallmoney`` = if reader.IsDBNull ``ordinal_Smallmoney`` then None else reader.GetDecimal ``ordinal_Smallmoney`` |> Some
      let ``Text`` = if reader.IsDBNull ``ordinal_Text`` then None else reader.GetString ``ordinal_Text`` |> Some
      let ``Time`` = if reader.IsDBNull ``ordinal_Time`` then None else reader.GetTimeSpan ``ordinal_Time`` |> Some
      let ``Tinyint`` = if reader.IsDBNull ``ordinal_Tinyint`` then None else reader.GetByte ``ordinal_Tinyint`` |> Some
      let ``Uniqueidentifier`` = if reader.IsDBNull ``ordinal_Uniqueidentifier`` then None else reader.GetGuid ``ordinal_Uniqueidentifier`` |> Some
      let ``Varbinary`` = if reader.IsDBNull ``ordinal_Varbinary`` then None else reader.GetBytes ``ordinal_Varbinary`` |> Some
      let ``Varchar`` = if reader.IsDBNull ``ordinal_Varchar`` then None else reader.GetString ``ordinal_Varchar`` |> Some
      let ``Xml`` = if reader.IsDBNull ``ordinal_Xml`` then None else reader.GetString ``ordinal_Xml`` |> Some
      {|
        ``Bigint`` = ``Bigint``
        ``Binary`` = ``Binary``
        ``Bit`` = ``Bit``
        ``Char`` = ``Char``
        ``Date`` = ``Date``
        ``Datetime`` = ``Datetime``
        ``Datetime2`` = ``Datetime2``
        ``Datetimeoffset`` = ``Datetimeoffset``
        ``Decimal`` = ``Decimal``
        ``Float`` = ``Float``
        ``Image`` = ``Image``
        ``Int`` = ``Int``
        ``Money`` = ``Money``
        ``Nchar`` = ``Nchar``
        ``Ntext`` = ``Ntext``
        ``Numeric`` = ``Numeric``
        ``Nvarchar`` = ``Nvarchar``
        ``Real`` = ``Real``
        ``Smalldatetime`` = ``Smalldatetime``
        ``Smallint`` = ``Smallint``
        ``Smallmoney`` = ``Smallmoney``
        ``Text`` = ``Text``
        ``Time`` = ``Time``
        ``Tinyint`` = ``Tinyint``
        ``Uniqueidentifier`` = ``Uniqueidentifier``
        ``Varbinary`` = ``Varbinary``
        ``Varchar`` = ``Varchar``
        ``Xml`` = ``Xml``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableAllTypesNull`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableAllTypesNull``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableAllTypesNull``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableAllTypesNull``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``AllTypesNull``: seq<``TempTableAllTypesNull``.``AllTypesNull``>
      ) =
      [
        TempTableData
          (
            "#AllTypesNull",
            """
            CREATE TABLE #AllTypesNull (
              [Bigint] BIGINT NULL,
              [Binary] BINARY(42) NULL,
              [Bit] BIT NULL,
              [Char] CHAR(42) NULL,
              [Date] DATE NULL,
              [Datetime] DATETIME NULL,
              [Datetime2] DATETIME2(3) NULL,
              [Datetimeoffset] DATETIMEOFFSET(1) NULL,
              [Decimal] DECIMAL(10, 5) NULL,
              [Float] FLOAT(42) NULL,
              [Image] IMAGE NULL,
              [Int] INT NULL,
              [Money] MONEY NULL,
              [Nchar] NCHAR(42) NULL,
              [Ntext] NTEXT NULL,
              [Numeric] NUMERIC(8, 3) NULL,
              [Nvarchar] NVARCHAR(42) NULL,
              [Real] REAL NULL,
              [Smalldatetime] SMALLDATETIME NULL,
              [Smallint] SMALLINT NULL,
              [Smallmoney] SMALLMONEY NULL,
              [Text] TEXT NULL,
              [Time] TIME(1) NULL,
              [Tinyint] TINYINT NULL,
              [Uniqueidentifier] UNIQUEIDENTIFIER NULL,
              [Varbinary] VARBINARY(42) NULL,
              [Varchar] VARCHAR(42) NULL,
              [Xml] XML NULL
            )

            """,
            (``AllTypesNull`` |> Seq.map (fun x -> x.Fields)),
            28,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``allTypesNull``: seq<``TempTableAllTypesNull``.``AllTypesNull``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``allTypesNull``
        )
      ``TempTableAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``AllTypesNull``: #seq<``TempTableAllTypesNull``.``AllTypesNull``>) dto)
        )
      ``TempTableAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableAllTypesNullNominalParams`` =


    type ``AllTypesNull`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Bigint``: int64 option,
          ``Binary``: byte [] option,
          ``Bit``: bool option,
          ``Char``: string option,
          ``Date``: DateTime option,
          ``Datetime``: DateTime option,
          ``Datetime2``: DateTime option,
          ``Datetimeoffset``: DateTimeOffset option,
          ``Decimal``: decimal option,
          ``Float``: float option,
          ``Image``: byte [] option,
          ``Int``: int option,
          ``Money``: decimal option,
          ``Nchar``: string option,
          ``Ntext``: string option,
          ``Numeric``: decimal option,
          ``Nvarchar``: string option,
          ``Real``: float32 option,
          ``Smalldatetime``: DateTime option,
          ``Smallint``: int16 option,
          ``Smallmoney``: decimal option,
          ``Text``: string option,
          ``Time``: TimeSpan option,
          ``Tinyint``: byte option,
          ``Uniqueidentifier``: Guid option,
          ``Varbinary``: byte [] option,
          ``Varchar``: string option,
          ``Xml``: string option
        ) : ``AllTypesNull`` =
        [|
          Option.toDbNull ``Bigint`` |> box
          Option.toDbNull ``Binary`` |> box
          Option.toDbNull ``Bit`` |> box
          Option.toDbNull ``Char`` |> box
          Option.toDbNull ``Date`` |> box
          Option.toDbNull ``Datetime`` |> box
          Option.toDbNull ``Datetime2`` |> box
          Option.toDbNull ``Datetimeoffset`` |> box
          Option.toDbNull ``Decimal`` |> box
          Option.toDbNull ``Float`` |> box
          Option.toDbNull ``Image`` |> box
          Option.toDbNull ``Int`` |> box
          Option.toDbNull ``Money`` |> box
          Option.toDbNull ``Nchar`` |> box
          Option.toDbNull ``Ntext`` |> box
          Option.toDbNull ``Numeric`` |> box
          Option.toDbNull ``Nvarchar`` |> box
          Option.toDbNull ``Real`` |> box
          Option.toDbNull ``Smalldatetime`` |> box
          Option.toDbNull ``Smallint`` |> box
          Option.toDbNull ``Smallmoney`` |> box
          Option.toDbNull ``Text`` |> box
          Option.toDbNull ``Time`` |> box
          Option.toDbNull ``Tinyint`` |> box
          Option.toDbNull ``Uniqueidentifier`` |> box
          Option.toDbNull ``Varbinary`` |> box
          Option.toDbNull ``Varchar`` |> box
          Option.toDbNull ``Xml`` |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``AllTypesNull`` =
        [|
          Option.toDbNull (^a: (member ``Bigint``: int64 option) dto) |> box
          Option.toDbNull (^a: (member ``Binary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``Bit``: bool option) dto) |> box
          Option.toDbNull (^a: (member ``Char``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Date``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto) |> box
          Option.toDbNull (^a: (member ``Decimal``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Float``: float option) dto) |> box
          Option.toDbNull (^a: (member ``Image``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``Int``: int option) dto) |> box
          Option.toDbNull (^a: (member ``Money``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Nchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Ntext``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Numeric``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Nvarchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Real``: float32 option) dto) |> box
          Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Smallint``: int16 option) dto) |> box
          Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Text``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto) |> box
          Option.toDbNull (^a: (member ``Tinyint``: byte option) dto) |> box
          Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto) |> box
          Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``Varchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Xml``: string option) dto) |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)


  type ``TempTableAllTypesNullNominalParams_Params`` =
    {
      ``AllTypesNull``: seq<``TempTableAllTypesNullNominalParams``.``AllTypesNull``>
    }


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableAllTypesNullNominalParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableAllTypesNullNominalParams.sql
SELECT * FROM #AllTypesNull"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Bigint`` = 0
    let mutable ``ordinal_Binary`` = 0
    let mutable ``ordinal_Bit`` = 0
    let mutable ``ordinal_Char`` = 0
    let mutable ``ordinal_Date`` = 0
    let mutable ``ordinal_Datetime`` = 0
    let mutable ``ordinal_Datetime2`` = 0
    let mutable ``ordinal_Datetimeoffset`` = 0
    let mutable ``ordinal_Decimal`` = 0
    let mutable ``ordinal_Float`` = 0
    let mutable ``ordinal_Image`` = 0
    let mutable ``ordinal_Int`` = 0
    let mutable ``ordinal_Money`` = 0
    let mutable ``ordinal_Nchar`` = 0
    let mutable ``ordinal_Ntext`` = 0
    let mutable ``ordinal_Numeric`` = 0
    let mutable ``ordinal_Nvarchar`` = 0
    let mutable ``ordinal_Real`` = 0
    let mutable ``ordinal_Smalldatetime`` = 0
    let mutable ``ordinal_Smallint`` = 0
    let mutable ``ordinal_Smallmoney`` = 0
    let mutable ``ordinal_Text`` = 0
    let mutable ``ordinal_Time`` = 0
    let mutable ``ordinal_Tinyint`` = 0
    let mutable ``ordinal_Uniqueidentifier`` = 0
    let mutable ``ordinal_Varbinary`` = 0
    let mutable ``ordinal_Varchar`` = 0
    let mutable ``ordinal_Xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Bigint`` <- reader.GetOrdinal "Bigint"
      ``ordinal_Binary`` <- reader.GetOrdinal "Binary"
      ``ordinal_Bit`` <- reader.GetOrdinal "Bit"
      ``ordinal_Char`` <- reader.GetOrdinal "Char"
      ``ordinal_Date`` <- reader.GetOrdinal "Date"
      ``ordinal_Datetime`` <- reader.GetOrdinal "Datetime"
      ``ordinal_Datetime2`` <- reader.GetOrdinal "Datetime2"
      ``ordinal_Datetimeoffset`` <- reader.GetOrdinal "Datetimeoffset"
      ``ordinal_Decimal`` <- reader.GetOrdinal "Decimal"
      ``ordinal_Float`` <- reader.GetOrdinal "Float"
      ``ordinal_Image`` <- reader.GetOrdinal "Image"
      ``ordinal_Int`` <- reader.GetOrdinal "Int"
      ``ordinal_Money`` <- reader.GetOrdinal "Money"
      ``ordinal_Nchar`` <- reader.GetOrdinal "Nchar"
      ``ordinal_Ntext`` <- reader.GetOrdinal "Ntext"
      ``ordinal_Numeric`` <- reader.GetOrdinal "Numeric"
      ``ordinal_Nvarchar`` <- reader.GetOrdinal "Nvarchar"
      ``ordinal_Real`` <- reader.GetOrdinal "Real"
      ``ordinal_Smalldatetime`` <- reader.GetOrdinal "Smalldatetime"
      ``ordinal_Smallint`` <- reader.GetOrdinal "Smallint"
      ``ordinal_Smallmoney`` <- reader.GetOrdinal "Smallmoney"
      ``ordinal_Text`` <- reader.GetOrdinal "Text"
      ``ordinal_Time`` <- reader.GetOrdinal "Time"
      ``ordinal_Tinyint`` <- reader.GetOrdinal "Tinyint"
      ``ordinal_Uniqueidentifier`` <- reader.GetOrdinal "Uniqueidentifier"
      ``ordinal_Varbinary`` <- reader.GetOrdinal "Varbinary"
      ``ordinal_Varchar`` <- reader.GetOrdinal "Varchar"
      ``ordinal_Xml`` <- reader.GetOrdinal "Xml"

    let getItem (reader: SqlDataReader) =
      let ``Bigint`` = if reader.IsDBNull ``ordinal_Bigint`` then None else reader.GetInt64 ``ordinal_Bigint`` |> Some
      let ``Binary`` = if reader.IsDBNull ``ordinal_Binary`` then None else reader.GetBytes ``ordinal_Binary`` |> Some
      let ``Bit`` = if reader.IsDBNull ``ordinal_Bit`` then None else reader.GetBoolean ``ordinal_Bit`` |> Some
      let ``Char`` = if reader.IsDBNull ``ordinal_Char`` then None else reader.GetString ``ordinal_Char`` |> Some
      let ``Date`` = if reader.IsDBNull ``ordinal_Date`` then None else reader.GetDateTime ``ordinal_Date`` |> Some
      let ``Datetime`` = if reader.IsDBNull ``ordinal_Datetime`` then None else reader.GetDateTime ``ordinal_Datetime`` |> Some
      let ``Datetime2`` = if reader.IsDBNull ``ordinal_Datetime2`` then None else reader.GetDateTime ``ordinal_Datetime2`` |> Some
      let ``Datetimeoffset`` = if reader.IsDBNull ``ordinal_Datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_Datetimeoffset`` |> Some
      let ``Decimal`` = if reader.IsDBNull ``ordinal_Decimal`` then None else reader.GetDecimal ``ordinal_Decimal`` |> Some
      let ``Float`` = if reader.IsDBNull ``ordinal_Float`` then None else reader.GetDouble ``ordinal_Float`` |> Some
      let ``Image`` = if reader.IsDBNull ``ordinal_Image`` then None else reader.GetBytes ``ordinal_Image`` |> Some
      let ``Int`` = if reader.IsDBNull ``ordinal_Int`` then None else reader.GetInt32 ``ordinal_Int`` |> Some
      let ``Money`` = if reader.IsDBNull ``ordinal_Money`` then None else reader.GetDecimal ``ordinal_Money`` |> Some
      let ``Nchar`` = if reader.IsDBNull ``ordinal_Nchar`` then None else reader.GetString ``ordinal_Nchar`` |> Some
      let ``Ntext`` = if reader.IsDBNull ``ordinal_Ntext`` then None else reader.GetString ``ordinal_Ntext`` |> Some
      let ``Numeric`` = if reader.IsDBNull ``ordinal_Numeric`` then None else reader.GetDecimal ``ordinal_Numeric`` |> Some
      let ``Nvarchar`` = if reader.IsDBNull ``ordinal_Nvarchar`` then None else reader.GetString ``ordinal_Nvarchar`` |> Some
      let ``Real`` = if reader.IsDBNull ``ordinal_Real`` then None else reader.GetFloat ``ordinal_Real`` |> Some
      let ``Smalldatetime`` = if reader.IsDBNull ``ordinal_Smalldatetime`` then None else reader.GetDateTime ``ordinal_Smalldatetime`` |> Some
      let ``Smallint`` = if reader.IsDBNull ``ordinal_Smallint`` then None else reader.GetInt16 ``ordinal_Smallint`` |> Some
      let ``Smallmoney`` = if reader.IsDBNull ``ordinal_Smallmoney`` then None else reader.GetDecimal ``ordinal_Smallmoney`` |> Some
      let ``Text`` = if reader.IsDBNull ``ordinal_Text`` then None else reader.GetString ``ordinal_Text`` |> Some
      let ``Time`` = if reader.IsDBNull ``ordinal_Time`` then None else reader.GetTimeSpan ``ordinal_Time`` |> Some
      let ``Tinyint`` = if reader.IsDBNull ``ordinal_Tinyint`` then None else reader.GetByte ``ordinal_Tinyint`` |> Some
      let ``Uniqueidentifier`` = if reader.IsDBNull ``ordinal_Uniqueidentifier`` then None else reader.GetGuid ``ordinal_Uniqueidentifier`` |> Some
      let ``Varbinary`` = if reader.IsDBNull ``ordinal_Varbinary`` then None else reader.GetBytes ``ordinal_Varbinary`` |> Some
      let ``Varchar`` = if reader.IsDBNull ``ordinal_Varchar`` then None else reader.GetString ``ordinal_Varchar`` |> Some
      let ``Xml`` = if reader.IsDBNull ``ordinal_Xml`` then None else reader.GetString ``ordinal_Xml`` |> Some
      {|
        ``Bigint`` = ``Bigint``
        ``Binary`` = ``Binary``
        ``Bit`` = ``Bit``
        ``Char`` = ``Char``
        ``Date`` = ``Date``
        ``Datetime`` = ``Datetime``
        ``Datetime2`` = ``Datetime2``
        ``Datetimeoffset`` = ``Datetimeoffset``
        ``Decimal`` = ``Decimal``
        ``Float`` = ``Float``
        ``Image`` = ``Image``
        ``Int`` = ``Int``
        ``Money`` = ``Money``
        ``Nchar`` = ``Nchar``
        ``Ntext`` = ``Ntext``
        ``Numeric`` = ``Numeric``
        ``Nvarchar`` = ``Nvarchar``
        ``Real`` = ``Real``
        ``Smalldatetime`` = ``Smalldatetime``
        ``Smallint`` = ``Smallint``
        ``Smallmoney`` = ``Smallmoney``
        ``Text`` = ``Text``
        ``Time`` = ``Time``
        ``Tinyint`` = ``Tinyint``
        ``Uniqueidentifier`` = ``Uniqueidentifier``
        ``Varbinary`` = ``Varbinary``
        ``Varchar`` = ``Varchar``
        ``Xml`` = ``Xml``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableAllTypesNullNominalParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableAllTypesNullNominalParams``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableAllTypesNullNominalParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableAllTypesNullNominalParams``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``AllTypesNull``: seq<``TempTableAllTypesNullNominalParams``.``AllTypesNull``>
      ) =
      [
        TempTableData
          (
            "#AllTypesNull",
            """
            CREATE TABLE #AllTypesNull (
              [Bigint] BIGINT NULL,
              [Binary] BINARY(42) NULL,
              [Bit] BIT NULL,
              [Char] CHAR(42) NULL,
              [Date] DATE NULL,
              [Datetime] DATETIME NULL,
              [Datetime2] DATETIME2(3) NULL,
              [Datetimeoffset] DATETIMEOFFSET(1) NULL,
              [Decimal] DECIMAL(10, 5) NULL,
              [Float] FLOAT(42) NULL,
              [Image] IMAGE NULL,
              [Int] INT NULL,
              [Money] MONEY NULL,
              [Nchar] NCHAR(42) NULL,
              [Ntext] NTEXT NULL,
              [Numeric] NUMERIC(8, 3) NULL,
              [Nvarchar] NVARCHAR(42) NULL,
              [Real] REAL NULL,
              [Smalldatetime] SMALLDATETIME NULL,
              [Smallint] SMALLINT NULL,
              [Smallmoney] SMALLMONEY NULL,
              [Text] TEXT NULL,
              [Time] TIME(1) NULL,
              [Tinyint] TINYINT NULL,
              [Uniqueidentifier] UNIQUEIDENTIFIER NULL,
              [Varbinary] VARBINARY(42) NULL,
              [Varchar] VARCHAR(42) NULL,
              [Xml] XML NULL
            )

            """,
            (``AllTypesNull`` |> Seq.map (fun x -> x.Fields)),
            28,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``allTypesNull``: seq<``TempTableAllTypesNullNominalParams``.``AllTypesNull``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``allTypesNull``
        )
      ``TempTableAllTypesNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: TempTableAllTypesNullNominalParams_Params) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          dto.``AllTypesNull``
        )
      ``TempTableAllTypesNullNominalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableAllTypesNullVoption`` =


    type ``AllTypesNull`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Bigint``: int64 voption,
          ``Binary``: byte [] voption,
          ``Bit``: bool voption,
          ``Char``: string voption,
          ``Date``: DateTime voption,
          ``Datetime``: DateTime voption,
          ``Datetime2``: DateTime voption,
          ``Datetimeoffset``: DateTimeOffset voption,
          ``Decimal``: decimal voption,
          ``Float``: float voption,
          ``Image``: byte [] voption,
          ``Int``: int voption,
          ``Money``: decimal voption,
          ``Nchar``: string voption,
          ``Ntext``: string voption,
          ``Numeric``: decimal voption,
          ``Nvarchar``: string voption,
          ``Real``: float32 voption,
          ``Smalldatetime``: DateTime voption,
          ``Smallint``: int16 voption,
          ``Smallmoney``: decimal voption,
          ``Text``: string voption,
          ``Time``: TimeSpan voption,
          ``Tinyint``: byte voption,
          ``Uniqueidentifier``: Guid voption,
          ``Varbinary``: byte [] voption,
          ``Varchar``: string voption,
          ``Xml``: string voption
        ) : ``AllTypesNull`` =
        [|
          ValueOption.toDbNull ``Bigint`` |> box
          ValueOption.toDbNull ``Binary`` |> box
          ValueOption.toDbNull ``Bit`` |> box
          ValueOption.toDbNull ``Char`` |> box
          ValueOption.toDbNull ``Date`` |> box
          ValueOption.toDbNull ``Datetime`` |> box
          ValueOption.toDbNull ``Datetime2`` |> box
          ValueOption.toDbNull ``Datetimeoffset`` |> box
          ValueOption.toDbNull ``Decimal`` |> box
          ValueOption.toDbNull ``Float`` |> box
          ValueOption.toDbNull ``Image`` |> box
          ValueOption.toDbNull ``Int`` |> box
          ValueOption.toDbNull ``Money`` |> box
          ValueOption.toDbNull ``Nchar`` |> box
          ValueOption.toDbNull ``Ntext`` |> box
          ValueOption.toDbNull ``Numeric`` |> box
          ValueOption.toDbNull ``Nvarchar`` |> box
          ValueOption.toDbNull ``Real`` |> box
          ValueOption.toDbNull ``Smalldatetime`` |> box
          ValueOption.toDbNull ``Smallint`` |> box
          ValueOption.toDbNull ``Smallmoney`` |> box
          ValueOption.toDbNull ``Text`` |> box
          ValueOption.toDbNull ``Time`` |> box
          ValueOption.toDbNull ``Tinyint`` |> box
          ValueOption.toDbNull ``Uniqueidentifier`` |> box
          ValueOption.toDbNull ``Varbinary`` |> box
          ValueOption.toDbNull ``Varchar`` |> box
          ValueOption.toDbNull ``Xml`` |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``AllTypesNull`` =
        [|
          ValueOption.toDbNull (^a: (member ``Bigint``: int64 voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Binary``: byte [] voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Bit``: bool voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Char``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Date``: DateTime voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Datetime``: DateTime voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Datetime2``: DateTime voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Decimal``: decimal voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Float``: float voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Image``: byte [] voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Int``: int voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Money``: decimal voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Nchar``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Ntext``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Numeric``: decimal voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Nvarchar``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Real``: float32 voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Smalldatetime``: DateTime voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Smallint``: int16 voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Smallmoney``: decimal voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Text``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Time``: TimeSpan voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Tinyint``: byte voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Uniqueidentifier``: Guid voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Varbinary``: byte [] voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Varchar``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Xml``: string voption) dto) |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableAllTypesNullVoption_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableAllTypesNullVoption.sql
SELECT * FROM #AllTypesNull"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Bigint`` = 0
    let mutable ``ordinal_Binary`` = 0
    let mutable ``ordinal_Bit`` = 0
    let mutable ``ordinal_Char`` = 0
    let mutable ``ordinal_Date`` = 0
    let mutable ``ordinal_Datetime`` = 0
    let mutable ``ordinal_Datetime2`` = 0
    let mutable ``ordinal_Datetimeoffset`` = 0
    let mutable ``ordinal_Decimal`` = 0
    let mutable ``ordinal_Float`` = 0
    let mutable ``ordinal_Image`` = 0
    let mutable ``ordinal_Int`` = 0
    let mutable ``ordinal_Money`` = 0
    let mutable ``ordinal_Nchar`` = 0
    let mutable ``ordinal_Ntext`` = 0
    let mutable ``ordinal_Numeric`` = 0
    let mutable ``ordinal_Nvarchar`` = 0
    let mutable ``ordinal_Real`` = 0
    let mutable ``ordinal_Smalldatetime`` = 0
    let mutable ``ordinal_Smallint`` = 0
    let mutable ``ordinal_Smallmoney`` = 0
    let mutable ``ordinal_Text`` = 0
    let mutable ``ordinal_Time`` = 0
    let mutable ``ordinal_Tinyint`` = 0
    let mutable ``ordinal_Uniqueidentifier`` = 0
    let mutable ``ordinal_Varbinary`` = 0
    let mutable ``ordinal_Varchar`` = 0
    let mutable ``ordinal_Xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Bigint`` <- reader.GetOrdinal "Bigint"
      ``ordinal_Binary`` <- reader.GetOrdinal "Binary"
      ``ordinal_Bit`` <- reader.GetOrdinal "Bit"
      ``ordinal_Char`` <- reader.GetOrdinal "Char"
      ``ordinal_Date`` <- reader.GetOrdinal "Date"
      ``ordinal_Datetime`` <- reader.GetOrdinal "Datetime"
      ``ordinal_Datetime2`` <- reader.GetOrdinal "Datetime2"
      ``ordinal_Datetimeoffset`` <- reader.GetOrdinal "Datetimeoffset"
      ``ordinal_Decimal`` <- reader.GetOrdinal "Decimal"
      ``ordinal_Float`` <- reader.GetOrdinal "Float"
      ``ordinal_Image`` <- reader.GetOrdinal "Image"
      ``ordinal_Int`` <- reader.GetOrdinal "Int"
      ``ordinal_Money`` <- reader.GetOrdinal "Money"
      ``ordinal_Nchar`` <- reader.GetOrdinal "Nchar"
      ``ordinal_Ntext`` <- reader.GetOrdinal "Ntext"
      ``ordinal_Numeric`` <- reader.GetOrdinal "Numeric"
      ``ordinal_Nvarchar`` <- reader.GetOrdinal "Nvarchar"
      ``ordinal_Real`` <- reader.GetOrdinal "Real"
      ``ordinal_Smalldatetime`` <- reader.GetOrdinal "Smalldatetime"
      ``ordinal_Smallint`` <- reader.GetOrdinal "Smallint"
      ``ordinal_Smallmoney`` <- reader.GetOrdinal "Smallmoney"
      ``ordinal_Text`` <- reader.GetOrdinal "Text"
      ``ordinal_Time`` <- reader.GetOrdinal "Time"
      ``ordinal_Tinyint`` <- reader.GetOrdinal "Tinyint"
      ``ordinal_Uniqueidentifier`` <- reader.GetOrdinal "Uniqueidentifier"
      ``ordinal_Varbinary`` <- reader.GetOrdinal "Varbinary"
      ``ordinal_Varchar`` <- reader.GetOrdinal "Varchar"
      ``ordinal_Xml`` <- reader.GetOrdinal "Xml"

    let getItem (reader: SqlDataReader) =
      let ``Bigint`` = if reader.IsDBNull ``ordinal_Bigint`` then None else reader.GetInt64 ``ordinal_Bigint`` |> Some
      let ``Binary`` = if reader.IsDBNull ``ordinal_Binary`` then None else reader.GetBytes ``ordinal_Binary`` |> Some
      let ``Bit`` = if reader.IsDBNull ``ordinal_Bit`` then None else reader.GetBoolean ``ordinal_Bit`` |> Some
      let ``Char`` = if reader.IsDBNull ``ordinal_Char`` then None else reader.GetString ``ordinal_Char`` |> Some
      let ``Date`` = if reader.IsDBNull ``ordinal_Date`` then None else reader.GetDateTime ``ordinal_Date`` |> Some
      let ``Datetime`` = if reader.IsDBNull ``ordinal_Datetime`` then None else reader.GetDateTime ``ordinal_Datetime`` |> Some
      let ``Datetime2`` = if reader.IsDBNull ``ordinal_Datetime2`` then None else reader.GetDateTime ``ordinal_Datetime2`` |> Some
      let ``Datetimeoffset`` = if reader.IsDBNull ``ordinal_Datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_Datetimeoffset`` |> Some
      let ``Decimal`` = if reader.IsDBNull ``ordinal_Decimal`` then None else reader.GetDecimal ``ordinal_Decimal`` |> Some
      let ``Float`` = if reader.IsDBNull ``ordinal_Float`` then None else reader.GetDouble ``ordinal_Float`` |> Some
      let ``Image`` = if reader.IsDBNull ``ordinal_Image`` then None else reader.GetBytes ``ordinal_Image`` |> Some
      let ``Int`` = if reader.IsDBNull ``ordinal_Int`` then None else reader.GetInt32 ``ordinal_Int`` |> Some
      let ``Money`` = if reader.IsDBNull ``ordinal_Money`` then None else reader.GetDecimal ``ordinal_Money`` |> Some
      let ``Nchar`` = if reader.IsDBNull ``ordinal_Nchar`` then None else reader.GetString ``ordinal_Nchar`` |> Some
      let ``Ntext`` = if reader.IsDBNull ``ordinal_Ntext`` then None else reader.GetString ``ordinal_Ntext`` |> Some
      let ``Numeric`` = if reader.IsDBNull ``ordinal_Numeric`` then None else reader.GetDecimal ``ordinal_Numeric`` |> Some
      let ``Nvarchar`` = if reader.IsDBNull ``ordinal_Nvarchar`` then None else reader.GetString ``ordinal_Nvarchar`` |> Some
      let ``Real`` = if reader.IsDBNull ``ordinal_Real`` then None else reader.GetFloat ``ordinal_Real`` |> Some
      let ``Smalldatetime`` = if reader.IsDBNull ``ordinal_Smalldatetime`` then None else reader.GetDateTime ``ordinal_Smalldatetime`` |> Some
      let ``Smallint`` = if reader.IsDBNull ``ordinal_Smallint`` then None else reader.GetInt16 ``ordinal_Smallint`` |> Some
      let ``Smallmoney`` = if reader.IsDBNull ``ordinal_Smallmoney`` then None else reader.GetDecimal ``ordinal_Smallmoney`` |> Some
      let ``Text`` = if reader.IsDBNull ``ordinal_Text`` then None else reader.GetString ``ordinal_Text`` |> Some
      let ``Time`` = if reader.IsDBNull ``ordinal_Time`` then None else reader.GetTimeSpan ``ordinal_Time`` |> Some
      let ``Tinyint`` = if reader.IsDBNull ``ordinal_Tinyint`` then None else reader.GetByte ``ordinal_Tinyint`` |> Some
      let ``Uniqueidentifier`` = if reader.IsDBNull ``ordinal_Uniqueidentifier`` then None else reader.GetGuid ``ordinal_Uniqueidentifier`` |> Some
      let ``Varbinary`` = if reader.IsDBNull ``ordinal_Varbinary`` then None else reader.GetBytes ``ordinal_Varbinary`` |> Some
      let ``Varchar`` = if reader.IsDBNull ``ordinal_Varchar`` then None else reader.GetString ``ordinal_Varchar`` |> Some
      let ``Xml`` = if reader.IsDBNull ``ordinal_Xml`` then None else reader.GetString ``ordinal_Xml`` |> Some
      {|
        ``Bigint`` = ``Bigint``
        ``Binary`` = ``Binary``
        ``Bit`` = ``Bit``
        ``Char`` = ``Char``
        ``Date`` = ``Date``
        ``Datetime`` = ``Datetime``
        ``Datetime2`` = ``Datetime2``
        ``Datetimeoffset`` = ``Datetimeoffset``
        ``Decimal`` = ``Decimal``
        ``Float`` = ``Float``
        ``Image`` = ``Image``
        ``Int`` = ``Int``
        ``Money`` = ``Money``
        ``Nchar`` = ``Nchar``
        ``Ntext`` = ``Ntext``
        ``Numeric`` = ``Numeric``
        ``Nvarchar`` = ``Nvarchar``
        ``Real`` = ``Real``
        ``Smalldatetime`` = ``Smalldatetime``
        ``Smallint`` = ``Smallint``
        ``Smallmoney`` = ``Smallmoney``
        ``Text`` = ``Text``
        ``Time`` = ``Time``
        ``Tinyint`` = ``Tinyint``
        ``Uniqueidentifier`` = ``Uniqueidentifier``
        ``Varbinary`` = ``Varbinary``
        ``Varchar`` = ``Varchar``
        ``Xml`` = ``Xml``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableAllTypesNullVoption`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableAllTypesNullVoption``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableAllTypesNullVoption``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableAllTypesNullVoption``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``AllTypesNull``: seq<``TempTableAllTypesNullVoption``.``AllTypesNull``>
      ) =
      [
        TempTableData
          (
            "#AllTypesNull",
            """
            CREATE TABLE #AllTypesNull (
              [Bigint] BIGINT NULL,
              [Binary] BINARY(42) NULL,
              [Bit] BIT NULL,
              [Char] CHAR(42) NULL,
              [Date] DATE NULL,
              [Datetime] DATETIME NULL,
              [Datetime2] DATETIME2(3) NULL,
              [Datetimeoffset] DATETIMEOFFSET(1) NULL,
              [Decimal] DECIMAL(10, 5) NULL,
              [Float] FLOAT(42) NULL,
              [Image] IMAGE NULL,
              [Int] INT NULL,
              [Money] MONEY NULL,
              [Nchar] NCHAR(42) NULL,
              [Ntext] NTEXT NULL,
              [Numeric] NUMERIC(8, 3) NULL,
              [Nvarchar] NVARCHAR(42) NULL,
              [Real] REAL NULL,
              [Smalldatetime] SMALLDATETIME NULL,
              [Smallint] SMALLINT NULL,
              [Smallmoney] SMALLMONEY NULL,
              [Text] TEXT NULL,
              [Time] TIME(1) NULL,
              [Tinyint] TINYINT NULL,
              [Uniqueidentifier] UNIQUEIDENTIFIER NULL,
              [Varbinary] VARBINARY(42) NULL,
              [Varchar] VARCHAR(42) NULL,
              [Xml] XML NULL
            )

            """,
            (``AllTypesNull`` |> Seq.map (fun x -> x.Fields)),
            28,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``allTypesNull``: seq<``TempTableAllTypesNullVoption``.``AllTypesNull``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``allTypesNull``
        )
      ``TempTableAllTypesNullVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``AllTypesNull``: #seq<``TempTableAllTypesNullVoption``.``AllTypesNull``>) dto)
        )
      ``TempTableAllTypesNullVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableInlined`` =


    type ``tempTableInlined`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col2``: string option
        ) : ``tempTableInlined`` =
        [|
          ``Col1`` |> box
          Option.toDbNull ``Col2`` |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTableInlined`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableInlined_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableInlined.sql
SELECT * FROM #tempTableInlined"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

    let getItem (reader: SqlDataReader) =
      let ``Col1`` = reader.GetInt32 ``ordinal_Col1``
      let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetString ``ordinal_Col2`` |> Some
      {|
        ``Col1`` = ``Col1``
        ``Col2`` = ``Col2``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableInlined`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableInlined``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableInlined``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableInlined``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTableInlined``: seq<``TempTableInlined``.``tempTableInlined``>
      ) =
      [
        TempTableData
          (
            "#tempTableInlined",
            """
            CREATE TABLE #tempTableInlined (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
            """,
            (``tempTableInlined`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTableInlined``: seq<``TempTableInlined``.``tempTableInlined``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTableInlined``
        )
      ``TempTableInlined_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTableInlined``: #seq<``TempTableInlined``.``tempTableInlined``>) dto)
        )
      ``TempTableInlined_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableInlinedDynamic`` =


    type ``tempTableInlined`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col2``: string option
        ) : ``tempTableInlined`` =
        [|
          ``Col1`` |> box
          Option.toDbNull ``Col2`` |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTableInlined`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableInlinedDynamic_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableInlinedDynamic.sql
DECLARE @sql NVARCHAR(MAX) =
  'SELECT * FROM #tempTableInlined'

EXEC sp_executesql @sql, N''"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

    let getItem (reader: SqlDataReader) =
      let ``Col1`` = reader.GetInt32 ``ordinal_Col1``
      let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetString ``ordinal_Col2`` |> Some
      {|
        ``Col1`` = ``Col1``
        ``Col2`` = ``Col2``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableInlinedDynamic`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableInlinedDynamic``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableInlinedDynamic``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableInlinedDynamic``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTableInlined``: seq<``TempTableInlinedDynamic``.``tempTableInlined``>
      ) =
      [
        TempTableData
          (
            "#tempTableInlined",
            """
            CREATE TABLE #tempTableInlined (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
            """,
            (``tempTableInlined`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTableInlined``: seq<``TempTableInlinedDynamic``.``tempTableInlined``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTableInlined``
        )
      ``TempTableInlinedDynamic_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTableInlined``: #seq<``TempTableInlinedDynamic``.``tempTableInlined``>) dto)
        )
      ``TempTableInlinedDynamic_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableInlinedWithOtherParams`` =


    type ``tempTableInlined`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col2``: string option
        ) : ``tempTableInlined`` =
        [|
          ``Col1`` |> box
          Option.toDbNull ``Col2`` |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTableInlined`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableInlinedWithOtherParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableInlinedWithOtherParams.sql
DECLARE @_someParam INT = @someParam

SELECT * FROM #tempTableInlined"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

    let getItem (reader: SqlDataReader) =
      let ``Col1`` = reader.GetInt32 ``ordinal_Col1``
      let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetString ``ordinal_Col2`` |> Some
      {|
        ``Col1`` = ``Col1``
        ``Col2`` = ``Col2``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableInlinedWithOtherParams`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableInlinedWithOtherParams``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableInlinedWithOtherParams``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableInlinedWithOtherParams``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTableInlined``: seq<``TempTableInlinedWithOtherParams``.``tempTableInlined``>
      ) =
      [
        TempTableData
          (
            "#tempTableInlined",
            """
            CREATE TABLE #tempTableInlined (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
            """,
            (``tempTableInlined`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTableInlined``: seq<``TempTableInlinedWithOtherParams``.``tempTableInlined``>,
        ``someParam``: int
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@someParam", SqlDbType.Int, Value = ``someParam``)
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTableInlined``
        )
      ``TempTableInlinedWithOtherParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@someParam", SqlDbType.Int, Value = (^a: (member ``SomeParam``: int) dto))
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTableInlined``: #seq<``TempTableInlinedWithOtherParams``.``tempTableInlined``>) dto)
        )
      ``TempTableInlinedWithOtherParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableWithLengthTypes`` =


    type ``tempTableWithLengthTypes`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``binary``: byte [],
          ``char``: string,
          ``nchar``: string,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) : ``tempTableWithLengthTypes`` =
        [|
          ``binary`` |> box
          ``char`` |> box
          ``nchar`` |> box
          ``nvarchar`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
        |]
        |> fun fields -> ``tempTableWithLengthTypes``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTableWithLengthTypes`` =
        [|
          (^a: (member ``binary``: byte []) dto) |> box
          (^a: (member ``char``: string) dto) |> box
          (^a: (member ``nchar``: string) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
        |]
        |> fun fields -> ``tempTableWithLengthTypes``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableWithLengthTypes_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableWithLengthTypes.sql
SELECT * FROM #tempTableWithLengthTypes"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_binary`` = 0
    let mutable ``ordinal_char`` = 0
    let mutable ``ordinal_nchar`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_binary`` <- reader.GetOrdinal "binary"
      ``ordinal_char`` <- reader.GetOrdinal "char"
      ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

    let getItem (reader: SqlDataReader) =
      let ``binary`` = reader.GetBytes ``ordinal_binary``
      let ``char`` = reader.GetString ``ordinal_char``
      let ``nchar`` = reader.GetString ``ordinal_nchar``
      let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
      let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
      let ``varchar`` = reader.GetString ``ordinal_varchar``
      {|
        ``binary`` = ``binary``
        ``char`` = ``char``
        ``nchar`` = ``nchar``
        ``nvarchar`` = ``nvarchar``
        ``varbinary`` = ``varbinary``
        ``varchar`` = ``varchar``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableWithLengthTypes`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableWithLengthTypes``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableWithLengthTypes``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableWithLengthTypes``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTableWithLengthTypes``: seq<``TempTableWithLengthTypes``.``tempTableWithLengthTypes``>
      ) =
      [
        TempTableData
          (
            "#tempTableWithLengthTypes",
            """
            CREATE TABLE #tempTableWithLengthTypes (
              [binary] BINARY(3) NOT NULL,
              [char] CHAR(3) NOT NULL,
              [nchar] NCHAR(3) NOT NULL,
              [nvarchar] NVARCHAR(3) NOT NULL,
              [varbinary] VARBINARY(3) NOT NULL,
              [varchar] VARCHAR(3) NOT NULL
            )

            """,
            (``tempTableWithLengthTypes`` |> Seq.map (fun x -> x.Fields)),
            6,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTableWithLengthTypes``: seq<``TempTableWithLengthTypes``.``tempTableWithLengthTypes``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTableWithLengthTypes``
        )
      ``TempTableWithLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTableWithLengthTypes``: #seq<``TempTableWithLengthTypes``.``tempTableWithLengthTypes``>) dto)
        )
      ``TempTableWithLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  module ``TempTableWithMaxLengthTypes`` =


    type ``tempTableWithMaxLengthTypes`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) : ``tempTableWithMaxLengthTypes`` =
        [|
          ``nvarchar`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
        |]
        |> fun fields -> ``tempTableWithMaxLengthTypes``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTableWithMaxLengthTypes`` =
        [|
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
        |]
        |> fun fields -> ``tempTableWithMaxLengthTypes``(internalUseOnlyValue, fields)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableWithMaxLengthTypes_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- TempTableWithMaxLengthTypes.sql
SELECT * FROM #tempTableWithMaxLengthTypes"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

    let getItem (reader: SqlDataReader) =
      let ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
      let ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
      let ``varchar`` = reader.GetString ``ordinal_varchar``
      {|
        ``nvarchar`` = ``nvarchar``
        ``varbinary`` = ``varbinary``
        ``varchar`` = ``varchar``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``TempTableWithMaxLengthTypes`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``TempTableWithMaxLengthTypes``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableWithMaxLengthTypes``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``TempTableWithMaxLengthTypes``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTableWithMaxLengthTypes``: seq<``TempTableWithMaxLengthTypes``.``tempTableWithMaxLengthTypes``>
      ) =
      [
        TempTableData
          (
            "#tempTableWithMaxLengthTypes",
            """
            CREATE TABLE #tempTableWithMaxLengthTypes (
              [nvarchar] NVARCHAR(MAX) NOT NULL,
              [varbinary] VARBINARY(MAX) NOT NULL,
              [varchar] VARCHAR(MAX) NOT NULL
            )

            """,
            (``tempTableWithMaxLengthTypes`` |> Seq.map (fun x -> x.Fields)),
            3,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTableWithMaxLengthTypes``: seq<``TempTableWithMaxLengthTypes``.``tempTableWithMaxLengthTypes``>
      ) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTableWithMaxLengthTypes``
        )
      ``TempTableWithMaxLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTableWithMaxLengthTypes``: #seq<``TempTableWithMaxLengthTypes``.``tempTableWithMaxLengthTypes``>) dto)
        )
      ``TempTableWithMaxLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, tempTableData, this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``UserDefinedTableType_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- UserDefinedTableType.sql
SELECT * FROM @tvp"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Foo`` = 0
    let mutable ``ordinal_Bar`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
      ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

    let getItem (reader: SqlDataReader) =
      let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
      let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
      {|
        ``Foo`` = ``Foo``
        ``Bar`` = ``Bar``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReader() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
      }

    /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReader() =
      let sqlParams = getSqlParams ()
      executeReader connStr conn tran configureConn (configureCmd sqlParams) []

    /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

    /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
    member this.AsyncExecuteReaderSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
      }

    /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
    member this.ExecuteReaderSingle() =
      let sqlParams = getSqlParams ()
      executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


  type ``UserDefinedTableType`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``UserDefinedTableType``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``UserDefinedTableType``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``UserDefinedTableType``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``tvp``: seq<TableTypes.``dbo``.``MultiColNull``>
      ) =
      let getSqlParams () =
        [|
          SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty ``tvp``)
        |]
      ``UserDefinedTableType_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
        |]
      ``UserDefinedTableType_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``Option`` =


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``In_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- Option/In.sql
SELECT @param1"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let initOrdinals = ignore<SqlDataReader>

        let getItem (reader: SqlDataReader) =
          if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.LazyExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecute() =
          let sqlParams = getSqlParams ()
          executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          let sqlParams = getSqlParams ()
          executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          let sqlParams = getSqlParams ()
          executeReader connStr conn tran configureConn (configureCmd sqlParams) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          let sqlParams = getSqlParams ()
          executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


      type ``In`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``In``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``In``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``In``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``param1``: string option
          ) =
          let getSqlParams () =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
            |]
          ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
            |]
          ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``Out_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- Option/Out.sql
SELECT @param1"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let initOrdinals = ignore<SqlDataReader>

        let getItem (reader: SqlDataReader) =
          if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.LazyExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecute() =
          let sqlParams = getSqlParams ()
          executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          let sqlParams = getSqlParams ()
          executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          let sqlParams = getSqlParams ()
          executeReader connStr conn tran configureConn (configureCmd sqlParams) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          let sqlParams = getSqlParams ()
          executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


      type ``Out`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``Out``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``Out``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``Out``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``param1``: string option
          ) =
          let getSqlParams () =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
            |]
          ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
            |]
          ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


      type ``TableOutWithDto`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """-- Option/TableOutWithDto.sql
SELECT * FROM OptionTableWithDto"""
          userConfigureCmd cmd

        let mutable ``ordinal_Col1`` = 0
        let mutable ``ordinal_Col2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
          ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

        let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``OptionTableWithDto`` =
          let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
          let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
          {
            ``Col1`` = ``Col1``
            ``Col2`` = ``Col2``
          }

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``TableOutWithDto``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TableOutWithDto``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``TableOutWithDto``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecute() =
          executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


      type ``TableOutWithoutDto`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """-- Option/TableOutWithoutDto.sql
SELECT * FROM OptionTableWithoutDto"""
          userConfigureCmd cmd

        let mutable ``ordinal_Col1`` = 0
        let mutable ``ordinal_Col2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
          ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

        let getItem (reader: SqlDataReader) =
          let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
          let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
          {|
            ``Col1`` = ``Col1``
            ``Col2`` = ``Col2``
          |}

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``TableOutWithoutDto``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TableOutWithoutDto``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``TableOutWithoutDto``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecute() =
          executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``TvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- Option/TvpInOut.sql
SELECT * FROM @tvp"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_Foo`` = 0
        let mutable ``ordinal_Bar`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
          ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

        let getItem (reader: SqlDataReader) =
          let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
          {|
            ``Foo`` = ``Foo``
            ``Bar`` = ``Bar``
          |}

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.LazyExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecute() =
          let sqlParams = getSqlParams ()
          executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          let sqlParams = getSqlParams ()
          executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          let sqlParams = getSqlParams ()
          executeReader connStr conn tran configureConn (configureCmd sqlParams) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          let sqlParams = getSqlParams ()
          executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


      type ``TvpInOut`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``TvpInOut``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TvpInOut``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``TvpInOut``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``tvp``: seq<TableTypes.``dbo``.``MultiColNull``>
          ) =
          let getSqlParams () =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty ``tvp``)
            |]
          ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = boxNullIfEmpty (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
            |]
          ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``SubPath`` =


      type ``SelectAllFromTable`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """-- SubPath/SelectAllFromTable.sql
SELECT * FROM Table1"""
          userConfigureCmd cmd

        let mutable ``ordinal_TableCol1`` = 0
        let mutable ``ordinal_TableCol2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
          ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

        let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``Table1`` =
          let ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
          let ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
          {
            ``TableCol1`` = ``TableCol1``
            ``TableCol2`` = ``TableCol2``
          }

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``SelectAllFromTable``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``SelectAllFromTable``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``SelectAllFromTable``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecute() =
          executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


  module ``TableScriptSubdir`` =


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``dbo_TableWithIdentityCol_GetById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- TableScriptSubdir/dbo_TableWithIdentityCol_GetById
SELECT
  [Id],
  [Foo],
  [BAR]
FROM
  [dbo].[TableWithIdentityCol]
WHERE
  [Id] = @id"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_Id`` = 0
        let mutable ``ordinal_Foo`` = 0
        let mutable ``ordinal_BAR`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Id`` <- reader.GetOrdinal "Id"
          ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
          ``ordinal_BAR`` <- reader.GetOrdinal "BAR"

        let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``TableWithIdentityCol`` =
          let ``Id`` = reader.GetInt32 ``ordinal_Id``
          let ``Foo`` = reader.GetInt64 ``ordinal_Foo``
          let ``BAR`` = if reader.IsDBNull ``ordinal_BAR`` then None else reader.GetDateTimeOffset ``ordinal_BAR`` |> Some
          {
            ``Id`` = ``Id``
            ``Foo`` = ``Foo``
            ``BAR`` = ``BAR``
          }

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.LazyExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecute() =
          let sqlParams = getSqlParams ()
          executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          let sqlParams = getSqlParams ()
          executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          let sqlParams = getSqlParams ()
          executeReader connStr conn tran configureConn (configureCmd sqlParams) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          let sqlParams = getSqlParams ()
          executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


      type ``dbo_TableWithIdentityCol_GetById`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``dbo_TableWithIdentityCol_GetById``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``dbo_TableWithIdentityCol_GetById``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``dbo_TableWithIdentityCol_GetById``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``id``: int
          ) =
          let getSqlParams () =
            [|
              SqlParameter("id", SqlDbType.Int, Value = ``id``)
            |]
          ``dbo_TableWithIdentityCol_GetById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("id", SqlDbType.Int, Value = (^a: (member ``Id``: int) dto))
            |]
          ``dbo_TableWithIdentityCol_GetById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``TableScriptConfiguredWithScriptRules_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- TableScriptSubdir/TableScriptConfiguredWithScriptRules
INSERT INTO [dbo].[TableWithIdentityCol]
(
  [Foo],
  [BAR]
)
VALUES
(
  @foo,
  @bAR
)"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


      type ``TableScriptConfiguredWithScriptRules`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``TableScriptConfiguredWithScriptRules``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TableScriptConfiguredWithScriptRules``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``TableScriptConfiguredWithScriptRules``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``foo``: int64,
            ``bAR``: DateTimeOffset voption
          ) =
          let getSqlParams () =
            [|
              SqlParameter("foo", SqlDbType.BigInt, Value = ``foo``)
              SqlParameter("bAR", SqlDbType.DateTimeOffset, Size = 10, Value = ValueOption.toDbNull ``bAR``)
            |]
          ``TableScriptConfiguredWithScriptRules_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("foo", SqlDbType.BigInt, Value = (^a: (member ``Foo``: int64) dto))
              SqlParameter("bAR", SqlDbType.DateTimeOffset, Size = 10, Value = ValueOption.toDbNull (^a: (member ``BAR``: DateTimeOffset voption) dto))
            |]
          ``TableScriptConfiguredWithScriptRules_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``Voption`` =


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``In_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- Voption/In.sql
SELECT @param1"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let initOrdinals = ignore<SqlDataReader>

        let getItem (reader: SqlDataReader) =
          if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.LazyExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecute() =
          let sqlParams = getSqlParams ()
          executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          let sqlParams = getSqlParams ()
          executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          let sqlParams = getSqlParams ()
          executeReader connStr conn tran configureConn (configureCmd sqlParams) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          let sqlParams = getSqlParams ()
          executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


      type ``In`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``In``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``In``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``In``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``param1``: string voption
          ) =
          let getSqlParams () =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull ``param1``)
            |]
          ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull (^a: (member ``Param1``: string voption) dto))
            |]
          ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``Out_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- Voption/Out.sql
SELECT @param1"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let initOrdinals = ignore<SqlDataReader>

        let getItem (reader: SqlDataReader) =
          if reader.IsDBNull 0 then ValueNone else reader.GetString 0 |> ValueSome

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.LazyExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecute() =
          let sqlParams = getSqlParams ()
          executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQuerySingleAsyncVoption connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          let sqlParams = getSqlParams ()
          executeQuerySingleVoption connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          let sqlParams = getSqlParams ()
          executeReader connStr conn tran configureConn (configureCmd sqlParams) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          let sqlParams = getSqlParams ()
          executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


      type ``Out`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``Out``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``Out``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``Out``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``param1``: string option
          ) =
          let getSqlParams () =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
            |]
          ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
            |]
          ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


      type ``TableOutWithDto`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """-- Voption/TableOutWithDto.sql
SELECT * FROM VoptionTableWithDto"""
          userConfigureCmd cmd

        let mutable ``ordinal_Col1`` = 0
        let mutable ``ordinal_Col2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
          ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

        let getItem (reader: SqlDataReader) : TableDtos.``dbo``.``VoptionTableWithDto`` =
          let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
          let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
          {
            ``Col1`` = ``Col1``
            ``Col2`` = ``Col2``
          }

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``TableOutWithDto``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TableOutWithDto``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``TableOutWithDto``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecute() =
          executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsyncVoption connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingleVoption connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


      type ``TableOutWithoutDto`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """-- Voption/TableOutWithoutDto.sql
SELECT * FROM VoptionTableWithoutDto"""
          userConfigureCmd cmd

        let mutable ``ordinal_Col1`` = 0
        let mutable ``ordinal_Col2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
          ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

        let getItem (reader: SqlDataReader) =
          let ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
          let ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
          {|
            ``Col1`` = ``Col1``
            ``Col2`` = ``Col2``
          |}

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``TableOutWithoutDto``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TableOutWithoutDto``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``TableOutWithoutDto``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecute() =
          executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsyncVoption connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingleVoption connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          executeReaderAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          executeReader connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          executeReaderSingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          executeReaderSingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) []


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``TvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- Voption/TvpInOut.sql
SELECT * FROM @tvp"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_Foo`` = 0
        let mutable ``ordinal_Bar`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
          ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

        let getItem (reader: SqlDataReader) =
          let ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then ValueNone else reader.GetInt32 ``ordinal_Foo`` |> ValueSome
          let ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then ValueNone else reader.GetString ``ordinal_Bar`` |> ValueSome
          {|
            ``Foo`` = ``Foo``
            ``Bar`` = ``Bar``
          |}

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.LazyExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecute() =
          let sqlParams = getSqlParams ()
          executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeQuerySingleAsyncVoption connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          let sqlParams = getSqlParams ()
          executeQuerySingleVoption connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReader() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderAsync(ct) |> Async.AwaitTask
          }

        /// Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReader() =
          let sqlParams = getSqlParams ()
          executeReader connStr conn tran configureConn (configureCmd sqlParams) []

        /// Same as ExecuteReaderAsync, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingleAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeReaderSingleAsync connStr conn tran configureConn (configureCmd sqlParams) [] (defaultArg cancellationToken CancellationToken.None)

        /// Same as AsyncExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use!' to ensure disposal of all resources managed by Facil for this query.
        member this.AsyncExecuteReaderSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteReaderSingleAsync(ct) |> Async.AwaitTask
          }

        /// Same as ExecuteReader, but uses CommandBehavior.SingleRow. Returns a value wrapping a SqlDataReader. The wrapper should be bound with 'use' to ensure disposal of all resources managed by Facil for this query.
        member this.ExecuteReaderSingle() =
          let sqlParams = getSqlParams ()
          executeReaderSingle connStr conn tran configureConn (configureCmd sqlParams) []


      type ``TvpInOut`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``TvpInOut``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TvpInOut``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``TvpInOut``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``tvp``: seq<TableTypes.``dbo``.``MultiColNullVoption``>
          ) =
          let getSqlParams () =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = boxNullIfEmpty ``tvp``)
            |]
          ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = boxNullIfEmpty (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNullVoption``>) dto))
            |]
          ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)
